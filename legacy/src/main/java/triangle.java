public class GlobalMembersTriangle
{

	// A few forward declarations.                                               

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//String readline();
//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//String findfield();
	//#endif // not TRILIBRARY


	// Global constants.                                                         

	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	public static REAL splitter; // Used to split REAL factors for exact multiplication.
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	public static REAL epsilon; // Floating-point machine epsilon.
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	public static REAL resulterrbound;
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	public static REAL ccwerrboundA;
	public static REAL ccwerrboundB;
	public static REAL ccwerrboundC;
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	public static REAL iccerrboundA;
	public static REAL iccerrboundB;
	public static REAL iccerrboundC;
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	public static REAL o3derrboundA;
	public static REAL o3derrboundB;
	public static REAL o3derrboundC;

	// Random number seed is not constant, but I've made it global anyway.       

	public static int randomseed; // Current random number seed.


	//***************************************************************************
	//                                                                           
	//  Mesh manipulation primitives.  Each triangle contains three pointers to  
	//  other triangles, with orientations.  Each pointer points not to the      
	//  first byte of a triangle, but to one of the first three bytes of a       
	//  triangle.  It is necessary to extract both the triangle itself and the   
	//  orientation.  To save memory, I keep both pieces of information in one   
	//  pointer.  To make this possible, I assume that all triangles are aligned 
	//  to four-byte boundaries.  The decode() routine below decodes a pointer,  
	//  extracting an orientation (in the range 0 to 2) and a pointer to the     
	//  beginning of a triangle.  The encode() routine compresses a pointer to a 
	//  triangle and an orientation into a single pointer.  My assumptions that  
	//  triangles are four-byte-aligned and that the `unsigned long' type is     
	//  long enough to hold a pointer are two of the few kludges in this program.
	//                                                                           
	//  Subsegments are manipulated similarly.  A pointer to a subsegment        
	//  carries both an address and an orientation in the range 0 to 1.          
	//                                                                           
	//  The other primitives take an oriented triangle or oriented subsegment,   
	//  and return an oriented triangle or oriented subsegment or vertex; or     
	//  they change the connections in the data structure.                       
	//                                                                           
	//  Below, triangles and subsegments are denoted by their vertices.  The     
	//  triangle abc has origin (org) a, destination (dest) b, and apex (apex)   
	//  c.  These vertices occur in counterclockwise order about the triangle.   
	//  The handle abc may simultaneously denote vertex a, edge ab, and triangle 
	//  abc.                                                                     
	//                                                                           
	//  Similarly, the subsegment ab has origin (sorg) a and destination (sdest) 
	//  b.  If ab is thought to be directed upward (with b directly above a),    
	//  then the handle ab is thought to grasp the right side of ab, and may     
	//  simultaneously denote vertex a and edge ab.                              
	//                                                                           
	//  An asterisk (*) denotes a vertex whose identity is unknown.              
	//                                                                           
	//  Given this notation, a partial list of mesh manipulation primitives      
	//  follows.                                                                 
	//                                                                           
	//                                                                           
	//  For triangles:                                                           
	//                                                                           
	//  sym:  Find the abutting triangle; same edge.                             
	//  sym(abc) -> ba*                                                          
	//                                                                           
	//  lnext:  Find the next edge (counterclockwise) of a triangle.             
	//  lnext(abc) -> bca                                                        
	//                                                                           
	//  lprev:  Find the previous edge (clockwise) of a triangle.                
	//  lprev(abc) -> cab                                                        
	//                                                                           
	//  onext:  Find the next edge counterclockwise with the same origin.        
	//  onext(abc) -> ac*                                                        
	//                                                                           
	//  oprev:  Find the next edge clockwise with the same origin.               
	//  oprev(abc) -> a*b                                                        
	//                                                                           
	//  dnext:  Find the next edge counterclockwise with the same destination.   
	//  dnext(abc) -> *ba                                                        
	//                                                                           
	//  dprev:  Find the next edge clockwise with the same destination.          
	//  dprev(abc) -> cb*                                                        
	//                                                                           
	//  rnext:  Find the next edge (counterclockwise) of the adjacent triangle.  
	//  rnext(abc) -> *a*                                                        
	//                                                                           
	//  rprev:  Find the previous edge (clockwise) of the adjacent triangle.     
	//  rprev(abc) -> b**                                                        
	//                                                                           
	//  org:  Origin          dest:  Destination          apex:  Apex            
	//  org(abc) -> a         dest(abc) -> b              apex(abc) -> c         
	//                                                                           
	//  bond:  Bond two triangles together at the resepective handles.           
	//  bond(abc, bad)                                                           
	//                                                                           
	//                                                                           
	//  For subsegments:                                                         
	//                                                                           
	//  ssym:  Reverse the orientation of a subsegment.                          
	//  ssym(ab) -> ba                                                           
	//                                                                           
	//  spivot:  Find adjoining subsegment with the same origin.                 
	//  spivot(ab) -> a*                                                         
	//                                                                           
	//  snext:  Find next subsegment in sequence.                                
	//  snext(ab) -> b*                                                          
	//                                                                           
	//  sorg:  Origin                      sdest:  Destination                   
	//  sorg(ab) -> a                      sdest(ab) -> b                        
	//                                                                           
	//  sbond:  Bond two subsegments together at the respective origins.         
	//  sbond(ab, ac)                                                            
	//                                                                           
	//                                                                           
	//  For interacting tetrahedra and subfacets:                                
	//                                                                           
	//  tspivot:  Find a subsegment abutting a triangle.                         
	//  tspivot(abc) -> ba                                                       
	//                                                                           
	//  stpivot:  Find a triangle abutting a subsegment.                         
	//  stpivot(ab) -> ba*                                                       
	//                                                                           
	//  tsbond:  Bond a triangle to a subsegment.                                
	//  tsbond(abc, ba)                                                          
	//                                                                           
	//***************************************************************************

	//******** Mesh manipulation primitives begin here                   ********
	//*                                                                         *
	//*                                                                         *

	// Fast lookup arrays to speed some of the mesh manipulation primitives.     

	public static int[] plus1mod3 = {1, 2, 0};
	public static int[] minus1mod3 = {2, 0, 1};

	//******** Primitives for triangles                                  ********
	//                                                                           
	//                                                                           

	// decode() converts a pointer to an oriented triangle.  The orientation is  
	//   extracted from the two least significant bits of the pointer.           

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define decode(ptr, otri) (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri).orient)

	// encode() compresses an oriented triangle into a single pointer.  It       
	//   relies on the assumption that all triangles are aligned to four-byte    
	//   boundaries, so the two least significant bits of (otri).tri are zero.   

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define encode(otri) (triangle) ((unsigned long) (otri).tri | (unsigned long) (otri).orient)

	// The following handle manipulation primitives are all described by Guibas  
	//   and Stolfi.  However, Guibas and Stolfi use an edge-based data          
	//   structure, whereas I use a triangle-based data structure.               

	// sym() finds the abutting triangle, on the same edge.  Note that the edge  
	//   direction is necessarily reversed, because the handle specified by an   
	//   oriented triangle is directed counterclockwise around the triangle.     

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define sym(otri1, otri2) ptr = (otri1).tri[(otri1).orient]; (otri2).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri2).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri2).orient);

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define symself(otri) ptr = (otri).tri[(otri).orient]; (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri).orient);

	// lnext() finds the next edge (counterclockwise) of a triangle.             

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define lnext(otri1, otri2) (otri2).tri = (otri1).tri; (otri2).orient = plus1mod3[(otri1).orient]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define lnextself(otri) (otri).orient = plus1mod3[(otri).orient]

	// lprev() finds the previous edge (clockwise) of a triangle.                

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define lprev(otri1, otri2) (otri2).tri = (otri1).tri; (otri2).orient = minus1mod3[(otri1).orient]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define lprevself(otri) (otri).orient = minus1mod3[(otri).orient]

	// onext() spins counterclockwise around a vertex; that is, it finds the     
	//   next edge with the same origin in the counterclockwise direction.  This 
	//   edge is part of a different triangle.                                   

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define onext(otri1, otri2) (otri2).tri = (otri1).tri; (otri2).orient = minus1mod3[(otri1).orient]; ptr = (otri2).tri[(otri2).orient]; (otri2).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri2).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri2).orient);;

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define onextself(otri) (otri).orient = minus1mod3[(otri).orient]; ptr = (otri).tri[(otri).orient]; (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri).orient);;

	// oprev() spins clockwise around a vertex; that is, it finds the next edge  
	//   with the same origin in the clockwise direction.  This edge is part of  
	//   a different triangle.                                                   

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define oprev(otri1, otri2) ptr = (otri1).tri[(otri1).orient]; (otri2).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri2).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri2).orient);; (otri2).orient = plus1mod3[(otri2).orient];

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define oprevself(otri) ptr = (otri).tri[(otri).orient]; (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri).orient);; (otri).orient = plus1mod3[(otri).orient];

	// dnext() spins counterclockwise around a vertex; that is, it finds the     
	//   next edge with the same destination in the counterclockwise direction.  
	//   This edge is part of a different triangle.                              

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define dnext(otri1, otri2) ptr = (otri1).tri[(otri1).orient]; (otri2).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri2).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri2).orient);; (otri2).orient = minus1mod3[(otri2).orient];

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define dnextself(otri) ptr = (otri).tri[(otri).orient]; (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri).orient);; (otri).orient = minus1mod3[(otri).orient];

	// dprev() spins clockwise around a vertex; that is, it finds the next edge  
	//   with the same destination in the clockwise direction.  This edge is     
	//   part of a different triangle.                                           

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define dprev(otri1, otri2) (otri2).tri = (otri1).tri; (otri2).orient = plus1mod3[(otri1).orient]; ptr = (otri2).tri[(otri2).orient]; (otri2).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri2).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri2).orient);;

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define dprevself(otri) (otri).orient = plus1mod3[(otri).orient]; ptr = (otri).tri[(otri).orient]; (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri).orient);;

	// rnext() moves one edge counterclockwise about the adjacent triangle.      
	//   (It's best understood by reading Guibas and Stolfi.  It involves        
	//   changing triangles twice.)                                              

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define rnext(otri1, otri2) ptr = (otri1).tri[(otri1).orient]; (otri2).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri2).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri2).orient);; (otri2).orient = plus1mod3[(otri2).orient]; ptr = (otri2).tri[(otri2).orient]; (otri2).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri2).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri2).orient);;

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define rnextself(otri) ptr = (otri).tri[(otri).orient]; (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri).orient);; (otri).orient = plus1mod3[(otri).orient]; ptr = (otri).tri[(otri).orient]; (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri).orient);;

	// rprev() moves one edge clockwise about the adjacent triangle.             
	//   (It's best understood by reading Guibas and Stolfi.  It involves        
	//   changing triangles twice.)                                              

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define rprev(otri1, otri2) ptr = (otri1).tri[(otri1).orient]; (otri2).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri2).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri2).orient);; (otri2).orient = minus1mod3[(otri2).orient]; ptr = (otri2).tri[(otri2).orient]; (otri2).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri2).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri2).orient);;

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define rprevself(otri) ptr = (otri).tri[(otri).orient]; (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri).orient);; (otri).orient = minus1mod3[(otri).orient]; ptr = (otri).tri[(otri).orient]; (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri).orient);;

	// These primitives determine or set the origin, destination, or apex of a   
	// triangle.                                                                 

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define org(otri, vertexptr) vertexptr = (vertex) (otri).tri[plus1mod3[(otri).orient] + 3]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define dest(otri, vertexptr) vertexptr = (vertex) (otri).tri[minus1mod3[(otri).orient] + 3]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define apex(otri, vertexptr) vertexptr = (vertex) (otri).tri[(otri).orient + 3]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setorg(otri, vertexptr) (otri).tri[plus1mod3[(otri).orient] + 3] = (triangle) vertexptr

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setdest(otri, vertexptr) (otri).tri[minus1mod3[(otri).orient] + 3] = (triangle) vertexptr

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setapex(otri, vertexptr) (otri).tri[(otri).orient + 3] = (triangle) vertexptr

	// Bond two triangles together.                                              

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define bond(otri1, otri2) (otri1).tri[(otri1).orient] = (triangle) ((unsigned long) (otri2).tri | (unsigned long) (otri2).orient); (otri2).tri[(otri2).orient] = (triangle) ((unsigned long) (otri1).tri | (unsigned long) (otri1).orient)

	// Dissolve a bond (from one side).  Note that the other triangle will still 
	//   think it's connected to this triangle.  Usually, however, the other     
	//   triangle is being deleted entirely, or bonded to another triangle, so   
	//   it doesn't matter.                                                      

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define dissolve(otri) (otri).tri[(otri).orient] = (triangle) m->dummytri

	// Copy an oriented triangle.                                                

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define otricopy(otri1, otri2) (otri2).tri = (otri1).tri; (otri2).orient = (otri1).orient

	// Test for equality of oriented triangles.                                  

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define otriequal(otri1, otri2) (((otri1).tri == (otri2).tri) && ((otri1).orient == (otri2).orient))

	// Primitives to infect or cure a triangle with the virus.  These rely on    
	//   the assumption that all subsegments are aligned to four-byte boundaries.

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define infect(otri) (otri).tri[6] = (triangle) ((unsigned long) (otri).tri[6] | (unsigned long) 2l)

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define uninfect(otri) (otri).tri[6] = (triangle) ((unsigned long) (otri).tri[6] & ~ (unsigned long) 2l)

	// Test a triangle for viral infection.                                      

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define infected(otri) (((unsigned long) (otri).tri[6] & (unsigned long) 2l) != 0l)

	// Check or set a triangle's attributes.                                     

	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define elemattribute(otri, attnum) ((REAL *) (otri).tri)[m->elemattribindex + (attnum)]

	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setelemattribute(otri, attnum, value) ((REAL *) (otri).tri)[m->elemattribindex + (attnum)] = value

	// Check or set a triangle's maximum area bound.                             

	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define areabound(otri) ((REAL *) (otri).tri)[m->areaboundindex]

	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setareabound(otri, value) ((REAL *) (otri).tri)[m->areaboundindex] = value

	// Check or set a triangle's deallocation.  Its second pointer is set to     
	//   NULL to indicate that it is not allocated.  (Its first pointer is used  
	//   for the stack of dead items.)  Its fourth pointer (its first vertex)    
	//   is set to NULL in case a `badtriang' structure points to it.            

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define deadtri(tria) ((tria)[1] == (triangle) NULL)

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define killtri(tria) (tria)[1] = (triangle) NULL; (tria)[3] = (triangle) NULL

	//******** Primitives for subsegments                                ********
	//                                                                           
	//                                                                           

	// sdecode() converts a pointer to an oriented subsegment.  The orientation  
	//   is extracted from the least significant bit of the pointer.  The two    
	//   least significant bits (one for orientation, one for viral infection)   
	//   are masked out to produce the real pointer.                             

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define sdecode(sptr, osub) (osub).ssorient = (int) ((unsigned long) (sptr) & (unsigned long) 1l); (osub).ss = (subseg *) ((unsigned long) (sptr) & ~ (unsigned long) 3l)

	// sencode() compresses an oriented subsegment into a single pointer.  It    
	//   relies on the assumption that all subsegments are aligned to two-byte   
	//   boundaries, so the least significant bit of (osub).ss is zero.          

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define sencode(osub) (subseg) ((unsigned long) (osub).ss | (unsigned long) (osub).ssorient)

	// ssym() toggles the orientation of a subsegment.                           

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define ssym(osub1, osub2) (osub2).ss = (osub1).ss; (osub2).ssorient = 1 - (osub1).ssorient

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define ssymself(osub) (osub).ssorient = 1 - (osub).ssorient

	// spivot() finds the other subsegment (from the same segment) that shares   
	//   the same origin.                                                        

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define spivot(osub1, osub2) sptr = (osub1).ss[(osub1).ssorient]; (osub2).ssorient = (int) ((unsigned long) (sptr) & (unsigned long) 1l); (osub2).ss = (subseg *) ((unsigned long) (sptr) & ~ (unsigned long) 3l)

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define spivotself(osub) sptr = (osub).ss[(osub).ssorient]; (osub).ssorient = (int) ((unsigned long) (sptr) & (unsigned long) 1l); (osub).ss = (subseg *) ((unsigned long) (sptr) & ~ (unsigned long) 3l)

	// snext() finds the next subsegment (from the same segment) in sequence;    
	//   one whose origin is the input subsegment's destination.                 

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define snext(osub1, osub2) sptr = (osub1).ss[1 - (osub1).ssorient]; (osub2).ssorient = (int) ((unsigned long) (sptr) & (unsigned long) 1l); (osub2).ss = (subseg *) ((unsigned long) (sptr) & ~ (unsigned long) 3l)

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define snextself(osub) sptr = (osub).ss[1 - (osub).ssorient]; (osub).ssorient = (int) ((unsigned long) (sptr) & (unsigned long) 1l); (osub).ss = (subseg *) ((unsigned long) (sptr) & ~ (unsigned long) 3l)

	// These primitives determine or set the origin or destination of a          
	//   subsegment or the segment that includes it.                             

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define sorg(osub, vertexptr) vertexptr = (vertex) (osub).ss[2 + (osub).ssorient]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define sdest(osub, vertexptr) vertexptr = (vertex) (osub).ss[3 - (osub).ssorient]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setsorg(osub, vertexptr) (osub).ss[2 + (osub).ssorient] = (subseg) vertexptr

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setsdest(osub, vertexptr) (osub).ss[3 - (osub).ssorient] = (subseg) vertexptr

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define segorg(osub, vertexptr) vertexptr = (vertex) (osub).ss[4 + (osub).ssorient]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define segdest(osub, vertexptr) vertexptr = (vertex) (osub).ss[5 - (osub).ssorient]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setsegorg(osub, vertexptr) (osub).ss[4 + (osub).ssorient] = (subseg) vertexptr

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setsegdest(osub, vertexptr) (osub).ss[5 - (osub).ssorient] = (subseg) vertexptr

	// These primitives read or set a boundary marker.  Boundary markers are     
	//   used to hold user-defined tags for setting boundary conditions in       
	//   finite element solvers.                                                 

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define mark(osub) (* (int *) ((osub).ss + 8))

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setmark(osub, value) * (int *) ((osub).ss + 8) = value

	// Bond two subsegments together.                                            

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define sbond(osub1, osub2) (osub1).ss[(osub1).ssorient] = (subseg) ((unsigned long) (osub2).ss | (unsigned long) (osub2).ssorient); (osub2).ss[(osub2).ssorient] = (subseg) ((unsigned long) (osub1).ss | (unsigned long) (osub1).ssorient)

	// Dissolve a subsegment bond (from one side).  Note that the other          
	//   subsegment will still think it's connected to this subsegment.          

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define sdissolve(osub) (osub).ss[(osub).ssorient] = (subseg) m->dummysub

	// Copy a subsegment.                                                        

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define subsegcopy(osub1, osub2) (osub2).ss = (osub1).ss; (osub2).ssorient = (osub1).ssorient

	// Test for equality of subsegments.                                         

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define subsegequal(osub1, osub2) (((osub1).ss == (osub2).ss) && ((osub1).ssorient == (osub2).ssorient))

	// Check or set a subsegment's deallocation.  Its second pointer is set to   
	//   NULL to indicate that it is not allocated.  (Its first pointer is used  
	//   for the stack of dead items.)  Its third pointer (its first vertex)     
	//   is set to NULL in case a `badsubseg' structure points to it.            

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define deadsubseg(sub) ((sub)[1] == (subseg) NULL)

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define killsubseg(sub) (sub)[1] = (subseg) NULL; (sub)[2] = (subseg) NULL

	//******** Primitives for interacting triangles and subsegments      ********
	//                                                                           
	//                                                                           

	// tspivot() finds a subsegment abutting a triangle.                         

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define tspivot(otri, osub) sptr = (subseg) (otri).tri[6 + (otri).orient]; (osub).ssorient = (int) ((unsigned long) (sptr) & (unsigned long) 1l); (osub).ss = (subseg *) ((unsigned long) (sptr) & ~ (unsigned long) 3l)

	// stpivot() finds a triangle abutting a subsegment.  It requires that the   
	//   variable `ptr' of type `triangle' be defined.                           

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define stpivot(osub, otri) ptr = (triangle) (osub).ss[6 + (osub).ssorient]; (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l); (otri).tri = (triangle *) ((unsigned long) (ptr) ^ (unsigned long) (otri).orient)

	// Bond a triangle to a subsegment.                                          

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define tsbond(otri, osub) (otri).tri[6 + (otri).orient] = (triangle) (subseg) ((unsigned long) (osub).ss | (unsigned long) (osub).ssorient); (osub).ss[6 + (osub).ssorient] = (subseg) (triangle) ((unsigned long) (otri).tri | (unsigned long) (otri).orient)

	// Dissolve a bond (from the triangle side).                                 

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define tsdissolve(otri) (otri).tri[6 + (otri).orient] = (triangle) m->dummysub

	// Dissolve a bond (from the subsegment side).                               

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define stdissolve(osub) (osub).ss[6 + (osub).ssorient] = (subseg) m->dummytri

	//******** Primitives for vertices                                   ********
	//                                                                           
	//                                                                           

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define vertexmark(vx) ((int *) (vx))[m->vertexmarkindex]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setvertexmark(vx, value) ((int *) (vx))[m->vertexmarkindex] = value

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define vertextype(vx) ((int *) (vx))[m->vertexmarkindex + 1]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setvertextype(vx, value) ((int *) (vx))[m->vertexmarkindex + 1] = value

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define vertex2tri(vx) ((triangle *) (vx))[m->vertex2triindex]

	//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
	//#define setvertex2tri(vx, value) ((triangle *) (vx))[m->vertex2triindex] = value

	//*                                                                         *
	//*                                                                         *
	//******** Mesh manipulation primitives end here                     ********

	//******** User-defined triangle evaluation routine begins here      ********
	//*                                                                         *
	//*                                                                         *

	//***************************************************************************
	//                                                                           
	//  triunsuitable()   Determine if a triangle is unsuitable, and thus must   
	//                    be further refined.                                    
	//                                                                           
	//  You may write your own procedure that decides whether or not a selected  
	//  triangle is too big (and needs to be refined).  There are two ways to do 
	//  this.                                                                    
	//                                                                           
	//  (1)  Modify the procedure `triunsuitable' below, then recompile          
	//  Triangle.                                                                
	//                                                                           
	//  (2)  Define the symbol EXTERNAL_TEST (either by adding the definition    
	//  to this file, or by using the appropriate compiler switch).  This way,   
	//  you can compile triangle.c separately from your test.  Write your own    
	//  `triunsuitable' procedure in a separate C file (using the same prototype 
	//  as below).  Compile it and link the object code with triangle.o.         
	//                                                                           
	//  This procedure returns 1 if the triangle is too large and should be      
	//  refined; 0 otherwise.                                                    
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if EXTERNAL_TEST

//C++ TO JAVA CONVERTER TODO TASK: The implementation of the following method could not be found:
	//int triunsuitable();

	//#else

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	public static int triunsuitable(RefObject<REAL> triorg, RefObject<REAL> tridest, RefObject<REAL> triapex, REAL area)
	//#else
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	RefObject<REAL> TempRefObject = new RefObject<REAL>(triorg);
	RefObject<REAL> TempRefObject2 = new RefObject<REAL>(tridest);
	RefObject<REAL> TempRefObject3 = new RefObject<REAL>(triapex);
	int triunsuitable(TempRefObject, TempRefObject2, TempRefObject3, area)
	triorg = TempRefObject.argvalue;
	tridest = TempRefObject2.argvalue;
	triapex = TempRefObject3.argvalue;
	public static REAL triorg; // The triangle's origin vertex.
	public static REAL tridest; // The triangle's destination vertex.
	public static REAL triapex; // The triangle's apex vertex.
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	public static REAL area; // The area of the triangle.
	//#endif // not ANSI_DECLARATORS

	{
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  public static REAL dxoa;
	  public static REAL dxda;
	  public static REAL dxod;
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  public static REAL dyoa;
	  public static REAL dyda;
	  public static REAL dyod;
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  public static REAL oalen;
	  public static REAL dalen;
	  public static REAL odlen;
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  public static REAL maxlen;

//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  dxoa = triorg[0] - triapex[0];
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  dyoa = triorg[1] - triapex[1];
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  dxda = tridest[0] - triapex[0];
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  dyda = tridest[1] - triapex[1];
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  dxod = triorg[0] - tridest[0];
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  dyod = triorg[1] - tridest[1];
	  // Find the squares of the lengths of the triangle's three edges. 
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  oalen = dxoa * dxoa + dyoa * dyoa;
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  dalen = dxda * dxda + dyda * dyda;
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  odlen = dxod * dxod + dyod * dyod;
	  // Find the square of the length of the longest edge. 
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  maxlen = (dalen > oalen) ? dalen : oalen;
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  maxlen = (odlen > maxlen) ? odlen : maxlen;

//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	  if (maxlen > 0.05 * (triorg[0] * triorg[0] + triorg[1] * triorg[1]) + 0.02)
	  {
		public static return 1;
	  }
	  else
	  {
		return 0;
	  }
	}

	//#endif // not EXTERNAL_TEST

	//*                                                                         *
	//*                                                                         *
	//******** User-defined triangle evaluation routine ends here        ********

	//******** Memory allocation and program exit wrappers begin here    ********
	//*                                                                         *
	//*                                                                         *

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void triexit(int status)
	//#else
	void triexit(status)
	int status;
	//#endif // not ANSI_DECLARATORS

	{
	  exit(status);
	}

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	int *trimalloc(int size)
	//#else
	int *trimalloc(size)
	int size;
	//#endif // not ANSI_DECLARATORS

	{
	  int memptr;

//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in Java:
	  memptr = (int) malloc((int) size);
	  if (memptr == (int) null)
	  {
		System.out.print("Error:  Out of memory.\n");
		triexit(1);
	  }
	  return(memptr);
	}

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void trifree(int memptr)
	//#else
	void trifree(memptr)
	int memptr;
	//#endif // not ANSI_DECLARATORS

	{
//C++ TO JAVA CONVERTER TODO TASK: The memory management function 'free' has no equivalent in Java:
	  free(memptr);
	}

	//*                                                                         *
	//*                                                                         *
	//******** Memory allocation and program exit wrappers end here      ********

	//******** User interaction routines begin here                      ********
	//*                                                                         *
	//*                                                                         *

	//***************************************************************************
	//                                                                           
	//  syntax()   Print list of command line switches.                          
	//                                                                           
	//***************************************************************************


	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! TRILIBRARY
	void syntax()
	{
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if CDT_ONLY
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if REDUCED
	  System.out.print("triangle [-pAcjevngBPNEIOXzo_lQVh] input_file\n");
	//#else
	  System.out.print("triangle [-pAcjevngBPNEIOXzo_iFlCQVh] input_file\n");
	//#endif // not REDUCED
	//#else
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if REDUCED
	  System.out.print("triangle [-prq__a__uAcDjevngBPNEIOXzo_YS__lQVh] input_file\n");
	//#else
	  System.out.print("triangle [-prq__a__uAcDjevngBPNEIOXzo_YS__iFlsCQVh] input_file\n");
	//#endif // not REDUCED
	//#endif // not CDT_ONLY

	  System.out.print("    -p  Triangulates a Planar Straight Line Graph (.poly file).\n");
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! CDT_ONLY
	  System.out.print("    -r  Refines a previously generated mesh.\n");
	  System.out.print("    -q  Quality mesh generation.  A minimum angle may be specified.\n");
	  System.out.print("    -a  Applies a maximum triangle area constraint.\n");
	  System.out.print("    -u  Applies a user-defined triangle constraint.\n");
	//#endif // not CDT_ONLY
	  System.out.print("    -A  Applies attributes to identify triangles in certain regions.\n");
	  System.out.print("    -c  Encloses the convex hull with segments.\n");
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! CDT_ONLY
	  System.out.print("    -D  Conforming Delaunay:  all triangles are truly Delaunay.\n");
	//#endif // not CDT_ONLY
	//
	//  printf("    -w  Weighted Delaunay triangulation.\n");
	//  printf("    -W  Regular triangulation (lower hull of a height field).\n");
	//
	  System.out.print("    -j  Jettison unused vertices from output .node file.\n");
	  System.out.print("    -e  Generates an edge list.\n");
	  System.out.print("    -v  Generates a Voronoi diagram.\n");
	  System.out.print("    -n  Generates a list of triangle neighbors.\n");
	  System.out.print("    -g  Generates an .off file for Geomview.\n");
	  System.out.print("    -B  Suppresses output of boundary information.\n");
	  System.out.print("    -P  Suppresses output of .poly file.\n");
	  System.out.print("    -N  Suppresses output of .node file.\n");
	  System.out.print("    -E  Suppresses output of .ele file.\n");
	  System.out.print("    -I  Suppresses mesh iteration numbers.\n");
	  System.out.print("    -O  Ignores holes in .poly file.\n");
	  System.out.print("    -X  Suppresses use of exact arithmetic.\n");
	  System.out.print("    -z  Numbers all items starting from zero (rather than one).\n");
	  System.out.print("    -o2 Generates second-order subparametric elements.\n");
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! CDT_ONLY
	  System.out.print("    -Y  Suppresses boundary segment splitting.\n");
	  System.out.print("    -S  Specifies maximum number of added Steiner points.\n");
	//#endif // not CDT_ONLY
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! REDUCED
	  System.out.print("    -i  Uses incremental method, rather than divide-and-conquer.\n");
	  System.out.print("    -F  Uses Fortune's sweepline algorithm, rather than d-and-c.\n");
	//#endif // not REDUCED
	  System.out.print("    -l  Uses vertical cuts only, rather than alternating cuts.\n");
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! REDUCED
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! CDT_ONLY
	  System.out.print("    -s  Force segments into mesh by splitting (instead of using CDT).\n");
	//#endif // not CDT_ONLY
	  System.out.print("    -C  Check consistency of final mesh.\n");
	//#endif // not REDUCED
	  System.out.print("    -Q  Quiet:  No terminal output except errors.\n");
	  System.out.print("    -V  Verbose:  Detailed information on what I'm doing.\n");
	  System.out.print("    -h  Help:  Detailed instructions for Triangle.\n");
	  triexit(0);
	}

	//#endif // not TRILIBRARY

	//***************************************************************************
	//                                                                           
	//  info()   Print out complete instructions.                                
	//                                                                           
	//***************************************************************************


	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! TRILIBRARY
	void info()
	{
	  System.out.print("Triangle\n");
	  System.out.print("A Two-Dimensional Quality Mesh Generator and Delaunay Triangulator.\n");
	  System.out.print("Version 1.6\n\n");
	  System.out.print("Copyright 1993, 1995, 1997, 1998, 2002, 2005 Jonathan Richard Shewchuk\n");
	  System.out.print("2360 Woolsey #H / Berkeley, California 94705-1927\n");
	  System.out.print("Bugs/comments to jrs@cs.berkeley.edu\n");
	  System.out.print("Created as part of the Quake project (tools for earthquake simulation).\n");
	  System.out.print("Supported in part by NSF Grant CMS-9318163 and an NSERC 1967 Scholarship.\n");
	  System.out.print("There is no warranty whatsoever.  Use at your own risk.\n");
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if SINGLE
	  System.out.print("This executable is compiled for single precision arithmetic.\n\n\n");
	//#else
	  System.out.print("This executable is compiled for double precision arithmetic.\n\n\n");
	//#endif // not SINGLE
	  System.out.print("Triangle generates exact Delaunay triangulations, constrained Delaunay\n");
	  System.out.print("triangulations, conforming Delaunay triangulations, Voronoi diagrams, and\n");
	  System.out.print("high-quality triangular meshes.  The latter can be generated with no small\n");
	  System.out.print("or large angles, and are thus suitable for finite element analysis.  If no\n");
	  System.out.print("command line switch is specified, your .node input file is read, and the\n");
	  System.out.print("Delaunay triangulation is returned in .node and .ele output files.  The\n");
	  System.out.print("command syntax is:\n\n");
	  System.out.print("triangle [-prq__a__uAcDjevngBPNEIOXzo_YS__iFlsCQVh] input_file\n\n");
	  System.out.print("Underscores indicate that numbers may optionally follow certain switches.\n");
	  System.out.print("Do not leave any space between a switch and its numeric parameter.\n");
	  System.out.print("input_file must be a file with extension .node, or extension .poly if the\n");
	  System.out.print("-p switch is used.  If -r is used, you must supply .node and .ele files,\n");
	  System.out.print("and possibly a .poly file and an .area file as well.  The formats of these\n");
	  System.out.print("files are described below.\n\n");
	  System.out.print("Command Line Switches:\n\n");
	  System.out.print("    -p  Reads a Planar Straight Line Graph (.poly file), which can specify\n");
	  System.out.print("        vertices, segments, holes, regional attributes, and regional area\n");
	  System.out.print("        constraints.  Generates a constrained Delaunay triangulation (CDT)\n");
	  System.out.print("        fitting the input; or, if -s, -q, -a, or -u is used, a conforming\n");
	  System.out.print("        constrained Delaunay triangulation (CCDT).  If you want a truly\n");
	  System.out.print("        Delaunay (not just constrained Delaunay) triangulation, use -D as\n");
	  System.out.print("        well.  When -p is not used, Triangle reads a .node file by default.\n");
	  System.out.print("    -r  Refines a previously generated mesh.  The mesh is read from a .node\n");
	  System.out.print("        file and an .ele file.  If -p is also used, a .poly file is read\n");
	  System.out.print("        and used to constrain segments in the mesh.  If -a is also used\n");
	  System.out.print("        (with no number following), an .area file is read and used to\n");
	  System.out.print("        impose area constraints on the mesh.  Further details on refinement\n");
	  System.out.print("        appear below.\n");
	  System.out.print("    -q  Quality mesh generation by Delaunay refinement (a hybrid of Paul\n");
	  System.out.print("        Chew's and Jim Ruppert's algorithms).  Adds vertices to the mesh to\n");
	  System.out.print("        ensure that all angles are between 20 and 140 degrees.  An\n");
	  System.out.print("        alternative bound on the minimum angle, replacing 20 degrees, may\n");
	  System.out.print("        be specified after the `q'.  The specified angle may include a\n");
	  System.out.print("        decimal point, but not exponential notation.  Note that a bound of\n");
	  System.out.print("        theta degrees on the smallest angle also implies a bound of\n");
	  System.out.print("        (180 - 2 theta) on the largest angle.  If the minimum angle is 28.6\n");
	  System.out.print("        degrees or smaller, Triangle is mathematically guaranteed to\n");
	  System.out.print("        terminate (assuming infinite precision arithmetic--Triangle may\n");
	  System.out.print("        fail to terminate if you run out of precision).  In practice,\n");
	  System.out.print("        Triangle often succeeds for minimum angles up to 34 degrees.  For\n");
	  System.out.print("        some meshes, however, you might need to reduce the minimum angle to\n");
	  System.out.print("        avoid problems associated with insufficient floating-point\n");
	  System.out.print("        precision.\n");
	  System.out.print("    -a  Imposes a maximum triangle area.  If a number follows the `a', no\n");
	  System.out.print("        triangle is generated whose area is larger than that number.  If no\n");
	  System.out.print("        number is specified, an .area file (if -r is used) or .poly file\n");
	  System.out.print("        (if -r is not used) specifies a set of maximum area constraints.\n");
	  System.out.print("        An .area file contains a separate area constraint for each\n");
	  System.out.print("        triangle, and is useful for refining a finite element mesh based on\n");
	  System.out.print("        a posteriori error estimates.  A .poly file can optionally contain\n");
	  System.out.print("        an area constraint for each segment-bounded region, thereby\n");
	  System.out.print("        controlling triangle densities in a first triangulation of a PSLG.\n");
	  System.out.print("        You can impose both a fixed area constraint and a varying area\n");
	  System.out.print("        constraint by invoking the -a switch twice, once with and once\n");
	  System.out.print("        without a number following.  Each area specified may include a\n");
	  System.out.print("        decimal point.\n");
	  System.out.print("    -u  Imposes a user-defined constraint on triangle size.  There are two\n");
	  System.out.print("        ways to use this feature.  One is to edit the triunsuitable()\n");
	  System.out.print("        procedure in triangle.c to encode any constraint you like, then\n");
	  System.out.print("        recompile Triangle.  The other is to compile triangle.c with the\n");
	  System.out.print("        EXTERNAL_TEST symbol set (compiler switch -DEXTERNAL_TEST), then\n");
	  System.out.print("        link Triangle with a separate object file that implements\n");
	  System.out.print("        triunsuitable().  In either case, the -u switch causes the user-\n");
	  System.out.print("        defined test to be applied to every triangle.\n");
	  System.out.print("    -A  Assigns an additional floating-point attribute to each triangle\n");
	  System.out.print("        that identifies what segment-bounded region each triangle belongs\n");
	  System.out.print("        to.  Attributes are assigned to regions by the .poly file.  If a\n");
	  System.out.print("        region is not explicitly marked by the .poly file, triangles in\n");
	  System.out.print("        that region are assigned an attribute of zero.  The -A switch has\n");
	  System.out.print("        an effect only when the -p switch is used and the -r switch is not.\n");
	  System.out.print("    -c  Creates segments on the convex hull of the triangulation.  If you\n");
	  System.out.print("        are triangulating a vertex set, this switch causes a .poly file to\n");
	  System.out.print("        be written, containing all edges of the convex hull.  If you are\n");
	  System.out.print("        triangulating a PSLG, this switch specifies that the whole convex\n");
	  System.out.print("        hull of the PSLG should be triangulated, regardless of what\n");
	  System.out.print("        segments the PSLG has.  If you do not use this switch when\n");
	  System.out.print("        triangulating a PSLG, Triangle assumes that you have identified the\n");
	  System.out.print("        region to be triangulated by surrounding it with segments of the\n");
	  System.out.print("        input PSLG.  Beware:  if you are not careful, this switch can cause\n");
	  System.out.print("        the introduction of an extremely thin angle between a PSLG segment\n");
	  System.out.print("        and a convex hull segment, which can cause overrefinement (and\n");
	  System.out.print("        possibly failure if Triangle runs out of precision).  If you are\n");
	  System.out.print("        refining a mesh, the -c switch works differently:  it causes a\n");
	  System.out.print("        .poly file to be written containing the boundary edges of the mesh\n");
	  System.out.print("        (useful if no .poly file was read).\n");
	  System.out.print("    -D  Conforming Delaunay triangulation:  use this switch if you want to\n");
	  System.out.print("        ensure that all the triangles in the mesh are Delaunay, and not\n");
	  System.out.print("        merely constrained Delaunay; or if you want to ensure that all the\n");
	  System.out.print("        Voronoi vertices lie within the triangulation.  (Some finite volume\n");
	  System.out.print("        methods have this requirement.)  This switch invokes Ruppert's\n");
	  System.out.print("        original algorithm, which splits every subsegment whose diametral\n");
	  System.out.print("        circle is encroached.  It usually increases the number of vertices\n");
	  System.out.print("        and triangles.\n");
	  System.out.print("    -j  Jettisons vertices that are not part of the final triangulation\n");
	  System.out.print("        from the output .node file.  By default, Triangle copies all\n");
	  System.out.print("        vertices in the input .node file to the output .node file, in the\n");
	  System.out.print("        same order, so their indices do not change.  The -j switch prevents\n");
	  System.out.print("        duplicated input vertices, or vertices `eaten' by holes, from\n");
	  System.out.print("        appearing in the output .node file.  Thus, if two input vertices\n");
	  System.out.print("        have exactly the same coordinates, only the first appears in the\n");
	  System.out.print("        output.  If any vertices are jettisoned, the vertex numbering in\n");
	  System.out.print("        the output .node file differs from that of the input .node file.\n");
	  System.out.print("    -e  Outputs (to an .edge file) a list of edges of the triangulation.\n");
	  System.out.print("    -v  Outputs the Voronoi diagram associated with the triangulation.\n");
	  System.out.print("        Does not attempt to detect degeneracies, so some Voronoi vertices\n");
	  System.out.print("        may be duplicated.  See the discussion of Voronoi diagrams below.\n");
	  System.out.print("    -n  Outputs (to a .neigh file) a list of triangles neighboring each\n");
	  System.out.print("        triangle.\n");
	  System.out.print("    -g  Outputs the mesh to an Object File Format (.off) file, suitable for\n");
	  System.out.print("        viewing with the Geometry Center's Geomview package.\n");
	  System.out.print("    -B  No boundary markers in the output .node, .poly, and .edge output\n");
	  System.out.print("        files.  See the detailed discussion of boundary markers below.\n");
	  System.out.print("    -P  No output .poly file.  Saves disk space, but you lose the ability\n");
	  System.out.print("        to maintain constraining segments on later refinements of the mesh.\n");
	  System.out.print("    -N  No output .node file.\n");
	  System.out.print("    -E  No output .ele file.\n");
	  System.out.print("    -I  No iteration numbers.  Suppresses the output of .node and .poly\n");
	  System.out.print("        files, so your input files won't be overwritten.  (If your input is\n");
	  System.out.print("        a .poly file only, a .node file is written.)  Cannot be used with\n");
	  System.out.print("        the -r switch, because that would overwrite your input .ele file.\n");
	  System.out.print("        Shouldn't be used with the -q, -a, -u, or -s switch if you are\n");
	  System.out.print("        using a .node file for input, because no .node file is written, so\n");
	  System.out.print("        there is no record of any added Steiner points.\n");
	  System.out.print("    -O  No holes.  Ignores the holes in the .poly file.\n");
	  System.out.print("    -X  No exact arithmetic.  Normally, Triangle uses exact floating-point\n");
	  System.out.print("        arithmetic for certain tests if it thinks the inexact tests are not\n");
	  System.out.print("        accurate enough.  Exact arithmetic ensures the robustness of the\n");
	  System.out.print("        triangulation algorithms, despite floating-point roundoff error.\n");
	  System.out.print("        Disabling exact arithmetic with the -X switch causes a small\n");
	  System.out.print("        improvement in speed and creates the possibility that Triangle will\n");
	  System.out.print("        fail to produce a valid mesh.  Not recommended.\n");
	  System.out.print("    -z  Numbers all items starting from zero (rather than one).  Note that\n");
	  System.out.print("        this switch is normally overridden by the value used to number the\n");
	  System.out.print("        first vertex of the input .node or .poly file.  However, this\n");
	  System.out.print("        switch is useful when calling Triangle from another program.\n");
	  System.out.print("    -o2 Generates second-order subparametric elements with six nodes each.\n");
	  System.out.print("    -Y  No new vertices on the boundary.  This switch is useful when the\n");
	  System.out.print("        mesh boundary must be preserved so that it conforms to some\n");
	  System.out.print("        adjacent mesh.  Be forewarned that you will probably sacrifice much\n");
	  System.out.print("        of the quality of the mesh; Triangle will try, but the resulting\n");
	  System.out.print("        mesh may contain poorly shaped triangles.  Works well if all the\n");
	  System.out.print("        boundary vertices are closely spaced.  Specify this switch twice\n");
	  System.out.print("        (`-YY') to prevent all segment splitting, including internal\n");
	  System.out.print("        boundaries.\n");
	  System.out.print("    -S  Specifies the maximum number of Steiner points (vertices that are\n");
	  System.out.print("        not in the input, but are added to meet the constraints on minimum\n");
	  System.out.print("        angle and maximum area).  The default is to allow an unlimited\n");
	  System.out.print("        number.  If you specify this switch with no number after it,\n");
	  System.out.print("        the limit is set to zero.  Triangle always adds vertices at segment\n");
	  System.out.print("        intersections, even if it needs to use more vertices than the limit\n");
	  System.out.print("        you set.  When Triangle inserts segments by splitting (-s), it\n");
	  System.out.print("        always adds enough vertices to ensure that all the segments of the\n");
	  System.out.print("        PLSG are recovered, ignoring the limit if necessary.\n");
	  System.out.print("    -i  Uses an incremental rather than a divide-and-conquer algorithm to\n");
	  System.out.print("        construct a Delaunay triangulation.  Try it if the divide-and-\n");
	  System.out.print("        conquer algorithm fails.\n");
	  System.out.print("    -F  Uses Steven Fortune's sweepline algorithm to construct a Delaunay\n");
	  System.out.print("        triangulation.  Warning:  does not use exact arithmetic for all\n");
	  System.out.print("        calculations.  An exact result is not guaranteed.\n");
	  System.out.print("    -l  Uses only vertical cuts in the divide-and-conquer algorithm.  By\n");
	  System.out.print("        default, Triangle alternates between vertical and horizontal cuts,\n");
	  System.out.print("        which usually improve the speed except with vertex sets that are\n");
	  System.out.print("        small or short and wide.  This switch is primarily of theoretical\n");
	  System.out.print("        interest.\n");
	  System.out.print("    -s  Specifies that segments should be forced into the triangulation by\n");
	  System.out.print("        recursively splitting them at their midpoints, rather than by\n");
	  System.out.print("        generating a constrained Delaunay triangulation.  Segment splitting\n");
	  System.out.print("        is true to Ruppert's original algorithm, but can create needlessly\n");
	  System.out.print("        small triangles.  This switch is primarily of theoretical interest.\n");
	  System.out.print("    -C  Check the consistency of the final mesh.  Uses exact arithmetic for\n");
	  System.out.print("        checking, even if the -X switch is used.  Useful if you suspect\n");
	  System.out.print("        Triangle is buggy.\n");
	  System.out.print("    -Q  Quiet:  Suppresses all explanation of what Triangle is doing,\n");
	  System.out.print("        unless an error occurs.\n");
	  System.out.print("    -V  Verbose:  Gives detailed information about what Triangle is doing.\n");
	  System.out.print("        Add more `V's for increasing amount of detail.  `-V' is most\n");
	  System.out.print("        useful; itgives information on algorithmic progress and much more\n");
	  System.out.print("        detailed statistics.  `-VV' gives vertex-by-vertex details, and\n");
	  System.out.print("        prints so much that Triangle runs much more slowly.  `-VVVV' gives\n");
	  System.out.print("        information only a debugger could love.\n");
	  System.out.print("    -h  Help:  Displays these instructions.\n");
	  System.out.print("\n");
	  System.out.print("Definitions:\n");
	  System.out.print("\n");
	  System.out.print("  A Delaunay triangulation of a vertex set is a triangulation whose\n");
	  System.out.print("  vertices are the vertex set, that covers the convex hull of the vertex\n");
	  System.out.print("  set.  A Delaunay triangulation has the property that no vertex lies\n");
	  System.out.print("  inside the circumscribing circle (circle that passes through all three\n");
	  System.out.print("  vertices) of any triangle in the triangulation.\n\n");
	  System.out.print("  A Voronoi diagram of a vertex set is a subdivision of the plane into\n");
	  System.out.print("  polygonal cells (some of which may be unbounded, meaning infinitely\n");
	  System.out.print("  large), where each cell is the set of points in the plane that are closer\n");
	  System.out.print("  to some input vertex than to any other input vertex.  The Voronoi diagram\n");
	  System.out.print("  is a geometric dual of the Delaunay triangulation.\n\n");
	  System.out.print("  A Planar Straight Line Graph (PSLG) is a set of vertices and segments.\n");
	  System.out.print("  Segments are simply edges, whose endpoints are all vertices in the PSLG.\n");
	  System.out.print("  Segments may intersect each other only at their endpoints.  The file\n");
	  System.out.print("  format for PSLGs (.poly files) is described below.\n\n");
	  System.out.print("  A constrained Delaunay triangulation (CDT) of a PSLG is similar to a\n");
	  System.out.print("  Delaunay triangulation, but each PSLG segment is present as a single edge\n");
	  System.out.print("  of the CDT.  (A constrained Delaunay triangulation is not truly a\n");
	  System.out.print("  Delaunay triangulation, because some of its triangles might not be\n");
	  System.out.print("  Delaunay.)  By definition, a CDT does not have any vertices other than\n");
	  System.out.print("  those specified in the input PSLG.  Depending on context, a CDT might\n");
	  System.out.print("  cover the convex hull of the PSLG, or it might cover only a segment-\n");
	  System.out.print("  bounded region (e.g. a polygon).\n\n");
	  System.out.print("  A conforming Delaunay triangulation of a PSLG is a triangulation in which\n");
	  System.out.print("  each triangle is truly Delaunay, and each PSLG segment is represented by\n");
	  System.out.print("  a linear contiguous sequence of edges of the triangulation.  New vertices\n");
	  System.out.print("  (not part of the PSLG) may appear, and each input segment may have been\n");
	  System.out.print("  subdivided into shorter edges (subsegments) by these additional vertices.\n");
	  System.out.print("  The new vertices are frequently necessary to maintain the Delaunay\n");
	  System.out.print("  property while ensuring that every segment is represented.\n\n");
	  System.out.print("  A conforming constrained Delaunay triangulation (CCDT) of a PSLG is a\n");
	  System.out.print("  triangulation of a PSLG whose triangles are constrained Delaunay.  New\n");
	  System.out.print("  vertices may appear, and input segments may be subdivided into\n");
	  System.out.print("  subsegments, but not to guarantee that segments are respected; rather, to\n");
	  System.out.print("  improve the quality of the triangles.  The high-quality meshes produced\n");
	  System.out.print("  by the -q switch are usually CCDTs, but can be made conforming Delaunay\n");
	  System.out.print("  with the -D switch.\n\n");
	  System.out.print("File Formats:\n\n");
	  System.out.print("  All files may contain comments prefixed by the character '#'.  Vertices,\n");
	  System.out.print("  triangles, edges, holes, and maximum area constraints must be numbered\n");
	  System.out.print("  consecutively, starting from either 1 or 0.  Whichever you choose, all\n");
	  System.out.print("  input files must be consistent; if the vertices are numbered from 1, so\n");
	  System.out.print("  must be all other objects.  Triangle automatically detects your choice\n");
	  System.out.print("  while reading the .node (or .poly) file.  (When calling Triangle from\n");
	  System.out.print("  another program, use the -z switch if you wish to number objects from\n");
	  System.out.print("  zero.)  Examples of these file formats are given below.\n\n");
	  System.out.print("  .node files:\n");
	  System.out.print("    First line:  <# of vertices> <dimension (must be 2)> <# of attributes>\n");
	  System.out.print("                                           <# of boundary markers (0 or 1)>\n");
	  System.out.print("    Remaining lines:  <vertex #> <x> <y> [attributes] [boundary marker]\n");
	  System.out.print("\n");
	  System.out.print("    The attributes, which are typically floating-point values of physical\n");
	  System.out.print("    quantities (such as mass or conductivity) associated with the nodes of\n");
	  System.out.print("    a finite element mesh, are copied unchanged to the output mesh.  If -q,\n");
	  System.out.print("    -a, -u, -D, or -s is selected, each new Steiner point added to the mesh\n");
	  System.out.print("    has attributes assigned to it by linear interpolation.\n\n");
	  System.out.print("    If the fourth entry of the first line is `1', the last column of the\n");
	  System.out.print("    remainder of the file is assumed to contain boundary markers.  Boundary\n");
	  System.out.print("    markers are used to identify boundary vertices and vertices resting on\n");
	  System.out.print("    PSLG segments; a complete description appears in a section below.  The\n");
	  System.out.print("    .node file produced by Triangle contains boundary markers in the last\n");
	  System.out.print("    column unless they are suppressed by the -B switch.\n\n");
	  System.out.print("  .ele files:\n");
	  System.out.print("    First line:  <# of triangles> <nodes per triangle> <# of attributes>\n");
	  System.out.print("    Remaining lines:  <triangle #> <node> <node> <node> ... [attributes]\n");
	  System.out.print("\n");
	  System.out.print("    Nodes are indices into the corresponding .node file.  The first three\n");
	  System.out.print("    nodes are the corner vertices, and are listed in counterclockwise order\n");
	  System.out.print("    around each triangle.  (The remaining nodes, if any, depend on the type\n");
	  System.out.print("    of finite element used.)\n\n");
	  System.out.print("    The attributes are just like those of .node files.  Because there is no\n");
	  System.out.print("    simple mapping from input to output triangles, Triangle attempts to\n");
	  System.out.print("    interpolate attributes, and may cause a lot of diffusion of attributes\n");
	  System.out.print("    among nearby triangles as the triangulation is refined.  Attributes do\n");
	  System.out.print("    not diffuse across segments, so attributes used to identify\n");
	  System.out.print("    segment-bounded regions remain intact.\n\n");
	  System.out.print("    In .ele files produced by Triangle, each triangular element has three\n");
	  System.out.print("    nodes (vertices) unless the -o2 switch is used, in which case\n");
	  System.out.print("    subparametric quadratic elements with six nodes each are generated.\n");
	  System.out.print("    The first three nodes are the corners in counterclockwise order, and\n");
	  System.out.print("    the fourth, fifth, and sixth nodes lie on the midpoints of the edges\n");
	  System.out.print("    opposite the first, second, and third vertices, respectively.\n");
	  System.out.print("\n");
	  System.out.print("  .poly files:\n");
	  System.out.print("    First line:  <# of vertices> <dimension (must be 2)> <# of attributes>\n");
	  System.out.print("                                           <# of boundary markers (0 or 1)>\n");
	  System.out.print("    Following lines:  <vertex #> <x> <y> [attributes] [boundary marker]\n");
	  System.out.print("    One line:  <# of segments> <# of boundary markers (0 or 1)>\n");
	  System.out.print("    Following lines:  <segment #> <endpoint> <endpoint> [boundary marker]\n");
	  System.out.print("    One line:  <# of holes>\n");
	  System.out.print("    Following lines:  <hole #> <x> <y>\n");
	  System.out.print("    Optional line:  <# of regional attributes and/or area constraints>\n");
	  System.out.print("    Optional following lines:  <region #> <x> <y> <attribute> <max area>\n");
	  System.out.print("\n");
	  System.out.print("    A .poly file represents a PSLG, as well as some additional information.\n");
	  System.out.print("    The first section lists all the vertices, and is identical to the\n");
	  System.out.print("    format of .node files.  <# of vertices> may be set to zero to indicate\n");
	  System.out.print("    that the vertices are listed in a separate .node file; .poly files\n");
	  System.out.print("    produced by Triangle always have this format.  A vertex set represented\n");
	  System.out.print("    this way has the advantage that it may easily be triangulated with or\n");
	  System.out.print("    without segments (depending on whether the -p switch is invoked).\n");
	  System.out.print("\n");
	  System.out.print("    The second section lists the segments.  Segments are edges whose\n");
	  System.out.print("    presence in the triangulation is enforced.  (Depending on the choice of\n");
	  System.out.print("    switches, segment might be subdivided into smaller edges).  Each\n");
	  System.out.print("    segment is specified by listing the indices of its two endpoints.  This\n");
	  System.out.print("    means that you must include its endpoints in the vertex list.  Each\n");
	  System.out.print("    segment, like each point, may have a boundary marker.\n\n");
	  System.out.print("    If -q, -a, -u, and -s are not selected, Triangle produces a constrained\n");
	  System.out.print("    Delaunay triangulation (CDT), in which each segment appears as a single\n");
	  System.out.print("    edge in the triangulation.  If -q, -a, -u, or -s is selected, Triangle\n");
	  System.out.print("    produces a conforming constrained Delaunay triangulation (CCDT), in\n");
	  System.out.print("    which segments may be subdivided into smaller edges.  If -D is\n");
	  System.out.print("    selected, Triangle produces a conforming Delaunay triangulation, so\n");
	  System.out.print("    that every triangle is Delaunay, and not just constrained Delaunay.\n");
	  System.out.print("\n");
	  System.out.print("    The third section lists holes (and concavities, if -c is selected) in\n");
	  System.out.print("    the triangulation.  Holes are specified by identifying a point inside\n");
	  System.out.print("    each hole.  After the triangulation is formed, Triangle creates holes\n");
	  System.out.print("    by eating triangles, spreading out from each hole point until its\n");
	  System.out.print("    progress is blocked by segments in the PSLG.  You must be careful to\n");
	  System.out.print("    enclose each hole in segments, or your whole triangulation might be\n");
	  System.out.print("    eaten away.  If the two triangles abutting a segment are eaten, the\n");
	  System.out.print("    segment itself is also eaten.  Do not place a hole directly on a\n");
	  System.out.print("    segment; if you do, Triangle chooses one side of the segment\n");
	  System.out.print("    arbitrarily.\n\n");
	  System.out.print("    The optional fourth section lists regional attributes (to be assigned\n");
	  System.out.print("    to all triangles in a region) and regional constraints on the maximum\n");
	  System.out.print("    triangle area.  Triangle reads this section only if the -A switch is\n");
	  System.out.print("    used or the -a switch is used without a number following it, and the -r\n");
	  System.out.print("    switch is not used.  Regional attributes and area constraints are\n");
	  System.out.print("    propagated in the same manner as holes:  you specify a point for each\n");
	  System.out.print("    attribute and/or constraint, and the attribute and/or constraint\n");
	  System.out.print("    affects the whole region (bounded by segments) containing the point.\n");
	  System.out.print("    If two values are written on a line after the x and y coordinate, the\n");
	  System.out.print("    first such value is assumed to be a regional attribute (but is only\n");
	  System.out.print("    applied if the -A switch is selected), and the second value is assumed\n");
	  System.out.print("    to be a regional area constraint (but is only applied if the -a switch\n");
	  System.out.print("    is selected).  You may specify just one value after the coordinates,\n");
	  System.out.print("    which can serve as both an attribute and an area constraint, depending\n");
	  System.out.print("    on the choice of switches.  If you are using the -A and -a switches\n");
	  System.out.print("    simultaneously and wish to assign an attribute to some region without\n");
	  System.out.print("    imposing an area constraint, use a negative maximum area.\n\n");
	  System.out.print("    When a triangulation is created from a .poly file, you must either\n");
	  System.out.print("    enclose the entire region to be triangulated in PSLG segments, or\n");
	  System.out.print("    use the -c switch, which automatically creates extra segments that\n");
	  System.out.print("    enclose the convex hull of the PSLG.  If you do not use the -c switch,\n");
	  System.out.print("    Triangle eats all triangles that are not enclosed by segments; if you\n");
	  System.out.print("    are not careful, your whole triangulation may be eaten away.  If you do\n");
	  System.out.print("    use the -c switch, you can still produce concavities by the appropriate\n");
	  System.out.print("    placement of holes just inside the boundary of the convex hull.\n");
	  System.out.print("\n");
	  System.out.print("    An ideal PSLG has no intersecting segments, nor any vertices that lie\n");
	  System.out.print("    upon segments (except, of course, the endpoints of each segment).  You\n");
	  System.out.print("    aren't required to make your .poly files ideal, but you should be aware\n");
	  System.out.print("    of what can go wrong.  Segment intersections are relatively safe--\n");
	  System.out.print("    Triangle calculates the intersection points for you and adds them to\n");
	  System.out.print("    the triangulation--as long as your machine's floating-point precision\n");
	  System.out.print("    doesn't become a problem.  You are tempting the fates if you have three\n");
	  System.out.print("    segments that cross at the same location, and expect Triangle to figure\n");
	  System.out.print("    out where the intersection point is.  Thanks to floating-point roundoff\n");
	  System.out.print("    error, Triangle will probably decide that the three segments intersect\n");
	  System.out.print("    at three different points, and you will find a minuscule triangle in\n");
	  System.out.print("    your output--unless Triangle tries to refine the tiny triangle, uses\n");
	  System.out.print("    up the last bit of machine precision, and fails to terminate at all.\n");
	  System.out.print("    You're better off putting the intersection point in the input files,\n");
	  System.out.print("    and manually breaking up each segment into two.  Similarly, if you\n");
	  System.out.print("    place a vertex at the middle of a segment, and hope that Triangle will\n");
	  System.out.print("    break up the segment at that vertex, you might get lucky.  On the other\n");
	  System.out.print("    hand, Triangle might decide that the vertex doesn't lie precisely on\n");
	  System.out.print("    the segment, and you'll have a needle-sharp triangle in your output--or\n");
	  System.out.print("    a lot of tiny triangles if you're generating a quality mesh.\n");
	  System.out.print("\n");
	  System.out.print("    When Triangle reads a .poly file, it also writes a .poly file, which\n");
	  System.out.print("    includes all the subsegments--the edges that are parts of input\n");
	  System.out.print("    segments.  If the -c switch is used, the output .poly file also\n");
	  System.out.print("    includes all of the edges on the convex hull.  Hence, the output .poly\n");
	  System.out.print("    file is useful for finding edges associated with input segments and for\n");
	  System.out.print("    setting boundary conditions in finite element simulations.  Moreover,\n");
	  System.out.print("    you will need the output .poly file if you plan to refine the output\n");
	  System.out.print("    mesh, and don't want segments to be missing in later triangulations.\n");
	  System.out.print("\n");
	  System.out.print("  .area files:\n");
	  System.out.print("    First line:  <# of triangles>\n");
	  System.out.print("    Following lines:  <triangle #> <maximum area>\n");
	  System.out.print("\n");
	  System.out.print("    An .area file associates with each triangle a maximum area that is used\n");
	  System.out.print("    for mesh refinement.  As with other file formats, every triangle must\n");
	  System.out.print("    be represented, and the triangles must be numbered consecutively.  A\n");
	  System.out.print("    triangle may be left unconstrained by assigning it a negative maximum\n");
	  System.out.print("    area.\n\n");
	  System.out.print("  .edge files:\n");
	  System.out.print("    First line:  <# of edges> <# of boundary markers (0 or 1)>\n");
	  System.out.print("    Following lines:  <edge #> <endpoint> <endpoint> [boundary marker]\n");
	  System.out.print("\n");
	  System.out.print("    Endpoints are indices into the corresponding .node file.  Triangle can\n");
	  System.out.print("    produce .edge files (use the -e switch), but cannot read them.  The\n");
	  System.out.print("    optional column of boundary markers is suppressed by the -B switch.\n");
	  System.out.print("\n");
	  System.out.print("    In Voronoi diagrams, one also finds a special kind of edge that is an\n");
	  System.out.print("    infinite ray with only one endpoint.  For these edges, a different\n");
	  System.out.print("    format is used:\n\n");
	  System.out.print("        <edge #> <endpoint> -1 <direction x> <direction y>\n\n");
	  System.out.print("    The `direction' is a floating-point vector that indicates the direction\n");
	  System.out.print("    of the infinite ray.\n\n");
	  System.out.print("  .neigh files:\n");
	  System.out.print("    First line:  <# of triangles> <# of neighbors per triangle (always 3)>\n");
	  System.out.print("    Following lines:  <triangle #> <neighbor> <neighbor> <neighbor>\n");
	  System.out.print("\n");
	  System.out.print("    Neighbors are indices into the corresponding .ele file.  An index of -1\n");
	  System.out.print("    indicates no neighbor (because the triangle is on an exterior\n");
	  System.out.print("    boundary).  The first neighbor of triangle i is opposite the first\n");
	  System.out.print("    corner of triangle i, and so on.\n\n");
	  System.out.print("    Triangle can produce .neigh files (use the -n switch), but cannot read\n");
	  System.out.print("    them.\n\n");
	  System.out.print("Boundary Markers:\n\n");
	  System.out.print("  Boundary markers are tags used mainly to identify which output vertices\n");
	  System.out.print("  and edges are associated with which PSLG segment, and to identify which\n");
	  System.out.print("  vertices and edges occur on a boundary of the triangulation.  A common\n");
	  System.out.print("  use is to determine where boundary conditions should be applied to a\n");
	  System.out.print("  finite element mesh.  You can prevent boundary markers from being written\n");
	  System.out.print("  into files produced by Triangle by using the -B switch.\n\n");
	  System.out.print("  The boundary marker associated with each segment in an output .poly file\n");
	  System.out.print("  and each edge in an output .edge file is chosen as follows:\n");
	  System.out.print("    - If an output edge is part or all of a PSLG segment with a nonzero\n");
	  System.out.print("      boundary marker, then the edge is assigned the same marker.\n");
	  System.out.print("    - Otherwise, if the edge lies on a boundary of the triangulation\n");
	  System.out.print("      (even the boundary of a hole), then the edge is assigned the marker\n");
	  System.out.print("      one (1).\n");
	  System.out.print("    - Otherwise, the edge is assigned the marker zero (0).\n");
	  System.out.print("  The boundary marker associated with each vertex in an output .node file\n");
	  System.out.print("  is chosen as follows:\n");
	  System.out.print("    - If a vertex is assigned a nonzero boundary marker in the input file,\n");
	  System.out.print("      then it is assigned the same marker in the output .node file.\n");
	  System.out.print("    - Otherwise, if the vertex lies on a PSLG segment (even if it is an\n");
	  System.out.print("      endpoint of the segment) with a nonzero boundary marker, then the\n");
	  System.out.print("      vertex is assigned the same marker.  If the vertex lies on several\n");
	  System.out.print("      such segments, one of the markers is chosen arbitrarily.\n");
	  System.out.print("    - Otherwise, if the vertex occurs on a boundary of the triangulation,\n");
	  System.out.print("      then the vertex is assigned the marker one (1).\n");
	  System.out.print("    - Otherwise, the vertex is assigned the marker zero (0).\n");
	  System.out.print("\n");
	  System.out.print("  If you want Triangle to determine for you which vertices and edges are on\n");
	  System.out.print("  the boundary, assign them the boundary marker zero (or use no markers at\n");
	  System.out.print("  all) in your input files.  In the output files, all boundary vertices,\n");
	  System.out.print("  edges, and segments will be assigned the value one.\n\n");
	  System.out.print("Triangulation Iteration Numbers:\n\n");
	  System.out.print("  Because Triangle can read and refine its own triangulations, input\n");
	  System.out.print("  and output files have iteration numbers.  For instance, Triangle might\n");
	  System.out.print("  read the files mesh.3.node, mesh.3.ele, and mesh.3.poly, refine the\n");
	  System.out.print("  triangulation, and output the files mesh.4.node, mesh.4.ele, and\n");
	  System.out.print("  mesh.4.poly.  Files with no iteration number are treated as if\n");
	  System.out.print("  their iteration number is zero; hence, Triangle might read the file\n");
	  System.out.print("  points.node, triangulate it, and produce the files points.1.node and\n");
	  System.out.print("  points.1.ele.\n\n");
	  System.out.print("  Iteration numbers allow you to create a sequence of successively finer\n");
	  System.out.print("  meshes suitable for multigrid methods.  They also allow you to produce a\n");
	  System.out.print("  sequence of meshes using error estimate-driven mesh refinement.\n");
	  System.out.print("\n");
	  System.out.print("  If you're not using refinement or quality meshing, and you don't like\n");
	  System.out.print("  iteration numbers, use the -I switch to disable them.  This switch also\n");
	  System.out.print("  disables output of .node and .poly files to prevent your input files from\n");
	  System.out.print("  being overwritten.  (If the input is a .poly file that contains its own\n");
	  System.out.print("  points, a .node file is written.  This can be quite convenient for\n");
	  System.out.print("  computing CDTs or quality meshes.)\n\n");
	  System.out.print("Examples of How to Use Triangle:\n\n");
	  System.out.print("  `triangle dots' reads vertices from dots.node, and writes their Delaunay\n");
	  System.out.print("  triangulation to dots.1.node and dots.1.ele.  (dots.1.node is identical\n");
	  System.out.print("  to dots.node.)  `triangle -I dots' writes the triangulation to dots.ele\n");
	  System.out.print("  instead.  (No additional .node file is needed, so none is written.)\n");
	  System.out.print("\n");
	  System.out.print("  `triangle -pe object.1' reads a PSLG from object.1.poly (and possibly\n");
	  System.out.print("  object.1.node, if the vertices are omitted from object.1.poly) and writes\n");
	  System.out.print("  its constrained Delaunay triangulation to object.2.node and object.2.ele.\n");
	  System.out.print("  The segments are copied to object.2.poly, and all edges are written to\n");
	  System.out.print("  object.2.edge.\n\n");
	  System.out.print("  `triangle -pq31.5a.1 object' reads a PSLG from object.poly (and possibly\n");
	  System.out.print("  object.node), generates a mesh whose angles are all between 31.5 and 117\n");
	  System.out.print("  degrees and whose triangles all have areas of 0.1 or less, and writes the\n");
	  System.out.print("  mesh to object.1.node and object.1.ele.  Each segment may be broken up\n");
	  System.out.print("  into multiple subsegments; these are written to object.1.poly.\n");
	  System.out.print("\n");
	  System.out.print("  Here is a sample file `box.poly' describing a square with a square hole:\n");
	  System.out.print("\n");
	  System.out.print("    # A box with eight vertices in 2D, no attributes, one boundary marker.\n");
	  System.out.print("    8 2 0 1\n");
	  System.out.print("     # Outer box has these vertices:\n");
	  System.out.print("     1   0 0   0\n");
	  System.out.print("     2   0 3   0\n");
	  System.out.print("     3   3 0   0\n");
	  System.out.print("     4   3 3   33     # A special marker for this vertex.\n");
	  System.out.print("     # Inner square has these vertices:\n");
	  System.out.print("     5   1 1   0\n");
	  System.out.print("     6   1 2   0\n");
	  System.out.print("     7   2 1   0\n");
	  System.out.print("     8   2 2   0\n");
	  System.out.print("    # Five segments with boundary markers.\n");
	  System.out.print("    5 1\n");
	  System.out.print("     1   1 2   5      # Left side of outer box.\n");
	  System.out.print("     # Square hole has these segments:\n");
	  System.out.print("     2   5 7   0\n");
	  System.out.print("     3   7 8   0\n");
	  System.out.print("     4   8 6   10\n");
	  System.out.print("     5   6 5   0\n");
	  System.out.print("    # One hole in the middle of the inner square.\n");
	  System.out.print("    1\n");
	  System.out.print("     1   1.5 1.5\n");
	  System.out.print("\n");
	  System.out.print("  Note that some segments are missing from the outer square, so you must\n");
	  System.out.print("  use the `-c' switch.  After `triangle -pqc box.poly', here is the output\n");
	  System.out.print("  file `box.1.node', with twelve vertices.  The last four vertices were\n");
	  System.out.print("  added to meet the angle constraint.  Vertices 1, 2, and 9 have markers\n");
	  System.out.print("  from segment 1.  Vertices 6 and 8 have markers from segment 4.  All the\n");
	  System.out.print("  other vertices but 4 have been marked to indicate that they lie on a\n");
	  System.out.print("  boundary.\n\n");
	  System.out.print("    12  2  0  1\n");
	  System.out.print("       1    0   0      5\n");
	  System.out.print("       2    0   3      5\n");
	  System.out.print("       3    3   0      1\n");
	  System.out.print("       4    3   3     33\n");
	  System.out.print("       5    1   1      1\n");
	  System.out.print("       6    1   2     10\n");
	  System.out.print("       7    2   1      1\n");
	  System.out.print("       8    2   2     10\n");
	  System.out.print("       9    0   1.5    5\n");
	  System.out.print("      10    1.5   0    1\n");
	  System.out.print("      11    3   1.5    1\n");
	  System.out.print("      12    1.5   3    1\n");
	  System.out.print("    # Generated by triangle -pqc box.poly\n");
	  System.out.print("\n");
	  System.out.print("  Here is the output file `box.1.ele', with twelve triangles.\n");
	  System.out.print("\n");
	  System.out.print("    12  3  0\n");
	  System.out.print("       1     5   6   9\n");
	  System.out.print("       2    10   3   7\n");
	  System.out.print("       3     6   8  12\n");
	  System.out.print("       4     9   1   5\n");
	  System.out.print("       5     6   2   9\n");
	  System.out.print("       6     7   3  11\n");
	  System.out.print("       7    11   4   8\n");
	  System.out.print("       8     7   5  10\n");
	  System.out.print("       9    12   2   6\n");
	  System.out.print("      10     8   7  11\n");
	  System.out.print("      11     5   1  10\n");
	  System.out.print("      12     8   4  12\n");
	  System.out.print("    # Generated by triangle -pqc box.poly\n\n");
	  System.out.print("  Here is the output file `box.1.poly'.  Note that segments have been added\n");
	  System.out.print("  to represent the convex hull, and some segments have been subdivided by\n");
	  System.out.print("  newly added vertices.  Note also that <# of vertices> is set to zero to\n");
	  System.out.print("  indicate that the vertices should be read from the .node file.\n");
	  System.out.print("\n");
	  System.out.print("    0  2  0  1\n");
	  System.out.print("    12  1\n");
	  System.out.print("       1     1   9     5\n");
	  System.out.print("       2     5   7     1\n");
	  System.out.print("       3     8   7     1\n");
	  System.out.print("       4     6   8    10\n");
	  System.out.print("       5     5   6     1\n");
	  System.out.print("       6     3  10     1\n");
	  System.out.print("       7     4  11     1\n");
	  System.out.print("       8     2  12     1\n");
	  System.out.print("       9     9   2     5\n");
	  System.out.print("      10    10   1     1\n");
	  System.out.print("      11    11   3     1\n");
	  System.out.print("      12    12   4     1\n");
	  System.out.print("    1\n");
	  System.out.print("       1   1.5 1.5\n");
	  System.out.print("    # Generated by triangle -pqc box.poly\n");
	  System.out.print("\n");
	  System.out.print("Refinement and Area Constraints:\n");
	  System.out.print("\n");
	  System.out.print("  The -r switch causes a mesh (.node and .ele files) to be read and\n");
	  System.out.print("  refined.  If the -p switch is also used, a .poly file is read and used to\n");
	  System.out.print("  specify edges that are constrained and cannot be eliminated (although\n");
	  System.out.print("  they can be subdivided into smaller edges) by the refinement process.\n");
	  System.out.print("\n");
	  System.out.print("  When you refine a mesh, you generally want to impose tighter constraints.\n");
	  System.out.print("  One way to accomplish this is to use -q with a larger angle, or -a\n");
	  System.out.print("  followed by a smaller area than you used to generate the mesh you are\n");
	  System.out.print("  refining.  Another way to do this is to create an .area file, which\n");
	  System.out.print("  specifies a maximum area for each triangle, and use the -a switch\n");
	  System.out.print("  (without a number following).  Each triangle's area constraint is applied\n");
	  System.out.print("  to that triangle.  Area constraints tend to diffuse as the mesh is\n");
	  System.out.print("  refined, so if there are large variations in area constraint between\n");
	  System.out.print("  adjacent triangles, you may not get the results you want.  In that case,\n");
	  System.out.print("  consider instead using the -u switch and writing a C procedure that\n");
	  System.out.print("  determines which triangles are too large.\n\n");
	  System.out.print("  If you are refining a mesh composed of linear (three-node) elements, the\n");
	  System.out.print("  output mesh contains all the nodes present in the input mesh, in the same\n");
	  System.out.print("  order, with new nodes added at the end of the .node file.  However, the\n");
	  System.out.print("  refinement is not hierarchical: there is no guarantee that each output\n");
	  System.out.print("  element is contained in a single input element.  Often, an output element\n");
	  System.out.print("  can overlap two or three input elements, and some input edges are not\n");
	  System.out.print("  present in the output mesh.  Hence, a sequence of refined meshes forms a\n");
	  System.out.print("  hierarchy of nodes, but not a hierarchy of elements.  If you refine a\n");
	  System.out.print("  mesh of higher-order elements, the hierarchical property applies only to\n");
	  System.out.print("  the nodes at the corners of an element; the midpoint nodes on each edge\n");
	  System.out.print("  are discarded before the mesh is refined.\n\n");
	  System.out.print("  Maximum area constraints in .poly files operate differently from those in\n");
	  System.out.print("  .area files.  A maximum area in a .poly file applies to the whole\n");
	  System.out.print("  (segment-bounded) region in which a point falls, whereas a maximum area\n");
	  System.out.print("  in an .area file applies to only one triangle.  Area constraints in .poly\n");
	  System.out.print("  files are used only when a mesh is first generated, whereas area\n");
	  System.out.print("  constraints in .area files are used only to refine an existing mesh, and\n");
	  System.out.print("  are typically based on a posteriori error estimates resulting from a\n");
	  System.out.print("  finite element simulation on that mesh.\n\n");
	  System.out.print("  `triangle -rq25 object.1' reads object.1.node and object.1.ele, then\n");
	  System.out.print("  refines the triangulation to enforce a 25 degree minimum angle, and then\n");
	  System.out.print("  writes the refined triangulation to object.2.node and object.2.ele.\n");
	  System.out.print("\n");
	  System.out.print("  `triangle -rpaa6.2 z.3' reads z.3.node, z.3.ele, z.3.poly, and z.3.area.\n");
	  System.out.print("  After reconstructing the mesh and its subsegments, Triangle refines the\n");
	  System.out.print("  mesh so that no triangle has area greater than 6.2, and furthermore the\n");
	  System.out.print("  triangles satisfy the maximum area constraints in z.3.area.  No angle\n");
	  System.out.print("  bound is imposed at all.  The output is written to z.4.node, z.4.ele, and\n");
	  System.out.print("  z.4.poly.\n\n");
	  System.out.print("  The sequence `triangle -qa1 x', `triangle -rqa.3 x.1', `triangle -rqa.1\n");
	  System.out.print("  x.2' creates a sequence of successively finer meshes x.1, x.2, and x.3,\n");
	  System.out.print("  suitable for multigrid.\n\n");
	  System.out.print("Convex Hulls and Mesh Boundaries:\n\n");
	  System.out.print("  If the input is a vertex set (not a PSLG), Triangle produces its convex\n");
	  System.out.print("  hull as a by-product in the output .poly file if you use the -c switch.\n");
	  System.out.print("  There are faster algorithms for finding a two-dimensional convex hull\n");
	  System.out.print("  than triangulation, of course, but this one comes for free.\n\n");
	  System.out.print("  If the input is an unconstrained mesh (you are using the -r switch but\n");
	  System.out.print("  not the -p switch), Triangle produces a list of its boundary edges\n");
	  System.out.print("  (including hole boundaries) as a by-product when you use the -c switch.\n");
	  System.out.print("  If you also use the -p switch, the output .poly file contains all the\n");
	  System.out.print("  segments from the input .poly file as well.\n\n");
	  System.out.print("Voronoi Diagrams:\n\n");
	  System.out.print("  The -v switch produces a Voronoi diagram, in files suffixed .v.node and\n");
	  System.out.print("  .v.edge.  For example, `triangle -v points' reads points.node, produces\n");
	  System.out.print("  its Delaunay triangulation in points.1.node and points.1.ele, and\n");
	  System.out.print("  produces its Voronoi diagram in points.1.v.node and points.1.v.edge.  The\n");
	  System.out.print("  .v.node file contains a list of all Voronoi vertices, and the .v.edge\n");
	  System.out.print("  file contains a list of all Voronoi edges, some of which may be infinite\n");
	  System.out.print("  rays.  (The choice of filenames makes it easy to run the set of Voronoi\n");
	  System.out.print("  vertices through Triangle, if so desired.)\n\n");
	  System.out.print("  This implementation does not use exact arithmetic to compute the Voronoi\n");
	  System.out.print("  vertices, and does not check whether neighboring vertices are identical.\n");
	  System.out.print("  Be forewarned that if the Delaunay triangulation is degenerate or\n");
	  System.out.print("  near-degenerate, the Voronoi diagram may have duplicate vertices or\n");
	  System.out.print("  crossing edges.\n\n");
	  System.out.print("  The result is a valid Voronoi diagram only if Triangle's output is a true\n");
	  System.out.print("  Delaunay triangulation.  The Voronoi output is usually meaningless (and\n");
	  System.out.print("  may contain crossing edges and other pathology) if the output is a CDT or\n");
	  System.out.print("  CCDT, or if it has holes or concavities.  If the triangulated domain is\n");
	  System.out.print("  convex and has no holes, you can use -D switch to force Triangle to\n");
	  System.out.print("  construct a conforming Delaunay triangulation instead of a CCDT, so the\n");
	  System.out.print("  Voronoi diagram will be valid.\n\n");
	  System.out.print("Mesh Topology:\n\n");
	  System.out.print("  You may wish to know which triangles are adjacent to a certain Delaunay\n");
	  System.out.print("  edge in an .edge file, which Voronoi cells are adjacent to a certain\n");
	  System.out.print("  Voronoi edge in a .v.edge file, or which Voronoi cells are adjacent to\n");
	  System.out.print("  each other.  All of this information can be found by cross-referencing\n");
	  System.out.print("  output files with the recollection that the Delaunay triangulation and\n");
	  System.out.print("  the Voronoi diagram are planar duals.\n\n");
	  System.out.print("  Specifically, edge i of an .edge file is the dual of Voronoi edge i of\n");
	  System.out.print("  the corresponding .v.edge file, and is rotated 90 degrees counterclock-\n");
	  System.out.print("  wise from the Voronoi edge.  Triangle j of an .ele file is the dual of\n");
	  System.out.print("  vertex j of the corresponding .v.node file.  Voronoi cell k is the dual\n");
	  System.out.print("  of vertex k of the corresponding .node file.\n\n");
	  System.out.print("  Hence, to find the triangles adjacent to a Delaunay edge, look at the\n");
	  System.out.print("  vertices of the corresponding Voronoi edge.  If the endpoints of a\n");
	  System.out.print("  Voronoi edge are Voronoi vertices 2 and 6 respectively, then triangles 2\n");
	  System.out.print("  and 6 adjoin the left and right sides of the corresponding Delaunay edge,\n");
	  System.out.print("  respectively.  To find the Voronoi cells adjacent to a Voronoi edge, look\n");
	  System.out.print("  at the endpoints of the corresponding Delaunay edge.  If the endpoints of\n");
	  System.out.print("  a Delaunay edge are input vertices 7 and 12, then Voronoi cells 7 and 12\n");
	  System.out.print("  adjoin the right and left sides of the corresponding Voronoi edge,\n");
	  System.out.print("  respectively.  To find which Voronoi cells are adjacent to each other,\n");
	  System.out.print("  just read the list of Delaunay edges.\n\n");
	  System.out.print("  Triangle does not write a list of the edges adjoining each Voronoi cell,\n");
	  System.out.print("  but you can reconstructed it straightforwardly.  For instance, to find\n");
	  System.out.print("  all the edges of Voronoi cell 1, search the output .edge file for every\n");
	  System.out.print("  edge that has input vertex 1 as an endpoint.  The corresponding dual\n");
	  System.out.print("  edges in the output .v.edge file form the boundary of Voronoi cell 1.\n");
	  System.out.print("\n");
	  System.out.print("  For each Voronoi vertex, the .neigh file gives a list of the three\n");
	  System.out.print("  Voronoi vertices attached to it.  You might find this more convenient\n");
	  System.out.print("  than the .v.edge file.\n\n");
	  System.out.print("Quadratic Elements:\n\n");
	  System.out.print("  Triangle generates meshes with subparametric quadratic elements if the\n");
	  System.out.print("  -o2 switch is specified.  Quadratic elements have six nodes per element,\n");
	  System.out.print("  rather than three.  `Subparametric' means that the edges of the triangles\n");
	  System.out.print("  are always straight, so that subparametric quadratic elements are\n");
	  System.out.print("  geometrically identical to linear elements, even though they can be used\n");
	  System.out.print("  with quadratic interpolating functions.  The three extra nodes of an\n");
	  System.out.print("  element fall at the midpoints of the three edges, with the fourth, fifth,\n");
	  System.out.print("  and sixth nodes appearing opposite the first, second, and third corners\n");
	  System.out.print("  respectively.\n\n");
	  System.out.print("Domains with Small Angles:\n\n");
	  System.out.print("  If two input segments adjoin each other at a small angle, clearly the -q\n");
	  System.out.print("  switch cannot remove the small angle.  Moreover, Triangle may have no\n");
	  System.out.print("  choice but to generate additional triangles whose smallest angles are\n");
	  System.out.print("  smaller than the specified bound.  However, these triangles only appear\n");
	  System.out.print("  between input segments separated by small angles.  Moreover, if you\n");
	  System.out.print("  request a minimum angle of theta degrees, Triangle will generally produce\n");
	  System.out.print("  no angle larger than 180 - 2 theta, even if it is forced to compromise on\n");
	  System.out.print("  the minimum angle.\n\n");
	  System.out.print("Statistics:\n\n");
	  System.out.print("  After generating a mesh, Triangle prints a count of entities in the\n");
	  System.out.print("  output mesh, including the number of vertices, triangles, edges, exterior\n");
	  System.out.print("  boundary edges (i.e. subsegments on the boundary of the triangulation,\n");
	  System.out.print("  including hole boundaries), interior boundary edges (i.e. subsegments of\n");
	  System.out.print("  input segments not on the boundary), and total subsegments.  If you've\n");
	  System.out.print("  forgotten the statistics for an existing mesh, run Triangle on that mesh\n");
	  System.out.print("  with the -rNEP switches to read the mesh and print the statistics without\n");
	  System.out.print("  writing any files.  Use -rpNEP if you've got a .poly file for the mesh.\n");
	  System.out.print("\n");
	  System.out.print("  The -V switch produces extended statistics, including a rough estimate\n");
	  System.out.print("  of memory use, the number of calls to geometric predicates, and\n");
	  System.out.print("  histograms of the angles and the aspect ratios of the triangles in the\n");
	  System.out.print("  mesh.\n\n");
	  System.out.print("Exact Arithmetic:\n\n");
	  System.out.print("  Triangle uses adaptive exact arithmetic to perform what computational\n");
	  System.out.print("  geometers call the `orientation' and `incircle' tests.  If the floating-\n");
	  System.out.print("  point arithmetic of your machine conforms to the IEEE 754 standard (as\n");
	  System.out.print("  most workstations do), and does not use extended precision internal\n");
	  System.out.print("  floating-point registers, then your output is guaranteed to be an\n");
	  System.out.print("  absolutely true Delaunay or constrained Delaunay triangulation, roundoff\n");
	  System.out.print("  error notwithstanding.  The word `adaptive' implies that these arithmetic\n");
	  System.out.print("  routines compute the result only to the precision necessary to guarantee\n");
	  System.out.print("  correctness, so they are usually nearly as fast as their approximate\n");
	  System.out.print("  counterparts.\n\n");
	  System.out.print("  May CPUs, including Intel x86 processors, have extended precision\n");
	  System.out.print("  floating-point registers.  These must be reconfigured so their precision\n");
	  System.out.print("  is reduced to memory precision.  Triangle does this if it is compiled\n");
	  System.out.print("  correctly.  See the makefile for details.\n\n");
	  System.out.print("  The exact tests can be disabled with the -X switch.  On most inputs, this\n");
	  System.out.print("  switch reduces the computation time by about eight percent--it's not\n");
	  System.out.print("  worth the risk.  There are rare difficult inputs (having many collinear\n");
	  System.out.print("  and cocircular vertices), however, for which the difference in speed\n");
	  System.out.print("  could be a factor of two.  Be forewarned that these are precisely the\n");
	  System.out.print("  inputs most likely to cause errors if you use the -X switch.  Hence, the\n");
	  System.out.print("  -X switch is not recommended.\n\n");
	  System.out.print("  Unfortunately, the exact tests don't solve every numerical problem.\n");
	  System.out.print("  Exact arithmetic is not used to compute the positions of new vertices,\n");
	  System.out.print("  because the bit complexity of vertex coordinates would grow without\n");
	  System.out.print("  bound.  Hence, segment intersections aren't computed exactly; in very\n");
	  System.out.print("  unusual cases, roundoff error in computing an intersection point might\n");
	  System.out.print("  actually lead to an inverted triangle and an invalid triangulation.\n");
	  System.out.print("  (This is one reason to specify your own intersection points in your .poly\n");
	  System.out.print("  files.)  Similarly, exact arithmetic is not used to compute the vertices\n");
	  System.out.print("  of the Voronoi diagram.\n\n");
	  System.out.print("  Another pair of problems not solved by the exact arithmetic routines is\n");
	  System.out.print("  underflow and overflow.  If Triangle is compiled for double precision\n");
	  System.out.print("  arithmetic, I believe that Triangle's geometric predicates work correctly\n");
	  System.out.print("  if the exponent of every input coordinate falls in the range [-148, 201].\n");
	  System.out.print("  Underflow can silently prevent the orientation and incircle tests from\n");
	  System.out.print("  being performed exactly, while overflow typically causes a floating\n");
	  System.out.print("  exception.\n\n");
	  System.out.print("Calling Triangle from Another Program:\n\n");
	  System.out.print("  Read the file triangle.h for details.\n\n");
	  System.out.print("Troubleshooting:\n\n");
	  System.out.print("  Please read this section before mailing me bugs.\n\n");
	  System.out.print("  `My output mesh has no triangles!'\n\n");
	  System.out.print("    If you're using a PSLG, you've probably failed to specify a proper set\n");
	  System.out.print("    of bounding segments, or forgotten to use the -c switch.  Or you may\n");
	  System.out.print("    have placed a hole badly, thereby eating all your triangles.  To test\n");
	  System.out.print("    these possibilities, try again with the -c and -O switches.\n");
	  System.out.print("    Alternatively, all your input vertices may be collinear, in which case\n");
	  System.out.print("    you can hardly expect to triangulate them.\n\n");
	  System.out.print("  `Triangle doesn't terminate, or just crashes.'\n\n");
	  System.out.print("    Bad things can happen when triangles get so small that the distance\n");
	  System.out.print("    between their vertices isn't much larger than the precision of your\n");
	  System.out.print("    machine's arithmetic.  If you've compiled Triangle for single-precision\n");
	  System.out.print("    arithmetic, you might do better by recompiling it for double-precision.\n");
	  System.out.print("    Then again, you might just have to settle for more lenient constraints\n");
	  System.out.print("    on the minimum angle and the maximum area than you had planned.\n");
	  System.out.print("\n");
	  System.out.print("    You can minimize precision problems by ensuring that the origin lies\n");
	  System.out.print("    inside your vertex set, or even inside the densest part of your\n");
	  System.out.print("    mesh.  If you're triangulating an object whose x-coordinates all fall\n");
	  System.out.print("    between 6247133 and 6247134, you're not leaving much floating-point\n");
	  System.out.print("    precision for Triangle to work with.\n\n");
	  System.out.print("    Precision problems can occur covertly if the input PSLG contains two\n");
	  System.out.print("    segments that meet (or intersect) at an extremely small angle, or if\n");
	  System.out.print("    such an angle is introduced by the -c switch.  If you don't realize\n");
	  System.out.print("    that a tiny angle is being formed, you might never discover why\n");
	  System.out.print("    Triangle is crashing.  To check for this possibility, use the -S switch\n");
	  System.out.print("    (with an appropriate limit on the number of Steiner points, found by\n");
	  System.out.print("    trial-and-error) to stop Triangle early, and view the output .poly file\n");
	  System.out.print("    with Show Me (described below).  Look carefully for regions where dense\n");
	  System.out.print("    clusters of vertices are forming and for small angles between segments.\n");
	  System.out.print("    Zoom in closely, as such segments might look like a single segment from\n");
	  System.out.print("    a distance.\n\n");
	  System.out.print("    If some of the input values are too large, Triangle may suffer a\n");
	  System.out.print("    floating exception due to overflow when attempting to perform an\n");
	  System.out.print("    orientation or incircle test.  (Read the section on exact arithmetic\n");
	  System.out.print("    above.)  Again, I recommend compiling Triangle for double (rather\n");
	  System.out.print("    than single) precision arithmetic.\n\n");
	  System.out.print("    Unexpected problems can arise if you use quality meshing (-q, -a, or\n");
	  System.out.print("    -u) with an input that is not segment-bounded--that is, if your input\n");
	  System.out.print("    is a vertex set, or you're using the -c switch.  If the convex hull of\n");
	  System.out.print("    your input vertices has collinear vertices on its boundary, an input\n");
	  System.out.print("    vertex that you think lies on the convex hull might actually lie just\n");
	  System.out.print("    inside the convex hull.  If so, the vertex and the nearby convex hull\n");
	  System.out.print("    edge form an extremely thin triangle.  When Triangle tries to refine\n");
	  System.out.print("    the mesh to enforce angle and area constraints, Triangle might generate\n");
	  System.out.print("    extremely tiny triangles, or it might fail because of insufficient\n");
	  System.out.print("    floating-point precision.\n\n");
	  System.out.print("  `The numbering of the output vertices doesn't match the input vertices.'\n");
	  System.out.print("\n");
	  System.out.print("    You may have had duplicate input vertices, or you may have eaten some\n");
	  System.out.print("    of your input vertices with a hole, or by placing them outside the area\n");
	  System.out.print("    enclosed by segments.  In any case, you can solve the problem by not\n");
	  System.out.print("    using the -j switch.\n\n");
	  System.out.print("  `Triangle executes without incident, but when I look at the resulting\n");
	  System.out.print("  mesh, it has overlapping triangles or other geometric inconsistencies.'\n");
	  System.out.print("\n");
	  System.out.print("    If you select the -X switch, Triangle occasionally makes mistakes due\n");
	  System.out.print("    to floating-point roundoff error.  Although these errors are rare,\n");
	  System.out.print("    don't use the -X switch.  If you still have problems, please report the\n");
	  System.out.print("    bug.\n\n");
	  System.out.print("  `Triangle executes without incident, but when I look at the resulting\n");
	  System.out.print("  Voronoi diagram, it has overlapping edges or other geometric\n");
	  System.out.print("  inconsistencies.'\n");
	  System.out.print("\n");
	  System.out.print("    If your input is a PSLG (-p), you can only expect a meaningful Voronoi\n");
	  System.out.print("    diagram if the domain you are triangulating is convex and free of\n");
	  System.out.print("    holes, and you use the -D switch to construct a conforming Delaunay\n");
	  System.out.print("    triangulation (instead of a CDT or CCDT).\n\n");
	  System.out.print("  Strange things can happen if you've taken liberties with your PSLG.  Do\n");
	  System.out.print("  you have a vertex lying in the middle of a segment?  Triangle sometimes\n");
	  System.out.print("  copes poorly with that sort of thing.  Do you want to lay out a collinear\n");
	  System.out.print("  row of evenly spaced, segment-connected vertices?  Have you simply\n");
	  System.out.print("  defined one long segment connecting the leftmost vertex to the rightmost\n");
	  System.out.print("  vertex, and a bunch of vertices lying along it?  This method occasionally\n");
	  System.out.print("  works, especially with horizontal and vertical lines, but often it\n");
	  System.out.print("  doesn't, and you'll have to connect each adjacent pair of vertices with a\n");
	  System.out.print("  separate segment.  If you don't like it, tough.\n\n");
	  System.out.print("  Furthermore, if you have segments that intersect other than at their\n");
	  System.out.print("  endpoints, try not to let the intersections fall extremely close to PSLG\n");
	  System.out.print("  vertices or each other.\n\n");
	  System.out.print("  If you have problems refining a triangulation not produced by Triangle:\n");
	  System.out.print("  Are you sure the triangulation is geometrically valid?  Is it formatted\n");
	  System.out.print("  correctly for Triangle?  Are the triangles all listed so the first three\n");
	  System.out.print("  vertices are their corners in counterclockwise order?  Are all of the\n");
	  System.out.print("  triangles constrained Delaunay?  Triangle's Delaunay refinement algorithm\n");
	  System.out.print("  assumes that it starts with a CDT.\n\n");
	  System.out.print("Show Me:\n\n");
	  System.out.print("  Triangle comes with a separate program named `Show Me', whose primary\n");
	  System.out.print("  purpose is to draw meshes on your screen or in PostScript.  Its secondary\n");
	  System.out.print("  purpose is to check the validity of your input files, and do so more\n");
	  System.out.print("  thoroughly than Triangle does.  Unlike Triangle, Show Me requires that\n");
	  System.out.print("  you have the X Windows system.  Sorry, Microsoft Windows users.\n");
	  System.out.print("\n");
	  System.out.print("Triangle on the Web:\n");
	  System.out.print("\n");
	  System.out.print("  To see an illustrated version of these instructions, check out\n");
	  System.out.print("\n");
	  System.out.print("    http://www.cs.cmu.edu/~quake/triangle.html\n");
	  System.out.print("\n");
	  System.out.print("A Brief Plea:\n");
	  System.out.print("\n");
	  System.out.print("  If you use Triangle, and especially if you use it to accomplish real\n");
	  System.out.print("  work, I would like very much to hear from you.  A short letter or email\n");
	  System.out.print("  (to jrs@cs.berkeley.edu) describing how you use Triangle will mean a lot\n");
	  System.out.print("  to me.  The more people I know are using this program, the more easily I\n");
	  System.out.print("  can justify spending time on improvements, which in turn will benefit\n");
	  System.out.print("  you.  Also, I can put you on a list to receive email whenever a new\n");
	  System.out.print("  version of Triangle is available.\n\n");
	  System.out.print("  If you use a mesh generated by Triangle in a publication, please include\n");
	  System.out.print("  an acknowledgment as well.  And please spell Triangle with a capital `T'!\n");
	  System.out.print("  If you want to include a citation, use `Jonathan Richard Shewchuk,\n");
	  System.out.print("  ``Triangle: Engineering a 2D Quality Mesh Generator and Delaunay\n");
	  System.out.print("  Triangulator,'' in Applied Computational Geometry:  Towards Geometric\n");
	  System.out.print("  Engineering (Ming C. Lin and Dinesh Manocha, editors), volume 1148 of\n");
	  System.out.print("  Lecture Notes in Computer Science, pages 203-222, Springer-Verlag,\n");
	  System.out.print("  Berlin, May 1996.  (From the First ACM Workshop on Applied Computational\n");
	  System.out.print("  Geometry.)'\n\n");
	  System.out.print("Research credit:\n\n");
	  System.out.print("  Of course, I can take credit for only a fraction of the ideas that made\n");
	  System.out.print("  this mesh generator possible.  Triangle owes its existence to the efforts\n");
	  System.out.print("  of many fine computational geometers and other researchers, including\n");
	  System.out.print("  Marshall Bern, L. Paul Chew, Kenneth L. Clarkson, Boris Delaunay, Rex A.\n");
	  System.out.print("  Dwyer, David Eppstein, Steven Fortune, Leonidas J. Guibas, Donald E.\n");
	  System.out.print("  Knuth, Charles L. Lawson, Der-Tsai Lee, Gary L. Miller, Ernst P. Mucke,\n");
	  System.out.print("  Steven E. Pav, Douglas M. Priest, Jim Ruppert, Isaac Saias, Bruce J.\n");
	  System.out.print("  Schachter, Micha Sharir, Peter W. Shor, Daniel D. Sleator, Jorge Stolfi,\n");
	  System.out.print("  Robert E. Tarjan, Alper Ungor, Christopher J. Van Wyk, Noel J.\n");
	  System.out.print("  Walkington, and Binhai Zhu.  See the comments at the beginning of the\n");
	  System.out.print("  source code for references.\n\n");
	  triexit(0);
	}

	//#endif // not TRILIBRARY

	//***************************************************************************
	//                                                                           
	//  internalerror()   Ask the user to send me the defective product.  Exit.  
	//                                                                           
	//***************************************************************************

	void internalerror()
	{
	  System.out.print("  Please report this bug to jrs@cs.berkeley.edu\n");
	  System.out.print("  Include the message above, your input data set, and the exact\n");
	  System.out.print("    command line you used to run Triangle.\n");
	  triexit(1);
	}

	//***************************************************************************
	//                                                                           
	//  parsecommandline()   Read the command line, identify switches, and set   
	//                       up options and file names.                          
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void parsecommandline(int argc,String *argv, struct behavior *b)
	//#else
	void parsecommandline(argc, argv, b)
	int argc;
	String[] argv;
	behavior b;
	//#endif // not ANSI_DECLARATORS

	{
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if TRILIBRARY
	//#define STARTINDEX 0
	//#else
	//#define STARTINDEX 1
	  int increment;
	  int meshnumber;
	//#endif // not TRILIBRARY
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! CDT_ONLY
	  int k;
	  String workstring = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
	//#endif
	  int i;
	  int j;

	  b.poly = b.refine = b.quality = 0;
	  b.vararea = b.fixedarea = b.usertest = 0;
	  b.regionattrib = b.convex = b.weighted = b.jettison = 0;
	  b.firstnumber = 1;
	  b.edgesout = b.voronoi = b.neighbors = b.geomview = 0;
	  b.nobound = b.nopolywritten = b.nonodewritten = b.noelewritten = 0;
	  b.noiterationnum = 0;
	  b.noholes = b.noexact = 0;
	  b.incremental = b.sweepline = 0;
	  b.dwyer = 1;
	  b.splitseg = 0;
	  b.docheck = 0;
	  b.nobisect = 0;
	  b.conformdel = 0;
	  b.steiner = -1;
	  b.order = 1;
	  b.minangle = 0.0;
	  b.maxarea = -1.0;
	  b.quiet = b.verbose = 0;
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! TRILIBRARY
	  b.innodefilename[0] = '\0';
	//#endif // not TRILIBRARY

	  for (i = DefineConstantsTriangle.STARTINDEX; i < argc; i++)
	  {
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! TRILIBRARY
		if (argv.charAt(i)[0] == '-')
		{
	//#endif // not TRILIBRARY
		  for (j = DefineConstantsTriangle.STARTINDEX; argv.charAt(i)[j] != '\0'; j++)
		  {
			if (argv.charAt(i)[j] == 'p')
			{
			  b.poly = 1;
		}
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! CDT_ONLY
			if (argv.charAt(i)[j] == 'r')
			{
			  b.refine = 1;
		}
			if (argv.charAt(i)[j] == 'q')
			{
			  b.quality = 1;
			  if (((argv.charAt(i)[j + 1] >= '0') && (argv.charAt(i)[j + 1] <= '9')) || (argv.charAt(i)[j + 1] == '.'))
			  {
				k = 0;
				while (((argv.charAt(i)[j + 1] >= '0') && (argv.charAt(i)[j + 1] <= '9')) || (argv.charAt(i)[j + 1] == '.'))
				{
				  j++;
				  workstring = StringHelper.changeCharacter(workstring, k, argv.charAt(i)[j]);
				  k++;
				}
				workstring = StringHelper.changeCharacter(workstring, k, '\0');
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
				b.minangle = (REAL) strtod(workstring, (char) null);
				}
		  else
		  {
				b.minangle = 20.0;
		  }
		}
			if (argv.charAt(i)[j] == 'a')
			{
			  b.quality = 1;
			  if (((argv.charAt(i)[j + 1] >= '0') && (argv.charAt(i)[j + 1] <= '9')) || (argv.charAt(i)[j + 1] == '.'))
			  {
				b.fixedarea = 1;
				k = 0;
				while (((argv.charAt(i)[j + 1] >= '0') && (argv.charAt(i)[j + 1] <= '9')) || (argv.charAt(i)[j + 1] == '.'))
				{
				  j++;
				  workstring = StringHelper.changeCharacter(workstring, k, argv.charAt(i)[j]);
				  k++;
				}
				workstring = StringHelper.changeCharacter(workstring, k, '\0');
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
				b.maxarea = (REAL) strtod(workstring, (char) null);
				if (b.maxarea <= 0.0)
				{
				  System.out.print("Error:  Maximum area must be greater than zero.\n");
				  triexit(1);
			}
				}
		  else
		  {
				b.vararea = 1;
		  }
		}
			if (argv.charAt(i)[j] == 'u')
			{
			  b.quality = 1;
			  b.usertest = 1;
			}
	//#endif // not CDT_ONLY
			if (argv.charAt(i)[j] == 'A')
			{
			  b.regionattrib = 1;
			}
			if (argv.charAt(i)[j] == 'c')
			{
			  b.convex = 1;
			}
			if (argv.charAt(i)[j] == 'w')
			{
			  b.weighted = 1;
			}
			if (argv.charAt(i)[j] == 'W')
			{
			  b.weighted = 2;
			}
			if (argv.charAt(i)[j] == 'j')
			{
			  b.jettison = 1;
			}
			if (argv.charAt(i)[j] == 'z')
			{
			  b.firstnumber = 0;
			}
			if (argv.charAt(i)[j] == 'e')
			{
			  b.edgesout = 1;
		}
			if (argv.charAt(i)[j] == 'v')
			{
			  b.voronoi = 1;
		}
			if (argv.charAt(i)[j] == 'n')
			{
			  b.neighbors = 1;
		}
			if (argv.charAt(i)[j] == 'g')
			{
			  b.geomview = 1;
		}
			if (argv.charAt(i)[j] == 'B')
			{
			  b.nobound = 1;
		}
			if (argv.charAt(i)[j] == 'P')
			{
			  b.nopolywritten = 1;
		}
			if (argv.charAt(i)[j] == 'N')
			{
			  b.nonodewritten = 1;
		}
			if (argv.charAt(i)[j] == 'E')
			{
			  b.noelewritten = 1;
		}
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! TRILIBRARY
			if (argv.charAt(i)[j] == 'I')
			{
			  b.noiterationnum = 1;
		}
	//#endif // not TRILIBRARY
			if (argv.charAt(i)[j] == 'O')
			{
			  b.noholes = 1;
		}
			if (argv.charAt(i)[j] == 'X')
			{
			  b.noexact = 1;
		}
			if (argv.charAt(i)[j] == 'o')
			{
			  if (argv.charAt(i)[j + 1] == '2')
			  {
				j++;
				b.order = 2;
			  }
		}
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! CDT_ONLY
			if (argv.charAt(i)[j] == 'Y')
			{
			  b.nobisect++;
		}
			if (argv.charAt(i)[j] == 'S')
			{
			  b.steiner = 0;
			  while ((argv.charAt(i)[j + 1] >= '0') && (argv.charAt(i)[j + 1] <= '9'))
			  {
				j++;
				b.steiner = b.steiner * 10 + (int)(argv.charAt(i)[j] - '0');
			  }
			}
	//#endif // not CDT_ONLY
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! REDUCED
			if (argv.charAt(i)[j] == 'i')
			{
			  b.incremental = 1;
			}
			if (argv.charAt(i)[j] == 'F')
			{
			  b.sweepline = 1;
			}
	//#endif // not REDUCED
			if (argv.charAt(i)[j] == 'l')
			{
			  b.dwyer = 0;
			}
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! REDUCED
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! CDT_ONLY
			if (argv.charAt(i)[j] == 's')
			{
			  b.splitseg = 1;
			}
			if ((argv.charAt(i)[j] == 'D') || (argv.charAt(i)[j] == 'L'))
			{
			  b.quality = 1;
			  b.conformdel = 1;
			}
	//#endif // not CDT_ONLY
			if (argv.charAt(i)[j] == 'C')
			{
			  b.docheck = 1;
			}
	//#endif // not REDUCED
			if (argv.charAt(i)[j] == 'Q')
			{
			  b.quiet = 1;
			}
			if (argv.charAt(i)[j] == 'V')
			{
			  b.verbose++;
			}
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! TRILIBRARY
			if ((argv.charAt(i)[j] == 'h') || (argv.charAt(i)[j] == 'H') || (argv.charAt(i)[j] == '?'))
			{
			  info();
		}
	//#endif // not TRILIBRARY
		  }
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! TRILIBRARY
			}
		else
		{
		  b.innodefilename = String.valueOf(argv.charAt(i)).substring(0, DefineConstantsTriangle.FILENAMESIZE - 1);
		  b.innodefilename[DefineConstantsTriangle.FILENAMESIZE - 1] = '\0';
		}
	//#endif // not TRILIBRARY
	  }
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! TRILIBRARY
	  if (b.innodefilename.charAt(0) == '\0')
	  {
		syntax();
	  }
	  if (!strcmp(b.innodefilename.charAt(String.valueOf(b.innodefilename).length() - 5), ".node"))
	  {
		b.innodefilename[String.valueOf(b.innodefilename).length() - 5] = '\0';
	  }
	  if (!strcmp(b.innodefilename.charAt(String.valueOf(b.innodefilename).length() - 5), ".poly"))
	  {
		b.innodefilename[String.valueOf(b.innodefilename).length() - 5] = '\0';
		b.poly = 1;
	  }
	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! CDT_ONLY
	  if (!strcmp(b.innodefilename.charAt(String.valueOf(b.innodefilename).length() - 4), ".ele"))
	  {
		b.innodefilename[String.valueOf(b.innodefilename).length() - 4] = '\0';
		b.refine = 1;
	  }
	  if (!strcmp(b.innodefilename.charAt(String.valueOf(b.innodefilename).length() - 5), ".area"))
	  {
		b.innodefilename[String.valueOf(b.innodefilename).length() - 5] = '\0';
		b.refine = 1;
		b.quality = 1;
		b.vararea = 1;
	  }
	//#endif // not CDT_ONLY
	//#endif // not TRILIBRARY
	  b.usesegments = b.poly || b.refine || b.quality || b.convex;
	  b.goodangle = Math.cos(b.minangle * DefineConstantsTriangle.PI / 180.0);
	  if (b.goodangle == 1.0)
	  {
		b.offconstant = 0.0;
	  }
	  else
	  {
		b.offconstant = 0.475 * Math.sqrt((1.0 + b.goodangle) / (1.0 - b.goodangle));
	  }
	  b.goodangle *= b.goodangle;
	  if (b.refine != 0 && b.noiterationnum != 0)
	  {
		System.out.print("Error:  You cannot use the -I switch when refining a triangulation.\n");
		triexit(1);
	  }
	  // Be careful not to allocate space for element area constraints that 
	  //   will never be assigned any value (other than the default -1.0).  
	  if (b.refine == 0 && b.poly == 0)
	  {
		b.vararea = 0;
	  }
	  // Be careful not to add an extra attribute to each element unless the 
	  //   input supports it (PSLG in, but not refining a preexisting mesh). 
	  if (b.refine != 0 || b.poly == 0)
	  {
		b.regionattrib = 0;
	  }
	  // Regular/weighted triangulations are incompatible with PSLGs 
	  //   and meshing.                                              
	  if (b.weighted != 0 && (b.poly != 0 || b.quality != 0))
	  {
		b.weighted = 0;
		if (b.quiet == 0)
		{
		  System.out.print("Warning:  weighted triangulations (-w, -W) are incompatible\n");
		  System.out.print("  with PSLGs (-p) and meshing (-q, -a, -u).  Weights ignored.\n");
		}
	  }
	  if (b.jettison != 0 && b.nonodewritten && b.quiet == 0)
	  {
		System.out.print("Warning:  -j and -N switches are somewhat incompatible.\n");
		System.out.print("  If any vertices are jettisoned, you will need the output\n");
		System.out.print("  .node file to reconstruct the new node indices.");
	  }

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ! TRILIBRARY
	  b.inpolyfilename = b.innodefilename;
	  b.inelefilename = b.innodefilename;
	  b.areafilename = b.innodefilename;
	  increment = 0;
	  workstring = b.innodefilename;
	  j = 1;
	  while (workstring.charAt(j) != '\0')
	  {
		if ((workstring.charAt(j) == '.') && (workstring.charAt(j + 1) != '\0'))
		{
		  increment = j + 1;
		}
		j++;
	  }
	  meshnumber = 0;
	  if (increment > 0)
	  {
		j = increment;
		do
		{
		  if ((workstring.charAt(j) >= '0') && (workstring.charAt(j) <= '9'))
		  {
			meshnumber = meshnumber * 10 + (int)(workstring.charAt(j) - '0');
		  }
		  else
		  {
			increment = 0;
		  }
		  j++;
		} while (workstring.charAt(j) != '\0');
	  }
	  if (b.noiterationnum != 0)
	  {
		b.outnodefilename = b.innodefilename;
		b.outelefilename = b.innodefilename;
		b.edgefilename = b.innodefilename;
		b.vnodefilename = b.innodefilename;
		b.vedgefilename = b.innodefilename;
		b.neighborfilename = b.innodefilename;
		b.offfilename = b.innodefilename;
		b.outnodefilename += ".node";
		b.outelefilename += ".ele";
		b.edgefilename += ".edge";
		b.vnodefilename += ".v.node";
		b.vedgefilename += ".v.edge";
		b.neighborfilename += ".neigh";
		b.offfilename += ".off";
	  }
	  else if (increment == 0)
	  {
		b.outnodefilename = b.innodefilename;
		b.outpolyfilename = b.innodefilename;
		b.outelefilename = b.innodefilename;
		b.edgefilename = b.innodefilename;
		b.vnodefilename = b.innodefilename;
		b.vedgefilename = b.innodefilename;
		b.neighborfilename = b.innodefilename;
		b.offfilename = b.innodefilename;
		b.outnodefilename += ".1.node";
		b.outpolyfilename += ".1.poly";
		b.outelefilename += ".1.ele";
		b.edgefilename += ".1.edge";
		b.vnodefilename += ".1.v.node";
		b.vedgefilename += ".1.v.edge";
		b.neighborfilename += ".1.neigh";
		b.offfilename += ".1.off";
	  }
	  else
	  {
		workstring = StringHelper.changeCharacter(workstring, increment, '%');
		workstring = StringHelper.changeCharacter(workstring, increment + 1, 'd');
		workstring = StringHelper.changeCharacter(workstring, increment + 2, '\0');
		String.format(b.outnodefilename, workstring, meshnumber + 1);
		b.outpolyfilename = b.outnodefilename;
		b.outelefilename = b.outnodefilename;
		b.edgefilename = b.outnodefilename;
		b.vnodefilename = b.outnodefilename;
		b.vedgefilename = b.outnodefilename;
		b.neighborfilename = b.outnodefilename;
		b.offfilename = b.outnodefilename;
		b.outnodefilename += ".node";
		b.outpolyfilename += ".poly";
		b.outelefilename += ".ele";
		b.edgefilename += ".edge";
		b.vnodefilename += ".v.node";
		b.vedgefilename += ".v.edge";
		b.neighborfilename += ".neigh";
		b.offfilename += ".off";
	  }
	  b.innodefilename += ".node";
	  b.inpolyfilename += ".poly";
	  b.inelefilename += ".ele";
	  b.areafilename += ".area";
	//#endif // not TRILIBRARY
	}

	//*                                                                         *
	//*                                                                         *
	//******** User interaction routines begin here                      ********

	//******** Debugging routines begin here                             ********
	//*                                                                         *
	//*                                                                         *

	//***************************************************************************
	//                                                                           
	//  printtriangle()   Print out the details of an oriented triangle.         
	//                                                                           
	//  I originally wrote this procedure to simplify debugging; it can be       
	//  called directly from the debugger, and presents information about an     
	//  oriented triangle in digestible form.  It's also used when the           
	//  highest level of verbosity (`-VVV') is specified.                        
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void printtriangle(struct mesh *m, struct behavior b, struct otri *t)
	//#else
	void printtriangle(m, b, t)
	mesh m;
	behavior b;
	otri t;
	//#endif // not ANSI_DECLARATORS

	{
	  otri printtri = new otri();
	  osub printsh = new osub();
	  REAL printvertex;

	  System.out.printf("triangle x%lx with orientation %d:\n", (int) t.tri, t.orient);
	  (printtri).orient = (int)((int)(t.tri[0]) & (int) 3l);
	  (printtri).tri = (REAL ** *)((int)(t.tri[0]) ^ (int)(printtri).orient);
	  if (printtri.tri == m.dummytri)
	  {
		System.out.print("    [0] = Outer space\n");
	  }
	  else
	  {
		System.out.printf("    [0] = x%lx  %d\n", (int) printtri.tri, printtri.orient);
	  }
	  (printtri).orient = (int)((int)(t.tri[1]) & (int) 3l);
	  (printtri).tri = (REAL ** *)((int)(t.tri[1]) ^ (int)(printtri).orient);
	  if (printtri.tri == m.dummytri)
	  {
		System.out.print("    [1] = Outer space\n");
	  }
	  else
	  {
		System.out.printf("    [1] = x%lx  %d\n", (int) printtri.tri, printtri.orient);
	  }
	  (printtri).orient = (int)((int)(t.tri[2]) & (int) 3l);
	  (printtri).tri = (REAL ** *)((int)(t.tri[2]) ^ (int)(printtri).orient);
	  if (printtri.tri == m.dummytri)
	  {
		System.out.print("    [2] = Outer space\n");
	  }
	  else
	  {
		System.out.printf("    [2] = x%lx  %d\n", (int) printtri.tri, printtri.orient);
	  }

	  printvertex = (REAL) t.tri[plus1mod3[t.orient] + 3];
	  if (printvertex == (REAL) null)
		System.out.printf("    Origin[%d] = NULL\n", (t.orient + 1) % 3 + 3);
	  else
		System.out.printf("    Origin[%d] = x%lx  (%.12g, %.12g)\n", (t.orient + 1) % 3 + 3, (int) printvertex, printvertex[0], printvertex[1]);
	  printvertex = (REAL) t.tri[minus1mod3[t.orient] + 3];
	  if (printvertex == (REAL) null)
		System.out.printf("    Dest  [%d] = NULL\n", (t.orient + 2) % 3 + 3);
	  else
		System.out.printf("    Dest  [%d] = x%lx  (%.12g, %.12g)\n", (t.orient + 2) % 3 + 3, (int) printvertex, printvertex[0], printvertex[1]);
	  printvertex = (REAL) t.tri[t.orient + 3];
	  if (printvertex == (REAL) null)
		System.out.printf("    Apex  [%d] = NULL\n", t.orient + 3);
	  else
		System.out.printf("    Apex  [%d] = x%lx  (%.12g, %.12g)\n", t.orient + 3, (int) printvertex, printvertex[0], printvertex[1]);

	  if (b.usesegments != 0)
	  {
		(printsh).ssorient = (int)((int)(t.tri[6]) & (int) 1l);
		(printsh).ss = (REAL ** *)((int)(t.tri[6]) & ~ (int) 3l);
		if (printsh.ss != m.dummysub)
		{
		  System.out.printf("    [6] = x%lx  %d\n", (int) printsh.ss, printsh.ssorient);
		}
		(printsh).ssorient = (int)((int)(t.tri[7]) & (int) 1l);
		(printsh).ss = (REAL ** *)((int)(t.tri[7]) & ~ (int) 3l);
		if (printsh.ss != m.dummysub)
		{
		  System.out.printf("    [7] = x%lx  %d\n", (int) printsh.ss, printsh.ssorient);
		}
		(printsh).ssorient = (int)((int)(t.tri[8]) & (int) 1l);
		(printsh).ss = (REAL ** *)((int)(t.tri[8]) & ~ (int) 3l);
		if (printsh.ss != m.dummysub)
		{
		  System.out.printf("    [8] = x%lx  %d\n", (int) printsh.ss, printsh.ssorient);
		}
	  }

	  if (b.vararea != 0)
	  {
	//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		System.out.printf("    Area constraint:  %.4g\n", ((REAL) t.tri)[m.areaboundindex]);
	  }
	}

	//***************************************************************************
	//                                                                           
	//  printsubseg()   Print out the details of an oriented subsegment.         
	//                                                                           
	//  I originally wrote this procedure to simplify debugging; it can be       
	//  called directly from the debugger, and presents information about an     
	//  oriented subsegment in digestible form.  It's also used when the highest 
	//  level of verbosity (`-VVV') is specified.                                
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void printsubseg(struct mesh m, struct behavior b, struct osub *s)
	//#else
	void printsubseg(m, b, s)
	mesh m;
	behavior b;
	osub s;
	//#endif // not ANSI_DECLARATORS

	{
	  osub printsh = new osub();
	  otri printtri = new otri();
	  REAL printvertex;

	  System.out.printf("subsegment x%lx with orientation %d and mark %d:\n", (int) s.ss, s.ssorient, (* (int)(s.ss + 8)));
	  (printsh).ssorient = (int)((int)(s.ss[0]) & (int) 1l);
	  (printsh).ss = (REAL ** *)((int)(s.ss[0]) & ~ (int) 3l);
	  if (printsh.ss == m.dummysub)
	  {
		System.out.print("    [0] = No subsegment\n");
	  }
	  else
	  {
		System.out.printf("    [0] = x%lx  %d\n", (int) printsh.ss, printsh.ssorient);
	  }
	  (printsh).ssorient = (int)((int)(s.ss[1]) & (int) 1l);
	  (printsh).ss = (REAL ** *)((int)(s.ss[1]) & ~ (int) 3l);
	  if (printsh.ss == m.dummysub)
	  {
		System.out.print("    [1] = No subsegment\n");
	  }
	  else
	  {
		System.out.printf("    [1] = x%lx  %d\n", (int) printsh.ss, printsh.ssorient);
	  }

	  printvertex = (REAL) s.ss[2 + s.ssorient];
	  if (printvertex == (REAL) null)
		System.out.printf("    Origin[%d] = NULL\n", 2 + s.ssorient);
	  else
		System.out.printf("    Origin[%d] = x%lx  (%.12g, %.12g)\n", 2 + s.ssorient, (int) printvertex, printvertex[0], printvertex[1]);
	  printvertex = (REAL) s.ss[3 - s.ssorient];
	  if (printvertex == (REAL) null)
		System.out.printf("    Dest  [%d] = NULL\n", 3 - s.ssorient);
	  else
		System.out.printf("    Dest  [%d] = x%lx  (%.12g, %.12g)\n", 3 - s.ssorient, (int) printvertex, printvertex[0], printvertex[1]);

	  (printtri).orient = (int)((int)(s.ss[6]) & (int) 3l);
	  (printtri).tri = (REAL ** *)((int)(s.ss[6]) ^ (int)(printtri).orient);
	  if (printtri.tri == m.dummytri)
	  {
		System.out.print("    [6] = Outer space\n");
	  }
	  else
	  {
		System.out.printf("    [6] = x%lx  %d\n", (int) printtri.tri, printtri.orient);
	  }
	  (printtri).orient = (int)((int)(s.ss[7]) & (int) 3l);
	  (printtri).tri = (REAL ** *)((int)(s.ss[7]) ^ (int)(printtri).orient);
	  if (printtri.tri == m.dummytri)
	  {
		System.out.print("    [7] = Outer space\n");
	  }
	  else
	  {
		System.out.printf("    [7] = x%lx  %d\n", (int) printtri.tri, printtri.orient);
	  }

	  printvertex = (REAL) s.ss[4 + s.ssorient];
	  if (printvertex == (REAL) null)
		System.out.printf("    Segment origin[%d] = NULL\n", 4 + s.ssorient);
	  else
		System.out.printf("    Segment origin[%d] = x%lx  (%.12g, %.12g)\n", 4 + s.ssorient, (int) printvertex, printvertex[0], printvertex[1]);
	  printvertex = (REAL) s.ss[5 - s.ssorient];
	  if (printvertex == (REAL) null)
		System.out.printf("    Segment dest  [%d] = NULL\n", 5 - s.ssorient);
	  else
		System.out.printf("    Segment dest  [%d] = x%lx  (%.12g, %.12g)\n", 5 - s.ssorient, (int) printvertex, printvertex[0], printvertex[1]);
	}

	//*                                                                         *
	//*                                                                         *
	//******** Debugging routines end here                               ********

	//******** Memory management routines begin here                     ********
	//*                                                                         *
	//*                                                                         *

	//***************************************************************************
	//                                                                           
	//  poolzero()   Set all of a pool's fields to zero.                         
	//                                                                           
	//  This procedure should never be called on a pool that has any memory      
	//  allocated to it, as that memory would leak.                              
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void poolzero(struct memorypool *pool)
	//#else
	void poolzero(pool)
	memorypool pool;
	//#endif // not ANSI_DECLARATORS

	{
	  pool.firstblock = (int) null;
	  pool.nowblock = (int) null;
	  pool.nextitem = (int) null;
	  pool.deaditemstack = (int) null;
	  pool.pathblock = (int) null;
	  pool.pathitem = (int) null;
	  pool.alignbytes = 0;
	  pool.itembytes = 0;
	  pool.itemsperblock = 0;
	  pool.itemsfirstblock = 0;
	  pool.items = 0;
	  pool.maxitems = 0;
	  pool.unallocateditems = 0;
	  pool.pathitemsleft = 0;
	}

	//***************************************************************************
	//                                                                           
	//  poolrestart()   Deallocate all items in a pool.                          
	//                                                                           
	//  The pool is returned to its starting state, except that no memory is     
	//  freed to the operating system.  Rather, the previously allocated blocks  
	//  are ready to be reused.                                                  
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void poolrestart(struct memorypool pool)
	//#else
	void poolrestart(pool)
	memorypool pool;
	//#endif // not ANSI_DECLARATORS

	{
	  int alignptr;

	  pool.items = 0;
	  pool.maxitems = 0;

	  // Set the currently active block. 
	  pool.nowblock = pool.firstblock;
	  // Find the first item in the pool.  Increment by the size of (VOID *). 
	  alignptr = (int)(pool.nowblock + 1);
	  // Align the item on an `alignbytes'-byte boundary. 
	  pool.nextitem = (int)(alignptr + (int) pool.alignbytes - (alignptr % (int) pool.alignbytes));
	  // There are lots of unallocated items left in this block. 
	  pool.unallocateditems = pool.itemsfirstblock;
	  // The stack of deallocated items is empty. 
	  pool.deaditemstack = (int) null;
	}

	//***************************************************************************
	//                                                                           
	//  poolinit()   Initialize a pool of memory for allocation of items.        
	//                                                                           
	//  This routine initializes the machinery for allocating items.  A `pool'   
	//  is created whose records have size at least `bytecount'.  Items will be  
	//  allocated in `itemcount'-item blocks.  Each item is assumed to be a      
	//  collection of words, and either pointers or floating-point values are    
	//  assumed to be the "primary" word type.  (The "primary" word type is used 
	//  to determine alignment of items.)  If `alignment' isn't zero, all items  
	//  will be `alignment'-byte aligned in memory.  `alignment' must be either  
	//  a multiple or a factor of the primary word size; powers of two are safe. 
	//  `alignment' is normally used to create a few unused bits at the bottom   
	//  of each item's pointer, in which information may be stored.              
	//                                                                           
	//  Don't change this routine unless you understand it.                      
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void poolinit(struct memorypool pool, int bytecount, int itemcount, int firstitemcount, int alignment)
	//#else
	void poolinit(pool, bytecount, itemcount, firstitemcount, alignment)
	memorypool pool;
	int bytecount;
	int itemcount;
	int firstitemcount;
	int alignment;
	//#endif // not ANSI_DECLARATORS

	{
	  // Find the proper alignment, which must be at least as large as:   
	  //   - The parameter `alignment'.                                   
	  //   - sizeof(VOID *), so the stack of dead items can be maintained 
	  //       without unaligned accesses.                                
	  if (alignment > sizeof(int))
	  {
		pool.alignbytes = alignment;
	  }
	  else
	  {
		pool.alignbytes = sizeof(int *);
	  }
	  pool.itembytes = ((bytecount - 1) / pool.alignbytes + 1) pool.alignbytes;
	  pool.itemsperblock = itemcount;
	  if (firstitemcount == 0)
	  {
		pool.itemsfirstblock = itemcount;
	  }
	  else
	  {
		pool.itemsfirstblock = firstitemcount;
	  }

	  // Allocate a block of items.  Space for `itemsfirstblock' items and one  
	  //   pointer (to point to the next block) are allocated, as well as space 
	  //   to ensure alignment of the items.                                    
	  pool.firstblock = (int) trimalloc(pool.itemsfirstblock pool.itembytes + (int) sizeof(int) + pool.alignbytes);
	  // Set the next block pointer to NULL. 
	  *(pool.firstblock) = (int) null;
	  poolrestart(pool);
	}

	//***************************************************************************
	//                                                                           
	//  pooldeinit()   Free to the operating system all memory taken by a pool.  
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void pooldeinit(struct memorypool pool)
	//#else
	void pooldeinit(pool)
	memorypool pool;
	//#endif // not ANSI_DECLARATORS

	{
	  while (pool.firstblock != (int) null)
	  {
		pool.nowblock = (int) *(pool.firstblock);
		trifree((int) pool.firstblock);
		pool.firstblock = pool.nowblock;
	  }
	}

	//***************************************************************************
	//                                                                           
	//  poolalloc()   Allocate space for an item.                                
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	int *poolalloc(struct memorypool pool)
	//#else
	int *poolalloc(pool)
	memorypool pool;
	//#endif // not ANSI_DECLARATORS

	{
	  int newitem;
	  int[] newblock;
	  int alignptr;

	  // First check the linked list of dead items.  If the list is not   
	  //   empty, allocate an item from the list rather than a fresh one. 
	  if (pool.deaditemstack != (int) null)
	  {
		newitem = pool.deaditemstack; // Take first item in list.
		pool.deaditemstack = (int) pool.deaditemstack;
	  }
	  else
	  {
		// Check if there are any free items left in the current block. 
		if (pool.unallocateditems == 0)
		{
		  // Check if another block must be allocated. 
		  if (*(pool.nowblock) == (int) null)
		  {
			// Allocate a new block of items, pointed to by the previous block. 
			newblock = (int) trimalloc(pool.itemsperblock pool.itembytes + (int) sizeof(int) + pool.alignbytes);
			*(pool.nowblock) = (int) newblock;
			// The next block pointer is NULL. 
			*newblock = (int) null;
		  }

		  // Move to the new block. 
		  pool.nowblock = (int) *(pool.nowblock);
		  // Find the first item in the block.    
		  //   Increment by the size of (VOID *). 
		  alignptr = (int)(pool.nowblock + 1);
		  // Align the item on an `alignbytes'-byte boundary. 
		  pool.nextitem = (int)(alignptr + (int) pool.alignbytes - (alignptr % (int) pool.alignbytes));
		  // There are lots of unallocated items left in this block. 
		  pool.unallocateditems = pool.itemsperblock;
		}

		// Allocate a new item. 
		newitem = pool.nextitem;
		// Advance `nextitem' pointer to next free item in block. 
		pool.nextitem = (int)((char) pool.nextitem + pool.itembytes);
		pool.unallocateditems--;
		pool.maxitems++;
	  }
	  pool.items++;
	  return newitem;
	}

	//***************************************************************************
	//                                                                           
	//  pooldealloc()   Deallocate space for an item.                            
	//                                                                           
	//  The deallocated space is stored in a queue for later reuse.              
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void pooldealloc(struct memorypool pool, int *dyingitem)
	//#else
	void pooldealloc(pool, dyingitem)
	memorypool pool;
	int dyingitem;
	//#endif // not ANSI_DECLARATORS

	{
	  // Push freshly killed item onto stack. 
	  *((int) dyingitem) = pool.deaditemstack;
	  pool.deaditemstack = dyingitem;
	  pool.items--;
	}

	//***************************************************************************
	//                                                                           
	//  traversalinit()   Prepare to traverse the entire list of items.          
	//                                                                           
	//  This routine is used in conjunction with traverse().                     
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void traversalinit(struct memorypool pool)
	//#else
	void traversalinit(pool)
	memorypool pool;
	//#endif // not ANSI_DECLARATORS

	{
	  int alignptr;

	  // Begin the traversal in the first block. 
	  pool.pathblock = pool.firstblock;
	  // Find the first item in the block.  Increment by the size of (VOID *). 
	  alignptr = (int)(pool.pathblock + 1);
	  // Align with item on an `alignbytes'-byte boundary. 
	  pool.pathitem = (int)(alignptr + (int) pool.alignbytes - (alignptr % (int) pool.alignbytes));
	  // Set the number of items left in the current block. 
	  pool.pathitemsleft = pool.itemsfirstblock;
	}

	//***************************************************************************
	//                                                                           
	//  traverse()   Find the next item in the list.                             
	//                                                                           
	//  This routine is used in conjunction with traversalinit().  Be forewarned 
	//  that this routine successively returns all items in the list, including  
	//  deallocated ones on the deaditemqueue.  It's up to you to figure out     
	//  which ones are actually dead.  Why?  I don't want to allocate extra      
	//  space just to demarcate dead items.  It can usually be done more         
	//  space-efficiently by a routine that knows something about the structure  
	//  of the item.                                                             
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	int *traverse(struct memorypool pool)
	//#else
	int *traverse(pool)
	memorypool pool;
	//#endif // not ANSI_DECLARATORS

	{
	  int newitem;
	  int alignptr;

	  // Stop upon exhausting the list of items. 
	  if (pool.pathitem == pool.nextitem)
	  {
		return (int) null;
	  }

	  // Check whether any untraversed items remain in the current block. 
	  if (pool.pathitemsleft == 0)
	  {
		// Find the next block. 
		pool.pathblock = (int) *(pool.pathblock);
		// Find the first item in the block.  Increment by the size of (VOID *). 
		alignptr = (int)(pool.pathblock + 1);
		// Align with item on an `alignbytes'-byte boundary. 
		pool.pathitem = (int)(alignptr + (int) pool.alignbytes - (alignptr % (int) pool.alignbytes));
		// Set the number of items left in the current block. 
		pool.pathitemsleft = pool.itemsperblock;
	  }

	  newitem = pool.pathitem;
	  // Find the next item in the block. 
	  pool.pathitem = (int)((char) pool.pathitem + pool.itembytes);
	  pool.pathitemsleft--;
	  return newitem;
	}

	//***************************************************************************
	//                                                                           
	//  dummyinit()   Initialize the triangle that fills "outer space" and the   
	//                omnipresent subsegment.                                    
	//                                                                           
	//  The triangle that fills "outer space," called `dummytri', is pointed to  
	//  by every triangle and subsegment on a boundary (be it outer or inner) of 
	//  the triangulation.  Also, `dummytri' points to one of the triangles on   
	//  the convex hull (until the holes and concavities are carved), making it  
	//  possible to find a starting triangle for point location.                 
	//                                                                           
	//  The omnipresent subsegment, `dummysub', is pointed to by every triangle  
	//  or subsegment that doesn't have a full complement of real subsegments    
	//  to point to.                                                             
	//                                                                           
	//  `dummytri' and `dummysub' are generally required to fulfill only a few   
	//  invariants:  their vertices must remain NULL and `dummytri' must always  
	//  be bonded (at offset zero) to some triangle on the convex hull of the    
	//  mesh, via a boundary edge.  Otherwise, the connections of `dummytri' and 
	//  `dummysub' may change willy-nilly.  This makes it possible to avoid      
	//  writing a good deal of special-case code (in the edge flip, for example) 
	//  for dealing with the boundary of the mesh, places where no subsegment is 
	//  present, and so forth.  Other entities are frequently bonded to          
	//  `dummytri' and `dummysub' as if they were real mesh entities, with no    
	//  harm done.                                                               
	//                                                                           
	//***************************************************************************

	//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
	//#if ANSI_DECLARATORS
	void dummyinit(struct mesh m, struct behavior b, int trianglebytes, int subsegbytes)
	//#else
	void dummyinit(m, b, trianglebytes, subsegbytes)
	mesh m;
	behavior b;
	int trianglebytes;
	int subsegbytes;
	//#endif // not ANSI_DECLARATORS

	{
	  int alignptr;

	  // Set up `dummytri', the `triangle' that occupies "outer space." 
	  m.dummytribase = (REAL ** *) trimalloc(trianglebytes + m.triangles.alignbytes);
	  // Align `dummytri' on a `triangles.alignbytes'-byte boundary. 
	  alignptr = (int) m.dummytribase;
	  m.dummytri = (REAL ** *)(alignptr + (int) m.triangles.alignbytes - (alignptr % (int) m.triangles.alignbytes));
	  // Initialize the three adjoining triangles to be "outer space."  These  
	  //   will eventually be changed by various bonding operations, but their 
	  //   values don't really matter, as long as they can legally be          
	  //   dereferenced.                                                       
	  m.dummytri[0] = (REAL) m.dummytri;
	  m.dummytri[1] = (REAL) m.dummytri;
	  m.dummytri[2] = (REAL) m.dummytri;
	  // Three NULL vertices. 
	  m.dummytri[3] = (REAL) null;
	  m.dummytri[4] = (REAL) null;
	  m.dummytri[5] = (REAL) null;

	  if (b.usesegments != 0)
	  {
		// Set up `dummysub', the omnipresent subsegment pointed to by any 
		//   triangle side or subsegment end that isn't attached to a real 
		//   subsegment.                                                   
		m.dummysubbase = (REAL ** *) trimalloc(subsegbytes + m.subsegs.alignbytes);
		// Align `dummysub' on a `subsegs.alignbytes'-byte boundary. 
		alignptr = (int) m.dummysubbase;
		m.dummysub = (REAL ** *)(alignptr + (int) m.subsegs.alignbytes - (alignptr % (int) m.subsegs.alignbytes));
		// Initialize the two adjoining subsegments to be the omnipresent      
		//   subsegment.  These will eventually be changed by various bonding  
		//   operations, but their values don't really matter, as long as they 
		//   can legally be dereferenced.                                      
		m.dummysub[0] = (REAL) m.dummysub;
		m.dummysub[1] = (REAL) m.dummysub;
		// Four NULL vertices. 
		m.dummysub[2] = (REAL) null;
		m.dummysub[3] = (REAL) null;
		m.dummysub[4] = (REAL) null;
		m.dummysub[5] = (REAL) null;
		// Initialize the two adjoining triangles to be "outer space." 
		m.dummysub[6] = (REAL) m.dummytri;
		m.dummysub[7] = (REAL) m.dummytri;
		// Set the boundary marker to zero. 
}
//***************************************************************************
//                                                                           
//      888888888        ,o,                          / 888                  
//         888    88o88o  "    o8888o  88o8888o o88888o 888  o88888o         */
///*         888    888    888       88b 888  888 888 888 888 d888  88b        
//         888    888    888  o88^o888 888  888 "88888" 888 8888oo888        
//         888    888    888 C888  888 888  888  /      888 q888             
//         888    888    888  "88o^888 888  888 Cb      888  "88oooo"        */
///*                                              "8oo8D                       */
///*                                                                           
//  A Two-Dimensional Quality Mesh Generator and Delaunay Triangulator.      
//  (triangle.c)                                                             
//                                                                           
//  Version 1.6                                                              
//  July 28, 2005                                                            
//                                                                           
//  Copyright 1993, 1995, 1997, 1998, 2002, 2005                             
//  Jonathan Richard Shewchuk                                                
//  2360 Woolsey #H                                                          
//  Berkeley, California  94705-1927                                         
//  jrs@cs.berkeley.edu                                                      
//                                                                           
//  This program may be freely redistributed under the condition that the    
//    copyright notices (including this entire header and the copyright      
//    notice printed when the `-h' switch is selected) are not removed, and  
//    no compensation is received.  Private, research, and institutional     
//    use is free.  You may distribute modified versions of this code UNDER  
//    THE CONDITION THAT THIS CODE AND ANY MODIFICATIONS MADE TO IT IN THE   
//    SAME FILE REMAIN UNDER COPYRIGHT OF THE ORIGINAL AUTHOR, BOTH SOURCE   
//    AND OBJECT CODE ARE MADE FREELY AVAILABLE WITHOUT CHARGE, AND CLEAR    
//    NOTICE IS GIVEN OF THE MODIFICATIONS.  Distribution of this code as    
//    part of a commercial system is permissible ONLY BY DIRECT ARRANGEMENT  
//    WITH THE AUTHOR.  (If you are not directly supplying this code to a    
//    customer, and you are instead telling them how they can obtain it for  
//    free, then you are not required to make any arrangement with me.)      
//                                                                           
//  Hypertext instructions for Triangle are available on the Web at          
//                                                                           
//      http://www.cs.cmu.edu/~quake/triangle.html                           
//                                                                           
//  Disclaimer:  Neither I nor Carnegie Mellon warrant this code in any way  
//    whatsoever.  This code is provided "as-is".  Use at your own risk.     
//                                                                           
//  Some of the references listed below are marked with an asterisk.  [*]    
//    These references are available for downloading from the Web page       
//                                                                           
//      http://www.cs.cmu.edu/~quake/triangle.research.html                  
//                                                                           
//  Three papers discussing aspects of Triangle are available.  A short      
//    overview appears in "Triangle:  Engineering a 2D Quality Mesh          */
///*    Generator and Delaunay Triangulator," in Applied Computational         */
///*    Geometry:  Towards Geometric Engineering, Ming C. Lin and Dinesh       
//    Manocha, editors, Lecture Notes in Computer Science volume 1148,       
//    pages 203-222, Springer-Verlag, Berlin, May 1996 (from the First ACM   
//    Workshop on Applied Computational Geometry).  [*]                      
//                                                                           
//    The algorithms are discussed in the greatest detail in "Delaunay       */
///*    Refinement Algorithms for Triangular Mesh Generation," Computational   */
///*    Geometry:  Theory and Applications 22(1-3):21-74, May 2002.  [*]       
//                                                                           
//    More detail about the data structures may be found in my dissertation: 
//    "Delaunay Refinement Mesh Generation," Ph.D. thesis, Technical Report  
//    CMU-CS-97-137, School of Computer Science, Carnegie Mellon University, 
//    Pittsburgh, Pennsylvania, 18 May 1997.  [*]                            
//                                                                           
//  Triangle was created as part of the Quake Project in the School of       
//    Computer Science at Carnegie Mellon University.  For further           
//    information, see Hesheng Bao, Jacobo Bielak, Omar Ghattas, Loukas F.   
//    Kallivokas, David R. O'Hallaron, Jonathan R. Shewchuk, and Jifeng Xu,  
//    "Large-scale Simulation of Elastic Wave Propagation in Heterogeneous   */
///*    Media on Parallel Computers," Computer Methods in Applied Mechanics    */
///*    and Engineering 152(1-2):85-102, 22 January 1998.                      
//                                                                           
//  Triangle's Delaunay refinement algorithm for quality mesh generation is  
//    a hybrid of one due to Jim Ruppert, "A Delaunay Refinement Algorithm   */
///*    for Quality 2-Dimensional Mesh Generation," Journal of Algorithms      */
///*    18(3):548-585, May 1995 [*], and one due to L. Paul Chew, "Guaranteed- */
///*    Quality Mesh Generation for Curved Surfaces," Proceedings of the Ninth */
///*    Annual Symposium on Computational Geometry (San Diego, California),    
//    pages 274-280, Association for Computing Machinery, May 1993,          
//    http://portal.acm.org/citation.cfm?id=161150 .                         
//                                                                           
//  The Delaunay refinement algorithm has been modified so that it meshes    
//    domains with small input angles well, as described in Gary L. Miller,  
//    Steven E. Pav, and Noel J. Walkington, "When and Why Ruppert's         */
///*    Algorithm Works," Twelfth International Meshing Roundtable, pages      */
///*    91-102, Sandia National Laboratories, September 2003.  [*]             
//                                                                           
//  My implementation of the divide-and-conquer and incremental Delaunay     
//    triangulation algorithms follows closely the presentation of Guibas    
//    and Stolfi, even though I use a triangle-based data structure instead  
//    of their quad-edge data structure.  (In fact, I originally implemented 
//    Triangle using the quad-edge data structure, but the switch to a       
//    triangle-based data structure sped Triangle by a factor of two.)  The  
//    mesh manipulation primitives and the two aforementioned Delaunay       
//    triangulation algorithms are described by Leonidas J. Guibas and Jorge 
//    Stolfi, "Primitives for the Manipulation of General Subdivisions and   */
///*    the Computation of Voronoi Diagrams," ACM Transactions on Graphics     */
///*    4(2):74-123, April 1985, http://portal.acm.org/citation.cfm?id=282923 .
//                                                                           
//  Their O(n log n) divide-and-conquer algorithm is adapted from Der-Tsai   
//    Lee and Bruce J. Schachter, "Two Algorithms for Constructing the       */
///*    Delaunay Triangulation," International Journal of Computer and         */
///*    Information Science 9(3):219-242, 1980.  Triangle's improvement of the 
//    divide-and-conquer algorithm by alternating between vertical and       
//    horizontal cuts was introduced by Rex A. Dwyer, "A Faster Divide-and-  */
///*    Conquer Algorithm for Constructing Delaunay Triangulations,"           */
///*    Algorithmica 2(2):137-151, 1987.                                       
//                                                                           
//  The incremental insertion algorithm was first proposed by C. L. Lawson,  
//    "Software for C1 Surface Interpolation," in Mathematical Software III, 
//    John R. Rice, editor, Academic Press, New York, pp. 161-194, 1977.     
//    For point location, I use the algorithm of Ernst P. Mucke, Isaac       
//    Saias, and Binhai Zhu, "Fast Randomized Point Location Without         */
///*    Preprocessing in Two- and Three-Dimensional Delaunay Triangulations,"  */
///*    Proceedings of the Twelfth Annual Symposium on Computational Geometry, 
//    ACM, May 1996.  [*]  If I were to randomize the order of vertex        
//    insertion (I currently don't bother), their result combined with the   
//    result of Kenneth L. Clarkson and Peter W. Shor, "Applications of      */
///*    Random Sampling in Computational Geometry II," Discrete &              */
///*    Computational Geometry 4(1):387-421, 1989, would yield an expected     
//    O(n^{4/3}) bound on running time.                                      
//                                                                           
//  The O(n log n) sweepline Delaunay triangulation algorithm is taken from  
//    Steven Fortune, "A Sweepline Algorithm for Voronoi Diagrams",          
//    Algorithmica 2(2):153-174, 1987.  A random sample of edges on the      
//    boundary of the triangulation are maintained in a splay tree for the   
//    purpose of point location.  Splay trees are described by Daniel        
//    Dominic Sleator and Robert Endre Tarjan, "Self-Adjusting Binary Search */
///*    Trees," Journal of the ACM 32(3):652-686, July 1985,                   */
///*    http://portal.acm.org/citation.cfm?id=3835 .                           
//                                                                           
//  The algorithms for exact computation of the signs of determinants are    
//    described in Jonathan Richard Shewchuk, "Adaptive Precision Floating-  */
///*    Point Arithmetic and Fast Robust Geometric Predicates," Discrete &     */
///*    Computational Geometry 18(3):305-363, October 1997.  (Also available   
//    as Technical Report CMU-CS-96-140, School of Computer Science,         
//    Carnegie Mellon University, Pittsburgh, Pennsylvania, May 1996.)  [*]  
//    An abbreviated version appears as Jonathan Richard Shewchuk, "Robust   */
///*    Adaptive Floating-Point Geometric Predicates," Proceedings of the      */
///*    Twelfth Annual Symposium on Computational Geometry, ACM, May 1996. [*] 
//    Many of the ideas for my exact arithmetic routines originate with      
//    Douglas M. Priest, "Algorithms for Arbitrary Precision Floating Point  */
///*    Arithmetic," Tenth Symposium on Computer Arithmetic, pp. 132-143, IEEE */
///*    Computer Society Press, 1991.  [*]  Many of the ideas for the correct  
//    evaluation of the signs of determinants are taken from Steven Fortune  
//    and Christopher J. Van Wyk, "Efficient Exact Arithmetic for Computa-   */
///*    tional Geometry," Proceedings of the Ninth Annual Symposium on         */
///*    Computational Geometry, ACM, pp. 163-172, May 1993, and from Steven    
//    Fortune, "Numerical Stability of Algorithms for 2D Delaunay Triangu-   */
///*    lations," International Journal of Computational Geometry & Applica-   */
///*    tions 5(1-2):193-213, March-June 1995.                                 
//                                                                           
//  The method of inserting new vertices off-center (not precisely at the    
//    circumcenter of every poor-quality triangle) is from Alper Ungor,      
//    "Off-centers:  A New Type of Steiner Points for Computing Size-Optimal */
///*    Quality-Guaranteed Delaunay Triangulations," Proceedings of LATIN      */
///*    2004 (Buenos Aires, Argentina), April 2004.                            
//                                                                           
//  For definitions of and results involving Delaunay triangulations,        
//    constrained and conforming versions thereof, and other aspects of      
//    triangular mesh generation, see the excellent survey by Marshall Bern  
//    and David Eppstein, "Mesh Generation and Optimal Triangulation," in    
//    Computing and Euclidean Geometry, Ding-Zhu Du and Frank Hwang,         
//    editors, World Scientific, Singapore, pp. 23-90, 1992.  [*]            
//                                                                           
//  The time for incrementally adding PSLG (planar straight line graph)      
//    segments to create a constrained Delaunay triangulation is probably    
//    O(t^2) per segment in the worst case and O(t) per segment in the       
//    common case, where t is the number of triangles that intersect the     
//    segment before it is inserted.  This doesn't count point location,     
//    which can be much more expensive.  I could improve this to O(d log d)  
//    time, but d is usually quite small, so it's not worth the bother.      
//    (This note does not apply when the -s switch is used, invoking a       
//    different method is used to insert segments.)                          
//                                                                           
//  The time for deleting a vertex from a Delaunay triangulation is O(d^2)   
//    in the worst case and O(d) in the common case, where d is the degree   
//    of the vertex being deleted.  I could improve this to O(d log d) time, 
//    but d is usually quite small, so it's not worth the bother.            
//                                                                           
//  Ruppert's Delaunay refinement algorithm typically generates triangles    
//    at a linear rate (constant time per triangle) after the initial        
//    triangulation is formed.  There may be pathological cases where        
//    quadratic time is required, but these never arise in practice.         
//                                                                           
//  The geometric predicates (circumcenter calculations, segment             
//    intersection formulae, etc.) appear in my "Lecture Notes on Geometric  */
///*    Robustness" at http://www.cs.berkeley.edu/~jrs/mesh .                  */
///*                                                                           
//  If you make any improvements to this code, please please please let me   
//    know, so that I may obtain the improvements.  Even if you don't change 
//    the code, I'd still love to hear what it's being used for.             
//                                                                           
//***************************************************************************

// For single precision (which will save some memory and reduce paging),     
//   define the symbol SINGLE by using the -DSINGLE compiler switch or by    
//   writing "#define SINGLE" below.                                         
//                                                                           
// For double precision (which will allow you to refine meshes to a smaller  
//   edge length), leave SINGLE undefined.                                   
//                                                                           
// Double precision uses more memory, but improves the resolution of the     
//   meshes you can generate with Triangle.  It also reduces the likelihood  
//   of a floating exception due to overflow.  Finally, it is much faster    
//   than single precision on 64-bit architectures like the DEC Alpha.  I    
//   recommend double precision unless you want to generate a mesh for which 
//   you do not have enough memory.                                          

// #define SINGLE 

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if SINGLE
//C++ TO JAVA CONVERTER TODO TASK: Alternate #define macros with the same name cannot be converted to Java:
//#define REAL float
//#else
//C++ TO JAVA CONVERTER TODO TASK: Alternate #define macros with the same name cannot be converted to Java:
//#define REAL double
//#endif // not SINGLE

// If yours is not a Unix system, define the NO_TIMER compiler switch to     
//   remove the Unix-specific timing code.                                   

// #define NO_TIMER 

// To insert lots of self-checks for internal errors, define the SELF_CHECK  
//   symbol.  This will slow down the program significantly.  It is best to  
//   define the symbol using the -DSELF_CHECK compiler switch, but you could 
//   write "#define SELF_CHECK" below.  If you are modifying this code, I    
//   recommend you turn self-checks on until your work is debugged.          

// #define SELF_CHECK 

// To compile Triangle as a callable object library (triangle.o), define the 
//   TRILIBRARY symbol.  Read the file triangle.h for details on how to call 
//   the procedure triangulate() that results.                               

// #define TRILIBRARY 

// It is possible to generate a smaller version of Triangle using one or     
//   both of the following symbols.  Define the REDUCED symbol to eliminate  
//   all features that are primarily of research interest; specifically, the 
//   -i, -F, -s, and -C switches.  Define the CDT_ONLY symbol to eliminate   
//   all meshing algorithms above and beyond constrained Delaunay            
//   triangulation; specifically, the -r, -q, -a, -u, -D, -S, and -s         
//   switches.  These reductions are most likely to be useful when           
//   generating an object library (triangle.o) by defining the TRILIBRARY    
//   symbol.                                                                 

// #define REDUCED 
// #define CDT_ONLY 

// On some machines, my exact arithmetic routines might be defeated by the   
//   use of internal extended precision floating-point registers.  The best  
//   way to solve this problem is to set the floating-point registers to use 
//   single or double precision internally.  On 80x86 processors, this may   
//   be accomplished by setting the CPU86 symbol for the Microsoft C         
//   compiler, or the LINUX symbol for the gcc compiler running on Linux.    
//                                                                           
// An inferior solution is to declare certain values as `volatile', thus     
//   forcing them to be stored to memory and rounded off.  Unfortunately,    
//   this solution might slow Triangle down quite a bit.  To use volatile    
//   values, write "#define INEXACT volatile" below.  Normally, however,     
//   INEXACT should be defined to be nothing.  ("#define INEXACT".)          
//                                                                           
// For more discussion, see http://www.cs.cmu.edu/~quake/robust.pc.html .    
//   For yet more discussion, see Section 5 of my paper, "Adaptive Precision */
///*   Floating-Point Arithmetic and Fast Robust Geometric Predicates" (also   */
///*   available as Section 6.6 of my dissertation).                           

// #define CPU86 
// #define LINUX 

//#define INEXACT
// #define INEXACT volatile 

// Maximum number of characters in a file name (including the null).         

//#define FILENAMESIZE 2048

// Maximum number of characters in a line read from a file (including the    
//   null).                                                                  

//#define INPUTLINESIZE 1024

// For efficiency, a variety of data structures are allocated in bulk.  The  
//   following constants determine how many of each structure is allocated   
//   at once.                                                                

//#define TRIPERBLOCK 4092
//#define SUBSEGPERBLOCK 508
//#define VERTEXPERBLOCK 4092
//#define VIRUSPERBLOCK 1020
// Number of encroached subsegments allocated at once. 
//#define BADSUBSEGPERBLOCK 252
// Number of skinny triangles allocated at once. 
//#define BADTRIPERBLOCK 4092
// Number of flipped triangles allocated at once. 
//#define FLIPSTACKERPERBLOCK 252
// Number of splay tree nodes allocated at once. 
//#define SPLAYNODEPERBLOCK 508

// The vertex types.   A DEADVERTEX has been deleted entirely.  An           
//   UNDEADVERTEX is not part of the mesh, but is written to the output      
//   .node file and affects the node indexing in the other output files.     

//#define INPUTVERTEX 0
//#define SEGMENTVERTEX 1
//#define FREEVERTEX 2
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define DEADVERTEX -32768
//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define UNDEADVERTEX -32767

// The next line is used to outsmart some very stupid compilers.  If your    
//   compiler is smarter, feel free to replace the "int" with "void".        
//   Not that it matters.                                                    

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define VOID int

// Two constants for algorithms based on random sampling.  Both constants    
//   have been chosen empirically to optimize their respective algorithms.   

// Used for the point location scheme of Mucke, Saias, and Zhu, to decide    
//   how large a random sample of triangles to inspect.                      

//#define SAMPLEFACTOR 11

// Used in Fortune's sweepline Delaunay algorithm to determine what fraction 
//   of boundary edges should be maintained in the splay tree for point      
//   location on the front.                                                  

//#define SAMPLERATE 10

// A number that speaks for itself, every kissable digit.                    

//#define PI 3.141592653589793238462643383279502884197169399375105820974944592308

// Another fave.                                                             

//#define SQUAREROOTTWO 1.4142135623730950488016887242096980785696718753769480732

// And here's one for those of you who are intimidated by math.              

//#define ONETHIRD 0.333333333333333333333333333333333333333333333333333333333333

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! NO_TIMER
//#endif // not NO_TIMER
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if CPU86
//#endif // CPU86
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if LINUX
//#endif // LINUX
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//#endif // TRILIBRARY

// Labels that signify the result of point location.  The result of a        
//   search indicates that the point falls in the interior of a triangle, on 
//   an edge, on a vertex, or outside the mesh.                              

public enum locateresult
{
	INTRIANGLE,
	ONEDGE,
	ONVERTEX,
	OUTSIDE
}

// Labels that signify the result of vertex insertion.  The result indicates 
//   that the vertex was inserted with complete success, was inserted but    
//   encroaches upon a subsegment, was not inserted because it lies on a     
//   segment, or was not inserted because another vertex occupies the same   
//   location.                                                               

public enum insertvertexresult
{
	SUCCESSFULVERTEX,
	ENCROACHINGVERTEX,
	VIOLATINGVERTEX,
						 DUPLICATEVERTEX
						 }

// Labels that signify the result of direction finding.  The result          
//   indicates that a segment connecting the two query points falls within   
//   the direction triangle, along the left edge of the direction triangle,  
//   or along the right edge of the direction triangle.                      

public enum finddirectionresult
{
	WITHIN,
	LEFTCOLLINEAR,
	RIGHTCOLLINEAR
}

//***************************************************************************
//                                                                           
//  The basic mesh data structures                                           
//                                                                           
//  There are three:  vertices, triangles, and subsegments (abbreviated      
//  `subseg').  These three data structures, linked by pointers, comprise    
//  the mesh.  A vertex simply represents a mesh vertex and its properties.  
//  A triangle is a triangle.  A subsegment is a special data structure used 
//  to represent an impenetrable edge of the mesh (perhaps on the outer      
//  boundary, on the boundary of a hole, or part of an internal boundary     
//  separating two triangulated regions).  Subsegments represent boundaries, 
//  defined by the user, that triangles may not lie across.                  
//                                                                           
//  A triangle consists of a list of three vertices, a list of three         
//  adjoining triangles, a list of three adjoining subsegments (when         
//  segments exist), an arbitrary number of optional user-defined            
//  floating-point attributes, and an optional area constraint.  The latter  
//  is an upper bound on the permissible area of each triangle in a region,  
//  used for mesh refinement.                                                
//                                                                           
//  For a triangle on a boundary of the mesh, some or all of the neighboring 
//  triangles may not be present.  For a triangle in the interior of the     
//  mesh, often no neighboring subsegments are present.  Such absent         
//  triangles and subsegments are never represented by NULL pointers; they   
//  are represented by two special records:  `dummytri', the triangle that   
//  fills "outer space", and `dummysub', the omnipresent subsegment.         
//  `dummytri' and `dummysub' are used for several reasons; for instance,    
//  they can be dereferenced and their contents examined without violating   
//  protected memory.                                                        
//                                                                           
//  However, it is important to understand that a triangle includes other    
//  information as well.  The pointers to adjoining vertices, triangles, and 
//  subsegments are ordered in a way that indicates their geometric relation 
//  to each other.  Furthermore, each of these pointers contains orientation 
//  information.  Each pointer to an adjoining triangle indicates which face 
//  of that triangle is contacted.  Similarly, each pointer to an adjoining  
//  subsegment indicates which side of that subsegment is contacted, and how 
//  the subsegment is oriented relative to the triangle.                     
//                                                                           
//  The data structure representing a subsegment may be thought to be        
//  abutting the edge of one or two triangle data structures:  either        
//  sandwiched between two triangles, or resting against one triangle on an  
//  exterior boundary or hole boundary.                                      
//                                                                           
//  A subsegment consists of a list of four vertices--the vertices of the    
//  subsegment, and the vertices of the segment it is a part of--a list of   
//  two adjoining subsegments, and a list of two adjoining triangles.  One   
//  of the two adjoining triangles may not be present (though there should   
//  always be one), and neighboring subsegments might not be present.        
//  Subsegments also store a user-defined integer "boundary marker".         
//  Typically, this integer is used to indicate what boundary conditions are 
//  to be applied at that location in a finite element simulation.           
//                                                                           
//  Like triangles, subsegments maintain information about the relative      
//  orientation of neighboring objects.                                      
//                                                                           
//  Vertices are relatively simple.  A vertex is a list of floating-point    
//  numbers, starting with the x, and y coordinates, followed by an          
//  arbitrary number of optional user-defined floating-point attributes,     
//  followed by an integer boundary marker.  During the segment insertion    
//  phase, there is also a pointer from each vertex to a triangle that may   
//  contain it.  Each pointer is not always correct, but when one is, it     
//  speeds up segment insertion.  These pointers are assigned values once    
//  at the beginning of the segment insertion phase, and are not used or     
//  updated except during this phase.  Edge flipping during segment          
//  insertion will render some of them incorrect.  Hence, don't rely upon    
//  them for anything.                                                       
//                                                                           
//  Other than the exception mentioned above, vertices have no information   
//  about what triangles, subfacets, or subsegments they are linked to.      
//                                                                           
//***************************************************************************

//***************************************************************************
//                                                                           
//  Handles                                                                  
//                                                                           
//  The oriented triangle (`otri') and oriented subsegment (`osub') data     
//  structures defined below do not themselves store any part of the mesh.   
//  The mesh itself is made of `triangle's, `subseg's, and `vertex's.        
//                                                                           
//  Oriented triangles and oriented subsegments will usually be referred to  
//  as "handles."  A handle is essentially a pointer into the mesh; it       
//  allows you to "hold" one particular part of the mesh.  Handles are used  
//  to specify the regions in which one is traversing and modifying the mesh.
//  A single `triangle' may be held by many handles, or none at all.  (The   
//  latter case is not a memory leak, because the triangle is still          
//  connected to other triangles in the mesh.)                               
//                                                                           
//  An `otri' is a handle that holds a triangle.  It holds a specific edge   
//  of the triangle.  An `osub' is a handle that holds a subsegment.  It     
//  holds either the left or right side of the subsegment.                   
//                                                                           
//  Navigation about the mesh is accomplished through a set of mesh          
//  manipulation primitives, further below.  Many of these primitives take   
//  a handle and produce a new handle that holds the mesh near the first     
//  handle.  Other primitives take two handles and glue the corresponding    
//  parts of the mesh together.  The orientation of the handles is           
//  important.  For instance, when two triangles are glued together by the   
//  bond() primitive, they are glued at the edges on which the handles lie.  
//                                                                           
//  Because vertices have no information about which triangles they are      
//  attached to, I commonly represent a vertex by use of a handle whose      
//  origin is the vertex.  A single handle can simultaneously represent a    
//  triangle, an edge, and a vertex.                                         
//                                                                           
//***************************************************************************

// The triangle data structure.  Each triangle contains three pointers to    
//   adjoining triangles, plus three pointers to vertices, plus three        
//   pointers to subsegments (declared below; these pointers are usually     
//   `dummysub').  It may or may not also contain user-defined attributes    
//   and/or a floating-point "area constraint."  It may also contain extra   
//   pointers for nodes, when the user asks for high-order elements.         
//   Because the size and structure of a `triangle' is not decided until     
//   runtime, I haven't simply declared the type `triangle' as a struct.     

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

// An oriented triangle:  includes a pointer to a triangle and orientation.  
//   The orientation denotes an edge of the triangle.  Hence, there are      
//   three possible orientations.  By convention, each edge always points    
//   counterclockwise about the corresponding triangle.                      

public class otri
{
  public REAL[][][] tri;
  public int orient; // Ranges from 0 to 2.
}

// The subsegment data structure.  Each subsegment contains two pointers to  
//   adjoining subsegments, plus four pointers to vertices, plus two         
//   pointers to adjoining triangles, plus one boundary marker, plus one     
//   segment number.                                                         

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

// An oriented subsegment:  includes a pointer to a subsegment and an        
//   orientation.  The orientation denotes a side of the edge.  Hence, there 
//   are two possible orientations.  By convention, the edge is always       
//   directed so that the "side" denoted is the right side of the edge.      

public class osub
{
  public REAL[][][] ss;
  public int ssorient; // Ranges from 0 to 1.
}

// The vertex data structure.  Each vertex is actually an array of REALs.    
//   The number of REALs is unknown until runtime.  An integer boundary      
//   marker, and sometimes a pointer to a triangle, is appended after the    
//   REALs.                                                                  

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

// A queue used to store encroached subsegments.  Each subsegment's vertices 
//   are stored so that we can check whether a subsegment is still the same. 

public class badsubseg
{
  public REAL[][] encsubseg; // An encroached subsegment.
  public REAL subsegorg; // Its two vertices.
  public REAL subsegdest;
}

// A queue used to store bad triangles.  The key is the square of the cosine 
//   of the smallest angle of the triangle.  Each triangle's vertices are    
//   stored so that one can check whether a triangle is still the same.      

public class badtriang
{
  public REAL[][] poortri; // A skinny or too-large triangle.
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  public REAL key; // cos^2 of smallest (apical) angle.
  public REAL triangorg; // Its three vertices.
  public REAL triangdest;
  public REAL triangapex;
  public badtriang nexttriang; // Pointer to next bad triangle.
}

// A stack of triangles flipped during the most recent vertex insertion.     
//   The stack is used to undo the vertex insertion if the vertex encroaches 
//   upon a subsegment.                                                      

public class flipstacker
{
  public REAL[][] flippedtri; // A recently flipped triangle.
  public flipstacker prevflip; // Previous flip in the stack.
}

// A node in a heap used to store events for the sweepline Delaunay          
//   algorithm.  Nodes do not point directly to their parents or children in 
//   the heap.  Instead, each node knows its position in the heap, and can   
//   look up its parent and children in a separate array.  The `eventptr'    
//   points either to a `vertex' or to a triangle (in encoded format, so     
//   that an orientation is included).  In the latter case, the origin of    
//   the oriented triangle is the apex of a "circle event" of the sweepline  
//   algorithm.  To distinguish site events from circle events, all circle   
//   events are given an invalid (smaller than `xmin') x-coordinate `xkey'.  

public class event
{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  public REAL xkey; // Coordinates of the event.
  public REAL ykey;
  public int eventptr; // Can be a vertex or the location of a circle event.
  public int heapposition; // Marks this event's position in the heap.
}

// A node in the splay tree.  Each node holds an oriented ghost triangle     
//   that represents a boundary edge of the growing triangulation.  When a   
//   circle event covers two boundary edges with a triangle, so that they    
//   are no longer boundary edges, those edges are not immediately deleted   
//   from the tree; rather, they are lazily deleted when they are next       
//   encountered.  (Since only a random sample of boundary edges are kept    
//   in the tree, lazy deletion is faster.)  `keydest' is used to verify     
//   that a triangle is still the same as when it entered the splay tree; if 
//   it has been rotated (due to a circle event), it no longer represents a  
//   boundary edge and should be deleted.                                    

public class splaynode
{
  public otri keyedge = new otri(); // Lprev of an edge on the front.
  public REAL keydest; // Used to verify that splay node is still live.
  public splaynode lchild; // Children in splay tree.
  public splaynode rchild;
}

// A type used to allocate memory.  firstblock is the first block of items.  
//   nowblock is the block from which items are currently being allocated.   
//   nextitem points to the next slab of free memory for an item.            
//   deaditemstack is the head of a linked list (stack) of deallocated items 
//   that can be recycled.  unallocateditems is the number of items that     
//   remain to be allocated from nowblock.                                   
//                                                                           
// Traversal is the process of walking through the entire list of items, and 
//   is separate from allocation.  Note that a traversal will visit items on 
//   the "deaditemstack" stack as well as live items.  pathblock points to   
//   the block currently being traversed.  pathitem points to the next item  
//   to be traversed.  pathitemsleft is the number of items that remain to   
//   be traversed in pathblock.                                              
//                                                                           
// alignbytes determines how new records should be aligned in memory.        
//   itembytes is the length of a record in bytes (after rounding up).       
//   itemsperblock is the number of items allocated at once in a single      
//   block.  itemsfirstblock is the number of items in the first block,      
//   which can vary from the others.  items is the number of currently       
//   allocated items.  maxitems is the maximum number of items that have     
//   been allocated at once; it is the current number of items plus the      
//   number of records kept on deaditemstack.                                

public class memorypool
{
  public int[] firstblock;
  public int[] nowblock;
  public int nextitem;
  public int deaditemstack;
  public int[] pathblock;
  public int pathitem;
  public int alignbytes;
  public int itembytes;
  public int itemsperblock;
  public int itemsfirstblock;
  public int items;
  public int maxitems;
  public int unallocateditems;
  public int pathitemsleft;
}


// Mesh data structure.  Triangle operates on only one mesh, but the mesh    
//   structure is used (instead of global variables) to allow reentrancy.    

public class mesh
{

// Variables used to allocate memory for triangles, subsegments, vertices,   
//   viri (triangles being eaten), encroached segments, bad (skinny or too   
//   large) triangles, and splay tree nodes.                                 

  public memorypool triangles = new memorypool();
  public memorypool subsegs = new memorypool();
  public memorypool vertices = new memorypool();
  public memorypool viri = new memorypool();
  public memorypool badsubsegs = new memorypool();
  public memorypool badtriangles = new memorypool();
  public memorypool flipstackers = new memorypool();
  public memorypool splaynodes = new memorypool();

// Variables that maintain the bad triangle queues.  The queues are          
//   ordered from 4095 (highest priority) to 0 (lowest priority).            

  public badtriang[] queuefront = new badtriang[4096];
  public badtriang[] queuetail = new badtriang[4096];
  public int[] nextnonemptyq = new int[4096];
  public int firstnonemptyq;

// Variable that maintains the stack of recently flipped triangles.          

  public flipstacker lastflip;

// Other variables. 

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  public REAL xmin; // x and y bounds.
  public REAL xmax;
  public REAL ymin;
  public REAL ymax;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  public REAL xminextreme; // Nonexistent x value used as a flag in sweepline.
  public int invertices; // Number of input vertices.
  public int inelements; // Number of input triangles.
  public int insegments; // Number of input segments.
  public int holes; // Number of input holes.
  public int regions; // Number of input regions.
  public int undeads; // Number of input vertices that don't appear in the mesh.
  public int edges; // Number of output edges.
  public int mesh_dim; // Dimension (ought to be 2).
  public int nextras; // Number of attributes per vertex.
  public int eextras; // Number of attributes per triangle.
  public int hullsize; // Number of edges in convex hull.
  public int steinerleft; // Number of Steiner points not yet used.
  public int vertexmarkindex; // Index to find boundary marker of a vertex.
  public int vertex2triindex; // Index to find a triangle adjacent to a vertex.
  public int highorderindex; // Index to find extra nodes for high-order elements.
  public int elemattribindex; // Index to find attributes of a triangle.
  public int areaboundindex; // Index to find area bound of a triangle.
  public int checksegments; // Are there segments in the triangulation yet?
  public int checkquality; // Has quality triangulation begun yet?
  public int readnodefile; // Has a .node file been read?
  public int samples; // Number of random samples for point location.

  public int incirclecount; // Number of incircle tests performed.
  public int counterclockcount; // Number of counterclockwise tests performed.
  public int orient3dcount; // Number of 3D orientation tests performed.
  public int hyperbolacount; // Number of right-of-hyperbola tests performed.
  public int circumcentercount; // Number of circumcenter calculations performed.
  public int circletopcount; // Number of circle top calculations performed.

// Triangular bounding box vertices.                                         

  public REAL infvertex1;
  public REAL infvertex2;
  public REAL infvertex3;

// Pointer to the `triangle' that occupies all of "outer space."             

  public REAL[][][] dummytri;
  public REAL[][][] dummytribase; // Keep base address so we can free() it later.

// Pointer to the omnipresent subsegment.  Referenced by any triangle or     
//   subsegment that isn't really connected to a subsegment at that          
//   location.                                                               

  public REAL[][][] dummysub;
  public REAL[][][] dummysubbase; // Keep base address so we can free() it later.

// Pointer to a recently visited triangle.  Improves point location if       
//   proximate vertices are inserted sequentially.                           

  public otri recenttri = new otri();

} // End of `struct mesh'.


// Data structure for command line switches and file names.  This structure  
//   is used (instead of global variables) to allow reentrancy.              

public class behavior
{

// Switches for the triangulator.                                            
//   poly: -p switch.  refine: -r switch.                                    
//   quality: -q switch.                                                     
//     minangle: minimum angle bound, specified after -q switch.             
//     goodangle: cosine squared of minangle.                                
//     offconstant: constant used to place off-center Steiner points.        
//   vararea: -a switch without number.                                      
//   fixedarea: -a switch with number.                                       
//     maxarea: maximum area bound, specified after -a switch.               
//   usertest: -u switch.                                                    
//   regionattrib: -A switch.  convex: -c switch.                            
//   weighted: 1 for -w switch, 2 for -W switch.  jettison: -j switch        
//   firstnumber: inverse of -z switch.  All items are numbered starting     
//     from `firstnumber'.                                                   
//   edgesout: -e switch.  voronoi: -v switch.                               
//   neighbors: -n switch.  geomview: -g switch.                             
//   nobound: -B switch.  nopolywritten: -P switch.                          
//   nonodewritten: -N switch.  noelewritten: -E switch.                     
//   noiterationnum: -I switch.  noholes: -O switch.                         
//   noexact: -X switch.                                                     
//   order: element order, specified after -o switch.                        
//   nobisect: count of how often -Y switch is selected.                     
//   steiner: maximum number of Steiner points, specified after -S switch.   
//   incremental: -i switch.  sweepline: -F switch.                          
//   dwyer: inverse of -l switch.                                            
//   splitseg: -s switch.                                                    
//   conformdel: -D switch.  docheck: -C switch.                             
//   quiet: -Q switch.  verbose: count of how often -V switch is selected.   
//   usesegments: -p, -r, -q, or -c switch; determines whether segments are  
//     used at all.                                                          
//                                                                           
// Read the instructions to find out the meaning of these switches.          

  public int poly;
  public int refine;
  public int quality;
  public int vararea;
  public int fixedarea;
  public int usertest;
  public int regionattrib;
  public int convex;
  public int weighted;
  public int jettison;
  public int firstnumber;
  public int edgesout;
  public int voronoi;
  public int neighbors;
  public int geomview;
  public int nobound;
  public int nopolywritten;
  public int nonodewritten;
  public int noelewritten;
  public int noiterationnum;
  public int noholes;
  public int noexact;
  public int conformdel;
  public int incremental;
  public int sweepline;
  public int dwyer;
  public int splitseg;
  public int docheck;
  public int quiet;
  public int verbose;
  public int usesegments;
  public int order;
  public int nobisect;
  public int steiner;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  public REAL minangle;
  public REAL goodangle;
  public REAL offconstant;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  public REAL maxarea;

// Variables for file names.                                                 

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
  public String innodefilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
  public String inelefilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
  public String inpolyfilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
  public String areafilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
  public String outnodefilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
  public String outelefilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
  public String outpolyfilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
  public String edgefilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
  public String vnodefilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
  public String vedgefilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
  public String neighborfilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
  public String offfilename = new String(new char[DefineConstantsTriangle.FILENAMESIZE]);
//#endif // not TRILIBRARY

} // End of `struct behavior'.
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
//	* (int *)(m->dummysub + 8) = 0;

	// Initialize the three adjoining subsegments of `dummytri' to be 
	//   the omnipresent subsegment.                                  
	m.dummytri[6] = (GlobalMembersTriangle.REAL) m.dummysub;
	m.dummytri[7] = (GlobalMembersTriangle.REAL) m.dummysub;
	m.dummytri[8] = (GlobalMembersTriangle.REAL) m.dummysub;
  }
}

//***************************************************************************
//                                                                           
//  initializevertexpool()   Calculate the size of the vertex data structure 
//                           and initialize its memory pool.                 
//                                                                           
//  This routine also computes the `vertexmarkindex' and `vertex2triindex'   
//  indices used to find values within each vertex.                          
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.initializevertexpool(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.initializevertexpool(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  int vertexsize;

  // The index within each vertex at which the boundary marker is found,    
  //   followed by the vertex type.  Ensure the vertex marker is aligned to 
  //   a sizeof(int)-byte address.                                          
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  m.vertexmarkindex = ((m.mesh_dim + m.nextras) * sizeof(GlobalMembersTriangle.REAL) + sizeof(int) - 1) / sizeof(int);
  vertexsize = (m.vertexmarkindex + 2) * sizeof(int);
  if (b.poly != 0)
  {
	// The index within each vertex at which a triangle pointer is found.  
	//   Ensure the pointer is aligned to a sizeof(triangle)-byte address. 
	m.vertex2triindex = (vertexsize + sizeof(GlobalMembersTriangle.REAL) - 1) / sizeof(GlobalMembersTriangle.REAL **);
	vertexsize = (m.vertex2triindex + 1) * sizeof(GlobalMembersTriangle.REAL **);
  }

  // Initialize the pool of vertices. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.poolinit(m.vertices, vertexsize, DefineConstantsTriangle.VERTEXPERBLOCK, m.invertices > DefineConstantsTriangle.VERTEXPERBLOCK ? m.invertices : DefineConstantsTriangle.VERTEXPERBLOCK, sizeof(GlobalMembersTriangle.REAL));
}

//***************************************************************************
//                                                                           
//  initializetrisubpools()   Calculate the sizes of the triangle and        
//                            subsegment data structures and initialize      
//                            their memory pools.                            
//                                                                           
//  This routine also computes the `highorderindex', `elemattribindex', and  
//  `areaboundindex' indices used to find values within each triangle.       
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.initializetrisubpools(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.initializetrisubpools(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  int trisize;

  // The index within each triangle at which the extra nodes (above three)  
  //   associated with high order elements are found.  There are three      
  //   pointers to other triangles, three pointers to corners, and possibly 
  //   three pointers to subsegments before the extra nodes.                
  m.highorderindex = 6 + (b.usesegments * 3);
  // The number of bytes occupied by a triangle. 
  trisize = ((b.order + 1) * (b.order + 2) / 2 + (m.highorderindex - 3)) * sizeof(GlobalMembersTriangle.REAL **);
  // The index within each triangle at which its attributes are found, 
  //   where the index is measured in REALs.                           
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  m.elemattribindex = (trisize + sizeof(GlobalMembersTriangle.REAL) - 1) / sizeof(GlobalMembersTriangle.REAL);
  // The index within each triangle at which the maximum area constraint  
  //   is found, where the index is measured in REALs.  Note that if the  
  //   `regionattrib' flag is set, an additional attribute will be added. 
  m.areaboundindex = m.elemattribindex + m.eextras + b.regionattrib;
  // If triangle attributes or an area bound are needed, increase the number 
  //   of bytes occupied by a triangle.                                      
  if (b.vararea != 0)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	trisize = (m.areaboundindex + 1) * sizeof(GlobalMembersTriangle.REAL);
  }
  else if (m.eextras + b.regionattrib > 0)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	trisize = m.areaboundindex * sizeof(GlobalMembersTriangle.REAL);
  }
  // If a Voronoi diagram or triangle neighbor graph is requested, make    
  //   sure there's room to store an integer index in each triangle.  This 
  //   integer index can occupy the same space as the subsegment pointers  
  //   or attributes or area constraint or extra nodes.                    
  if ((b.voronoi != 0 || b.neighbors != 0) && (trisize < 6 * sizeof(GlobalMembersTriangle.REAL) + sizeof(int)))
  {
	trisize = 6 * sizeof(GlobalMembersTriangle.REAL) + sizeof(int);
  }

  // Having determined the memory size of a triangle, initialize the pool. 
  GlobalMembersTriangle.poolinit(m.triangles, trisize, DefineConstantsTriangle.TRIPERBLOCK, (2 m.invertices - 2) > DefineConstantsTriangle.TRIPERBLOCK ? (2 m.invertices - 2) : DefineConstantsTriangle.TRIPERBLOCK, 4);

  if (b.usesegments != 0)
  {
	// Initialize the pool of subsegments.  Take into account all eight 
	//   pointers and one boundary marker.                              
	GlobalMembersTriangle.poolinit(m.subsegs, 8 * sizeof(GlobalMembersTriangle.REAL) + sizeof(int), DefineConstantsTriangle.SUBSEGPERBLOCK, DefineConstantsTriangle.SUBSEGPERBLOCK, 4);

	// Initialize the "outer space" triangle and omnipresent subsegment. 
	GlobalMembersTriangle.dummyinit(m, b, m.triangles.itembytes, m.subsegs.itembytes);
  }
  else
  {
	// Initialize the "outer space" triangle. 
	GlobalMembersTriangle.dummyinit(m, b, m.triangles.itembytes, 0);
  }
}

//***************************************************************************
//                                                                           
//  triangledealloc()   Deallocate space for a triangle, marking it dead.    
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.triangledealloc(struct mesh m, GlobalMembersTriangle.REAL ** *dyingtriangle)
//#else
void GlobalMembersTriangle.triangledealloc(m, dyingtriangle)
mesh m;
GlobalMembersTriangle.REAL[][][] dyingtriangle;
//#endif // not ANSI_DECLARATORS

{
  // Mark the triangle as dead.  This makes it possible to detect dead 
  //   triangles when traversing the list of all triangles.            
  (dyingtriangle)[1] = (GlobalMembersTriangle.REAL) null;
  (dyingtriangle)[3] = (GlobalMembersTriangle.REAL) null;
  GlobalMembersTriangle.pooldealloc(m.triangles, (int) dyingtriangle);
}

//***************************************************************************
//                                                                           
//  triangletraverse()   Traverse the triangles, skipping dead ones.         
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
GlobalMembersTriangle.REAL ** *GlobalMembersTriangle.triangletraverse(struct mesh m)
//#else
GlobalMembersTriangle.REAL ** *GlobalMembersTriangle.triangletraverse(m)
mesh m;
//#endif // not ANSI_DECLARATORS

{
  GlobalMembersTriangle.REAL[][][] newtriangle;

  do
  {
	newtriangle = (GlobalMembersTriangle.REAL ** *) GlobalMembersTriangle.traverse(m.triangles);
	if (newtriangle == (GlobalMembersTriangle.REAL ** *) null)
	{
	  return (GlobalMembersTriangle.REAL ** *) null;
	}
  } while (((newtriangle)[1] == (GlobalMembersTriangle.REAL) null));
  return newtriangle;
}

//***************************************************************************
//                                                                           
//  subsegdealloc()   Deallocate space for a subsegment, marking it dead.    
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.subsegdealloc(struct mesh m, GlobalMembersTriangle.REAL ** *dyingsubseg)
//#else
void GlobalMembersTriangle.subsegdealloc(m, dyingsubseg)
mesh m;
GlobalMembersTriangle.REAL[][][] dyingsubseg;
//#endif // not ANSI_DECLARATORS

{
  // Mark the subsegment as dead.  This makes it possible to detect dead 
  //   subsegments when traversing the list of all subsegments.          
  (dyingsubseg)[1] = (GlobalMembersTriangle.REAL) null;
  (dyingsubseg)[2] = (GlobalMembersTriangle.REAL) null;
  GlobalMembersTriangle.pooldealloc(m.subsegs, (int) dyingsubseg);
}

//***************************************************************************
//                                                                           
//  subsegtraverse()   Traverse the subsegments, skipping dead ones.         
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
GlobalMembersTriangle.REAL ** *GlobalMembersTriangle.subsegtraverse(struct mesh m)
//#else
GlobalMembersTriangle.REAL ** *GlobalMembersTriangle.subsegtraverse(m)
mesh m;
//#endif // not ANSI_DECLARATORS

{
  GlobalMembersTriangle.REAL[][][] newsubseg;

  do
  {
	newsubseg = (GlobalMembersTriangle.REAL ** *) GlobalMembersTriangle.traverse(m.subsegs);
	if (newsubseg == (GlobalMembersTriangle.REAL ** *) null)
	{
	  return (GlobalMembersTriangle.REAL ** *) null;
	}
  } while (((newsubseg)[1] == (GlobalMembersTriangle.REAL) null));
  return newsubseg;
}

//***************************************************************************
//                                                                           
//  vertexdealloc()   Deallocate space for a vertex, marking it dead.        
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.vertexdealloc(struct mesh m, GlobalMembersTriangle.REAL * dyingvertex)
//#else
void GlobalMembersTriangle.vertexdealloc(m, dyingvertex)
mesh m;
GlobalMembersTriangle.REAL dyingvertex;
//#endif // not ANSI_DECLARATORS

{
  // Mark the vertex as dead.  This makes it possible to detect dead 
  //   vertices when traversing the list of all vertices.            
  ((int)(dyingvertex))[m.vertexmarkindex + 1] = -32768;
  GlobalMembersTriangle.pooldealloc(m.vertices, (int) dyingvertex);
}

//***************************************************************************
//                                                                           
//  vertextraverse()   Traverse the vertices, skipping dead ones.            
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
GlobalMembersTriangle.REAL * GlobalMembersTriangle.vertextraverse(struct mesh m)
//#else
GlobalMembersTriangle.REAL * GlobalMembersTriangle.vertextraverse(m)
mesh m;
//#endif // not ANSI_DECLARATORS

{
  GlobalMembersTriangle.REAL newvertex;

  do
  {
	newvertex = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.traverse(m.vertices);
	if (newvertex == (GlobalMembersTriangle.REAL) null)
	{
	  return (GlobalMembersTriangle.REAL) null;
	}
  } while (((int)(newvertex))[m.vertexmarkindex + 1] == -32768);
  return newvertex;
}

//***************************************************************************
//                                                                           
//  badsubsegdealloc()   Deallocate space for a bad subsegment, marking it   
//                       dead.                                               
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.badsubsegdealloc(struct mesh m, struct badsubseg *dyingseg)
//#else
void GlobalMembersTriangle.badsubsegdealloc(m, dyingseg)
mesh m;
badsubseg dyingseg;
//#endif // not ANSI_DECLARATORS

{
  // Set subsegment's origin to NULL.  This makes it possible to detect dead 
  //   badsubsegs when traversing the list of all badsubsegs             .   
  dyingseg.subsegorg = (GlobalMembersTriangle.REAL) null;
  GlobalMembersTriangle.pooldealloc(m.badsubsegs, (int) dyingseg);
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  badsubsegtraverse()   Traverse the bad subsegments, skipping dead ones.  
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
struct badsubseg *GlobalMembersTriangle.badsubsegtraverse(struct mesh m)
//#else
struct badsubseg *GlobalMembersTriangle.badsubsegtraverse(m)
mesh m;
//#endif // not ANSI_DECLARATORS

{
  badsubseg newseg;

  do
  {
	newseg = (badsubseg) GlobalMembersTriangle.traverse(m.badsubsegs);
	if (newseg == (badsubseg) null)
	{
	  return (badsubseg) null;
	}
  } while (newseg.subsegorg == (GlobalMembersTriangle.REAL) null); // Skip dead ones.
  return newseg;
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  getvertex()   Get a specific vertex, by number, from the list.           
//                                                                           
//  The first vertex is number 'firstnumber'.                                
//                                                                           
//  Note that this takes O(n) time (with a small constant, if VERTEXPERBLOCK 
//  is large).  I don't care to take the trouble to make it work in constant 
//  time.                                                                    
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
GlobalMembersTriangle.REAL * GlobalMembersTriangle.getvertex(struct mesh m, struct behavior b, int number)
//#else
GlobalMembersTriangle.REAL * GlobalMembersTriangle.getvertex(m, b, number)
mesh m;
behavior b;
int number;
//#endif // not ANSI_DECLARATORS

{
  int[] getblock;
  String foundvertex;
  int alignptr;
  int current;

  getblock = m.vertices.firstblock;
  current = b.firstnumber;

  // Find the right block. 
  if (current + m.vertices.itemsfirstblock <= number)
  {
	getblock = (int) *getblock;
	current += m.vertices.itemsfirstblock;
	while (current + m.vertices.itemsperblock <= number)
	{
	  getblock = (int) *getblock;
	  current += m.vertices.itemsperblock;
	}
  }

  // Now find the right vertex. 
  alignptr = (int)(getblock + 1);
  foundvertex = (char)(alignptr + (int) m.vertices.alignbytes - (alignptr % (int) m.vertices.alignbytes));
  return (GlobalMembersTriangle.REAL)(foundvertex + m.vertices.itembytes * (number - current));
}

//***************************************************************************
//                                                                           
//  triangledeinit()   Free all remaining allocated memory.                  
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.triangledeinit(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.triangledeinit(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  GlobalMembersTriangle.pooldeinit(m.triangles);
  GlobalMembersTriangle.trifree((int) m.dummytribase);
  if (b.usesegments != 0)
  {
	GlobalMembersTriangle.pooldeinit(m.subsegs);
	GlobalMembersTriangle.trifree((int) m.dummysubbase);
  }
  GlobalMembersTriangle.pooldeinit(m.vertices);
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
  if (b.quality != 0)
  {
	GlobalMembersTriangle.pooldeinit(m.badsubsegs);
	if ((b.minangle > 0.0) || b.vararea || b.fixedarea || b.usertest != 0)
	{
	  GlobalMembersTriangle.pooldeinit(m.badtriangles);
	  GlobalMembersTriangle.pooldeinit(m.flipstackers);
	}
  }
//#endif // not CDT_ONLY
}

//*                                                                         *
//*                                                                         *
//******** Memory management routines end here                       ********

//******** Constructors begin here                                   ********
//*                                                                         *
//*                                                                         *

//***************************************************************************
//                                                                           
//  maketriangle()   Create a new triangle with orientation zero.            
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.maketriangle(struct mesh m, struct behavior b, struct otri *newotri)
//#else
void GlobalMembersTriangle.maketriangle(m, b, newotri)
mesh m;
behavior b;
otri newotri;
//#endif // not ANSI_DECLARATORS

{
  int i;

  newotri.tri = (GlobalMembersTriangle.REAL ** *) GlobalMembersTriangle.poolalloc(m.triangles);
  // Initialize the three adjoining triangles to be "outer space". 
  newotri.tri[0] = (GlobalMembersTriangle.REAL) m.dummytri;
  newotri.tri[1] = (GlobalMembersTriangle.REAL) m.dummytri;
  newotri.tri[2] = (GlobalMembersTriangle.REAL) m.dummytri;
  // Three NULL vertices. 
  newotri.tri[3] = (GlobalMembersTriangle.REAL) null;
  newotri.tri[4] = (GlobalMembersTriangle.REAL) null;
  newotri.tri[5] = (GlobalMembersTriangle.REAL) null;
  if (b.usesegments != 0)
  {
	// Initialize the three adjoining subsegments to be the omnipresent 
	//   subsegment.                                                    
	newotri.tri[6] = (GlobalMembersTriangle.REAL) m.dummysub;
	newotri.tri[7] = (GlobalMembersTriangle.REAL) m.dummysub;
	newotri.tri[8] = (GlobalMembersTriangle.REAL) m.dummysub;
  }
  for (i = 0; i < m.eextras; i++)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	((GlobalMembersTriangle.REAL) newotri.tri)[m.elemattribindex + (i)] = 0.0;
  }
  if (b.vararea != 0)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	((GlobalMembersTriangle.REAL) newotri.tri)[m.areaboundindex] = -1.0;
  }

  newotri.orient = 0;
}

//***************************************************************************
//                                                                           
//  makesubseg()   Create a new subsegment with orientation zero.            
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.makesubseg(struct mesh m, struct osub *newsubseg)
//#else
void GlobalMembersTriangle.makesubseg(m, newsubseg)
mesh m;
osub newsubseg;
//#endif // not ANSI_DECLARATORS

{
  newsubseg.ss = (GlobalMembersTriangle.REAL ** *) GlobalMembersTriangle.poolalloc(m.subsegs);
  // Initialize the two adjoining subsegments to be the omnipresent 
  //   subsegment.                                                  
  newsubseg.ss[0] = (GlobalMembersTriangle.REAL) m.dummysub;
  newsubseg.ss[1] = (GlobalMembersTriangle.REAL) m.dummysub;
  // Four NULL vertices. 
  newsubseg.ss[2] = (GlobalMembersTriangle.REAL) null;
  newsubseg.ss[3] = (GlobalMembersTriangle.REAL) null;
  newsubseg.ss[4] = (GlobalMembersTriangle.REAL) null;
  newsubseg.ss[5] = (GlobalMembersTriangle.REAL) null;
  // Initialize the two adjoining triangles to be "outer space." 
  newsubseg.ss[6] = (GlobalMembersTriangle.REAL) m.dummytri;
  newsubseg.ss[7] = (GlobalMembersTriangle.REAL) m.dummytri;
  // Set the boundary marker to zero. 
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
//  * (int *)(newsubseg.ss + 8) = 0;

  newsubseg.ssorient = 0;
}

//*                                                                         *
//*                                                                         *
//******** Constructors end here                                     ********

//******** Geometric primitives begin here                           ********
//*                                                                         *
//*                                                                         *

// The adaptive exact arithmetic geometric predicates implemented herein are 
//   described in detail in my paper, "Adaptive Precision Floating-Point     */
///*   Arithmetic and Fast Robust Geometric Predicates."  See the header for a */
///*   full citation.                                                          

// Which of the following two methods of finding the absolute values is      
//   fastest is compiler-dependent.  A few compilers can inline and optimize 
//   the fabs() call; but most will incur the overhead of a function call,   
//   which is disastrously slow.  A faster way on IEEE machines might be to  
//   mask the appropriate bit, but that's difficult to do in C without       
//   forcing the value to be stored to memory (rather than be kept in the    
//   register to which the optimizer assigned it).                           

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Absolute(a) ((a) >= 0.0 ? (a) : -(a))
// #define Absolute(a)  fabs(a) 

// Many of the operations are broken up into two pieces, a main part that    
//   performs an approximate operation, and a "tail" that computes the       
//   roundoff error of that operation.                                       
//                                                                           
// The operations Fast_Two_Sum(), Fast_Two_Diff(), Two_Sum(), Two_Diff(),    
//   Split(), and Two_Product() are all implemented as described in the      
//   reference.  Each of these macros requires certain variables to be       
//   defined in the calling routine.  The variables `bvirt', `c', `abig',    
//   `_i', `_j', `_k', `_l', `_m', and `_n' are declared `INEXACT' because   
//   they store the result of an operation that may incur roundoff error.    
//   The input parameter `x' (or the highest numbered `x_' parameter) must   
//   also be declared `INEXACT'.                                             


//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Fast_Two_Sum_Tail(a, b, x, y) bvirt = x - a; y = b - bvirt
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Fast_Two_Sum(a, b, x, y) x = (REAL) (a + b); bvirt = x - a; y = b - bvirt
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_Sum_Tail(a, b, x, y) bvirt = (REAL) (x - a); avirt = x - bvirt; bround = b - bvirt; around = a - avirt; y = around + bround
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_Sum(a, b, x, y) x = (REAL) (a + b); bvirt = (REAL) (x - a); avirt = x - bvirt; bround = b - bvirt; around = a - avirt; y = around + bround
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_Diff_Tail(a, b, x, y) bvirt = (REAL) (a - x); avirt = x + bvirt; bround = bvirt - b; around = a - avirt; y = around + bround
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_Diff(a, b, x, y) x = (REAL) (a - b); bvirt = (REAL) (a - x); avirt = x + bvirt; bround = bvirt - b; around = a - avirt; y = around + bround
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Split(a, ahi, alo) c = (REAL) (splitter * a); abig = (REAL) (c - a); ahi = c - abig; alo = a - ahi
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_Product_Tail(a, b, x, y) c = (REAL) (splitter * a); abig = (REAL) (c - a); ahi = c - abig; alo = a - ahi; c = (REAL) (splitter * b); abig = (REAL) (c - b); bhi = c - abig; blo = b - bhi; err1 = x - (ahi * bhi); err2 = err1 - (alo * bhi); err3 = err2 - (ahi * blo); y = (alo * blo) - err3
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_Product(a, b, x, y) x = (REAL) (a * b); c = (REAL) (splitter * a); abig = (REAL) (c - a); ahi = c - abig; alo = a - ahi; c = (REAL) (splitter * b); abig = (REAL) (c - b); bhi = c - abig; blo = b - bhi; err1 = x - (ahi * bhi); err2 = err1 - (alo * bhi); err3 = err2 - (ahi * blo); y = (alo * blo) - err3
// Two_Product_Presplit() is Two_Product() where one of the inputs has       
//   already been split.  Avoids redundant splitting.                        

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_Product_Presplit(a, b, bhi, blo, x, y) x = (REAL) (a * b); c = (REAL) (splitter * a); abig = (REAL) (c - a); ahi = c - abig; alo = a - ahi; err1 = x - (ahi * bhi); err2 = err1 - (alo * bhi); err3 = err2 - (ahi * blo); y = (alo * blo) - err3
// Square() can be done more quickly than Two_Product().                     

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Square_Tail(a, x, y) c = (REAL) (splitter * a); abig = (REAL) (c - a); ahi = c - abig; alo = a - ahi; err1 = x - (ahi * ahi); err3 = err1 - ((ahi + ahi) * alo); y = (alo * alo) - err3
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Square(a, x, y) x = (REAL) (a * a); c = (REAL) (splitter * a); abig = (REAL) (c - a); ahi = c - abig; alo = a - ahi; err1 = x - (ahi * ahi); err3 = err1 - ((ahi + ahi) * alo); y = (alo * alo) - err3
// Macros for summing expansions of various fixed lengths.  These are all    
//   unrolled versions of Expansion_Sum().                                   

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_One_Sum(a1, a0, b, x2, x1, x0) _i = (REAL) (a0 + b); bvirt = (REAL) (_i - a0); avirt = _i - bvirt; bround = b - bvirt; around = a0 - avirt; x0 = around + bround; x2 = (REAL) (a1 + _i); bvirt = (REAL) (x2 - a1); avirt = x2 - bvirt; bround = _i - bvirt; around = a1 - avirt; x1 = around + bround
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_One_Diff(a1, a0, b, x2, x1, x0) _i = (REAL) (a0 - b); bvirt = (REAL) (a0 - _i); avirt = _i + bvirt; bround = bvirt - b; around = a0 - avirt; x0 = around + bround; x2 = (REAL) (a1 + _i); bvirt = (REAL) (x2 - a1); avirt = x2 - bvirt; bround = _i - bvirt; around = a1 - avirt; x1 = around + bround
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_Two_Sum(a1, a0, b1, b0, x3, x2, x1, x0) _i = (REAL) (a0 + b0); bvirt = (REAL) (_i - a0); avirt = _i - bvirt; bround = b0 - bvirt; around = a0 - avirt; x0 = around + bround; _j = (REAL) (a1 + _i); bvirt = (REAL) (_j - a1); avirt = _j - bvirt; bround = _i - bvirt; around = a1 - avirt; _0 = around + bround; _i = (REAL) (_0 + b1); bvirt = (REAL) (_i - _0); avirt = _i - bvirt; bround = b1 - bvirt; around = _0 - avirt; x1 = around + bround; x3 = (REAL) (_j + _i); bvirt = (REAL) (x3 - _j); avirt = x3 - bvirt; bround = _i - bvirt; around = _j - avirt; x2 = around + bround
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_Two_Diff(a1, a0, b1, b0, x3, x2, x1, x0) _i = (REAL) (a0 - b0); bvirt = (REAL) (a0 - _i); avirt = _i + bvirt; bround = bvirt - b0; around = a0 - avirt; x0 = around + bround; _j = (REAL) (a1 + _i); bvirt = (REAL) (_j - a1); avirt = _j - bvirt; bround = _i - bvirt; around = a1 - avirt; _0 = around + bround; _i = (REAL) (_0 - b1); bvirt = (REAL) (_0 - _i); avirt = _i + bvirt; bround = bvirt - b1; around = _0 - avirt; x1 = around + bround; x3 = (REAL) (_j + _i); bvirt = (REAL) (x3 - _j); avirt = x3 - bvirt; bround = _i - bvirt; around = _j - avirt; x2 = around + bround
// Macro for multiplying a two-component expansion by a single component.    

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:

//C++ TO JAVA CONVERTER NOTE: The following #define macro was replaced in-line:
//#define Two_One_Product(a1, a0, b, x3, x2, x1, x0) c = (REAL) (splitter * b); abig = (REAL) (c - b); bhi = c - abig; blo = b - bhi; _i = (REAL) (a0 * b); c = (REAL) (splitter * a0); abig = (REAL) (c - a0); ahi = c - abig; alo = a0 - ahi; err1 = _i - (ahi * bhi); err2 = err1 - (alo * bhi); err3 = err2 - (ahi * blo); x0 = (alo * blo) - err3; _j = (REAL) (a1 * b); c = (REAL) (splitter * a1); abig = (REAL) (c - a1); ahi = c - abig; alo = a1 - ahi; err1 = _j - (ahi * bhi); err2 = err1 - (alo * bhi); err3 = err2 - (ahi * blo); _0 = (alo * blo) - err3; _k = (REAL) (_i + _0); bvirt = (REAL) (_k - _i); avirt = _k - bvirt; bround = _0 - bvirt; around = _i - avirt; x1 = around + bround; x3 = (REAL) (_j + _k); bvirt = x3 - _j; x2 = _k - bvirt
//***************************************************************************
//                                                                           
//  exactinit()   Initialize the variables used for exact arithmetic.        
//                                                                           
//  `epsilon' is the largest power of two such that 1.0 + epsilon = 1.0 in   
//  floating-point arithmetic.  `epsilon' bounds the relative roundoff       
//  error.  It is used for floating-point error analysis.                    
//                                                                           
//  `splitter' is used to split floating-point numbers into two half-        
//  length significands for exact multiplication.                            
//                                                                           
//  I imagine that a highly optimizing compiler might be too smart for its   
//  own good, and somehow cause this routine to fail, if it pretends that    
//  floating-point arithmetic is too much like real arithmetic.              
//                                                                           
//  Don't change this routine unless you fully understand it.                
//                                                                           
//***************************************************************************

void GlobalMembersTriangle.exactinit()
{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL half;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL check;
  GlobalMembersTriangle.REAL lastcheck;
  int every_other;
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if LINUX
  int cword;
//#endif // LINUX

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if CPU86
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if SINGLE
  _control87(_PC_24, _MCW_PC); // Set FPU control word for single precision. cword = 4210; // set FPU control word for single precision
//#else
  _control87(_PC_53, _MCW_PC); // Set FPU control word for double precision. cword = 4210; // set FPU control word for single precision
//#endif // not SINGLE
//#endif // CPU86
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if LINUX
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if SINGLE
  //  cword = 4223; 
  __asm__ ("fldcw %0" : : "m" (*&cword));
//#else
  //  cword = 4735; 
  cword = 4722; // set FPU control word for double precision __asm__ ("fldcw %0" : : "m" (*&cword));
//#endif // not SINGLE
//#endif // LINUX

  every_other = 1;
  half = 0.5;
  GlobalMembersTriangle.epsilon = 1.0;
  GlobalMembersTriangle.splitter = 1.0;
  check = 1.0;
  // Repeatedly divide `epsilon' by two until it is too small to add to      
  //   one without causing roundoff.  (Also check if the sum is equal to     
  //   the previous sum, for machines that round up instead of using exact   
  //   rounding.  Not that these routines will work on such machines.)       
  do
  {
	lastcheck = check;
	GlobalMembersTriangle.epsilon *= half;
	if (every_other != 0)
	{
	  GlobalMembersTriangle.splitter *= 2.0;
	}
	every_other = !every_other;
	check = 1.0 + GlobalMembersTriangle.epsilon;
  } while ((check != 1.0) && (check != lastcheck));
  GlobalMembersTriangle.splitter += 1.0;
  // Error bounds for orientation and incircle tests. 
  GlobalMembersTriangle.resulterrbound = (3.0 + 8.0 * GlobalMembersTriangle.epsilon) * GlobalMembersTriangle.epsilon;
  GlobalMembersTriangle.ccwerrboundA = (3.0 + 16.0 * GlobalMembersTriangle.epsilon) * GlobalMembersTriangle.epsilon;
  GlobalMembersTriangle.ccwerrboundB = (2.0 + 12.0 * GlobalMembersTriangle.epsilon) * GlobalMembersTriangle.epsilon;
  GlobalMembersTriangle.ccwerrboundC = (9.0 + 64.0 * GlobalMembersTriangle.epsilon) * GlobalMembersTriangle.epsilon * GlobalMembersTriangle.epsilon;
  GlobalMembersTriangle.iccerrboundA = (10.0 + 96.0 * GlobalMembersTriangle.epsilon) * GlobalMembersTriangle.epsilon;
  GlobalMembersTriangle.iccerrboundB = (4.0 + 48.0 * GlobalMembersTriangle.epsilon) * GlobalMembersTriangle.epsilon;
  GlobalMembersTriangle.iccerrboundC = (44.0 + 576.0 * GlobalMembersTriangle.epsilon) * GlobalMembersTriangle.epsilon * GlobalMembersTriangle.epsilon;
  GlobalMembersTriangle.o3derrboundA = (7.0 + 56.0 * GlobalMembersTriangle.epsilon) * GlobalMembersTriangle.epsilon;
  GlobalMembersTriangle.o3derrboundB = (3.0 + 28.0 * GlobalMembersTriangle.epsilon) * GlobalMembersTriangle.epsilon;
  GlobalMembersTriangle.o3derrboundC = (26.0 + 288.0 * GlobalMembersTriangle.epsilon) * GlobalMembersTriangle.epsilon * GlobalMembersTriangle.epsilon;
}

//***************************************************************************
//                                                                           
//  fast_expansion_sum_zeroelim()   Sum two expansions, eliminating zero     
//                                  components from the output expansion.    
//                                                                           
//  Sets h = e + f.  See my Robust Predicates paper for details.             
//                                                                           
//  If round-to-even is used (as with IEEE 754), maintains the strongly      
//  nonoverlapping property.  (That is, if e is strongly nonoverlapping, h   
//  will be also.)  Does NOT maintain the nonoverlapping or nonadjacent      
//  properties.                                                              
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
int GlobalMembersTriangle.fast_expansion_sum_zeroelim(int elen, GlobalMembersTriangle.REAL *e, int flen, GlobalMembersTriangle.REAL *f, GlobalMembersTriangle.REAL *h)
//#else
int GlobalMembersTriangle.fast_expansion_sum_zeroelim(elen, e, flen, f, h) // h cannot be e or f.
int elen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL e;
int flen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL f;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL h;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL Q;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL Qnew;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL hh;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bvirt;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL avirt;
  GlobalMembersTriangle.REAL bround;
  GlobalMembersTriangle.REAL around;
  int eindex;
  int findex;
  int hindex;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL enow;
  GlobalMembersTriangle.REAL fnow;

  enow = e[0];
  fnow = f[0];
  eindex = findex = 0;
  if ((fnow > enow) == (fnow > -enow))
  {
	Q = enow;
	enow = e[++eindex];
  }
  else
  {
	Q = fnow;
	fnow = f[++findex];
  }
  hindex = 0;
  if ((eindex < elen) && (findex < flen))
  {
	if ((fnow > enow) == (fnow > -enow))
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  Qnew = (GlobalMembersTriangle.REAL)(enow + Q);
	  bvirt = Qnew - enow;
	  hh = Q - bvirt;
	  enow = e[++eindex];
	}
	else
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  Qnew = (GlobalMembersTriangle.REAL)(fnow + Q);
	  bvirt = Qnew - fnow;
	  hh = Q - bvirt;
	  fnow = f[++findex];
	}
	Q = Qnew;
	if (hh != 0.0)
	{
	  h[hindex++] = hh;
	}
	while ((eindex < elen) && (findex < flen))
	{
	  if ((fnow > enow) == (fnow > -enow))
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		Qnew = (GlobalMembersTriangle.REAL)(Q + enow);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		bvirt = (GlobalMembersTriangle.REAL)(Qnew - Q);
		avirt = Qnew - bvirt;
		bround = enow - bvirt;
		around = Q - avirt;
		hh = around + bround;
		enow = e[++eindex];
	  }
	  else
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		Qnew = (GlobalMembersTriangle.REAL)(Q + fnow);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		bvirt = (GlobalMembersTriangle.REAL)(Qnew - Q);
		avirt = Qnew - bvirt;
		bround = fnow - bvirt;
		around = Q - avirt;
		hh = around + bround;
		fnow = f[++findex];
	  }
	  Q = Qnew;
	  if (hh != 0.0)
	  {
		h[hindex++] = hh;
	  }
	}
  }
  while (eindex < elen)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	Qnew = (GlobalMembersTriangle.REAL)(Q + enow);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(Qnew - Q);
	avirt = Qnew - bvirt;
	bround = enow - bvirt;
	around = Q - avirt;
	hh = around + bround;
	enow = e[++eindex];
	Q = Qnew;
	if (hh != 0.0)
	{
	  h[hindex++] = hh;
	}
  }
  while (findex < flen)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	Qnew = (GlobalMembersTriangle.REAL)(Q + fnow);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(Qnew - Q);
	avirt = Qnew - bvirt;
	bround = fnow - bvirt;
	around = Q - avirt;
	hh = around + bround;
	fnow = f[++findex];
	Q = Qnew;
	if (hh != 0.0)
	{
	  h[hindex++] = hh;
	}
  }
  if ((Q != 0.0) || (hindex == 0))
  {
	h[hindex++] = Q;
  }
  return hindex;
}

//***************************************************************************
//                                                                           
//  scale_expansion_zeroelim()   Multiply an expansion by a scalar,          
//                               eliminating zero components from the        
//                               output expansion.                           
//                                                                           
//  Sets h = be.  See my Robust Predicates paper for details.                
//                                                                           
//  Maintains the nonoverlapping property.  If round-to-even is used (as     
//  with IEEE 754), maintains the strongly nonoverlapping and nonadjacent    
//  properties as well.  (That is, if e has one of these properties, so      
//  will h.)                                                                 
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
int GlobalMembersTriangle.scale_expansion_zeroelim(int elen, GlobalMembersTriangle.REAL e, GlobalMembersTriangle.REAL b, GlobalMembersTriangle.REAL h)
//#else
int GlobalMembersTriangle.scale_expansion_zeroelim(elen, e, b, h) // e and h cannot be the same.
int elen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL e;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL b;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL h;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL Q;
   GlobalMembersTriangle.REAL sum;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL hh;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL product1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL product0;
  int eindex;
  int hindex;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL enow;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bvirt;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL avirt;
  GlobalMembersTriangle.REAL bround;
  GlobalMembersTriangle.REAL around;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL c;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL abig;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL ahi;
  GlobalMembersTriangle.REAL alo;
  GlobalMembersTriangle.REAL bhi;
  GlobalMembersTriangle.REAL blo;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL err1;
  GlobalMembersTriangle.REAL err2;
  GlobalMembersTriangle.REAL err3;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter b);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - b);
  bhi = c - abig;
  blo = b - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  Q = (GlobalMembersTriangle.REAL)(e[0] b);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter e[0]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - e[0]);
  ahi = c - abig;
  alo = e[0] - ahi;
  err1 = Q - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  hh = (alo * blo) - err3;
  hindex = 0;
  if (hh != 0)
  {
	h[hindex++] = hh;
  }
  for (eindex = 1; eindex < elen; eindex++)
  {
	enow = e[eindex];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	product1 = (GlobalMembersTriangle.REAL)(enow b);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * enow);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	abig = (GlobalMembersTriangle.REAL)(c - enow);
	ahi = c - abig;
	alo = enow - ahi;
	err1 = product1 - (ahi * bhi);
	err2 = err1 - (alo * bhi);
	err3 = err2 - (ahi * blo);
	product0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	sum = (GlobalMembersTriangle.REAL)(Q + product0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(sum - Q);
	avirt = sum - bvirt;
	bround = product0 - bvirt;
	around = Q - avirt;
	hh = around + bround;
	if (hh != 0)
	{
	  h[hindex++] = hh;
	}
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	Q = (GlobalMembersTriangle.REAL)(product1 + sum);
	bvirt = Q - product1;
	hh = sum - bvirt;
	if (hh != 0)
	{
	  h[hindex++] = hh;
	}
  }
  if ((Q != 0.0) || (hindex == 0))
  {
	h[hindex++] = Q;
  }
  return hindex;
}

//***************************************************************************
//                                                                           
//  estimate()   Produce a one-word estimate of an expansion's value.        
//                                                                           
//  See my Robust Predicates paper for details.                              
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.estimate(int elen, GlobalMembersTriangle.REAL e)
//#else
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.estimate(elen, e)
int elen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL e;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL Q;
  int eindex;

  Q = e[0];
  for (eindex = 1; eindex < elen; eindex++)
  {
	Q += e[eindex];
  }
  return Q;
}

//***************************************************************************
//                                                                           
//  counterclockwise()   Return a positive value if the points pa, pb, and   
//                       pc occur in counterclockwise order; a negative      
//                       value if they occur in clockwise order; and zero    
//                       if they are collinear.  The result is also a rough  
//                       approximation of twice the signed area of the       
//                       triangle defined by the three points.               
//                                                                           
//  Uses exact arithmetic if necessary to ensure a correct answer.  The      
//  result returned is the determinant of a matrix.  This determinant is     
//  computed adaptively, in the sense that exact arithmetic is used only to  
//  the degree it is needed to ensure that the returned value has the        
//  correct sign.  Hence, this function is usually quite fast, but will run  
//  more slowly when the input points are collinear or nearly so.            
//                                                                           
//  See my Robust Predicates paper for details.                              
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.counterclockwiseadapt(GlobalMembersTriangle.REAL * pa, GlobalMembersTriangle.REAL * pb, GlobalMembersTriangle.REAL * pc, GlobalMembersTriangle.REAL detsum)
//#else
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.counterclockwiseadapt(pa, pb, pc, detsum)
GlobalMembersTriangle.REAL pa;
GlobalMembersTriangle.REAL pb;
GlobalMembersTriangle.REAL pc;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL detsum;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL acx;
   GlobalMembersTriangle.REAL acy;
   GlobalMembersTriangle.REAL bcx;
   GlobalMembersTriangle.REAL bcy;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL acxtail;
  GlobalMembersTriangle.REAL acytail;
  GlobalMembersTriangle.REAL bcxtail;
  GlobalMembersTriangle.REAL bcytail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL detleft;
   GlobalMembersTriangle.REAL detright;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL detlefttail;
  GlobalMembersTriangle.REAL detrighttail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL det;
  GlobalMembersTriangle.REAL errbound;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] B = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] C1 = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] C2 = new GlobalMembersTriangle.REAL[12];
  GlobalMembersTriangle.REAL[] D = new GlobalMembersTriangle.REAL[16];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL B3;
  int C1length;
  int C2length;
  int Dlength;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] u = new GlobalMembersTriangle.REAL[4];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL u3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL s1;
   GlobalMembersTriangle.REAL t1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL s0;
  GlobalMembersTriangle.REAL t0;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bvirt;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL avirt;
  GlobalMembersTriangle.REAL bround;
  GlobalMembersTriangle.REAL around;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL c;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL abig;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL ahi;
  GlobalMembersTriangle.REAL alo;
  GlobalMembersTriangle.REAL bhi;
  GlobalMembersTriangle.REAL blo;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL err1;
  GlobalMembersTriangle.REAL err2;
  GlobalMembersTriangle.REAL err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL _i;
   GlobalMembersTriangle.REAL _j;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL _0;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  acx = (GlobalMembersTriangle.REAL)(pa[0] - pc[0]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bcx = (GlobalMembersTriangle.REAL)(pb[0] - pc[0]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  acy = (GlobalMembersTriangle.REAL)(pa[1] - pc[1]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bcy = (GlobalMembersTriangle.REAL)(pb[1] - pc[1]);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  detleft = (GlobalMembersTriangle.REAL)(acx * bcy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * acx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - acx);
  ahi = c - abig;
  alo = acx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bcy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bcy);
  bhi = c - abig;
  blo = bcy - bhi;
  err1 = detleft - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  detlefttail = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  detright = (GlobalMembersTriangle.REAL)(acy * bcx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * acy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - acy);
  ahi = c - abig;
  alo = acy - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bcx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bcx);
  bhi = c - abig;
  blo = bcx - bhi;
  err1 = detright - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  detrighttail = (alo * blo) - err3;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(detlefttail - detrighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(detlefttail - _i);
  avirt = _i + bvirt;
  bround = bvirt - detrighttail;
  around = detlefttail - avirt;
  B[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _j = (GlobalMembersTriangle.REAL)(detleft + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_j - detleft);
  avirt = _j - bvirt;
  bround = _i - bvirt;
  around = detleft - avirt;
  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(_0 - detright);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - detright;
  around = _0 - avirt;
  B[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  B3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(B3 - _j);
  avirt = B3 - bvirt;
  bround = _i - bvirt;
  around = _j - avirt;
  B[2] = around + bround;
  B[3] = B3;

  det = GlobalMembersTriangle.estimate(4, B);
  errbound = GlobalMembersTriangle.ccwerrboundB * detsum;
  if ((det >= errbound) || (-det >= errbound))
  {
	return det;
  }

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pa[0] - acx);
  avirt = acx + bvirt;
  bround = bvirt - pc[0];
  around = pa[0] - avirt;
  acxtail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pb[0] - bcx);
  avirt = bcx + bvirt;
  bround = bvirt - pc[0];
  around = pb[0] - avirt;
  bcxtail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pa[1] - acy);
  avirt = acy + bvirt;
  bround = bvirt - pc[1];
  around = pa[1] - avirt;
  acytail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pb[1] - bcy);
  avirt = bcy + bvirt;
  bround = bvirt - pc[1];
  around = pb[1] - avirt;
  bcytail = around + bround;

  if ((acxtail == 0.0) && (acytail == 0.0) && (bcxtail == 0.0) && (bcytail == 0.0))
  {
	return det;
  }

  errbound = GlobalMembersTriangle.ccwerrboundC * detsum + GlobalMembersTriangle.resulterrbound * ((det) >= 0.0 ? (det) : -(det));
  det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
  if ((det >= errbound) || (-det >= errbound))
  {
	return det;
  }

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  s1 = (GlobalMembersTriangle.REAL)(acxtail * bcy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * acxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - acxtail);
  ahi = c - abig;
  alo = acxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bcy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bcy);
  bhi = c - abig;
  blo = bcy - bhi;
  err1 = s1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  s0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  t1 = (GlobalMembersTriangle.REAL)(acytail * bcx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * acytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - acytail);
  ahi = c - abig;
  alo = acytail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bcx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bcx);
  bhi = c - abig;
  blo = bcx - bhi;
  err1 = t1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  t0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(s0 - t0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(s0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - t0;
  around = s0 - avirt;
  u[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _j = (GlobalMembersTriangle.REAL)(s1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_j - s1);
  avirt = _j - bvirt;
  bround = _i - bvirt;
  around = s1 - avirt;
  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(_0 - t1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - t1;
  around = _0 - avirt;
  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  u3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(u3 - _j);
  avirt = u3 - bvirt;
  bround = _i - bvirt;
  around = _j - avirt;
  u[2] = around + bround;
  u[3] = u3;
  C1length = GlobalMembersTriangle.fast_expansion_sum_zeroelim(4, B, 4, u, C1);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  s1 = (GlobalMembersTriangle.REAL)(acx * bcytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * acx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - acx);
  ahi = c - abig;
  alo = acx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bcytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bcytail);
  bhi = c - abig;
  blo = bcytail - bhi;
  err1 = s1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  s0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  t1 = (GlobalMembersTriangle.REAL)(acy * bcxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * acy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - acy);
  ahi = c - abig;
  alo = acy - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bcxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bcxtail);
  bhi = c - abig;
  blo = bcxtail - bhi;
  err1 = t1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  t0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(s0 - t0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(s0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - t0;
  around = s0 - avirt;
  u[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _j = (GlobalMembersTriangle.REAL)(s1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_j - s1);
  avirt = _j - bvirt;
  bround = _i - bvirt;
  around = s1 - avirt;
  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(_0 - t1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - t1;
  around = _0 - avirt;
  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  u3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(u3 - _j);
  avirt = u3 - bvirt;
  bround = _i - bvirt;
  around = _j - avirt;
  u[2] = around + bround;
  u[3] = u3;
  C2length = GlobalMembersTriangle.fast_expansion_sum_zeroelim(C1length, C1, 4, u, C2);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  s1 = (GlobalMembersTriangle.REAL)(acxtail * bcytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * acxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - acxtail);
  ahi = c - abig;
  alo = acxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bcytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bcytail);
  bhi = c - abig;
  blo = bcytail - bhi;
  err1 = s1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  s0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  t1 = (GlobalMembersTriangle.REAL)(acytail * bcxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * acytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - acytail);
  ahi = c - abig;
  alo = acytail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bcxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bcxtail);
  bhi = c - abig;
  blo = bcxtail - bhi;
  err1 = t1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  t0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(s0 - t0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(s0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - t0;
  around = s0 - avirt;
  u[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _j = (GlobalMembersTriangle.REAL)(s1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_j - s1);
  avirt = _j - bvirt;
  bround = _i - bvirt;
  around = s1 - avirt;
  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(_0 - t1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - t1;
  around = _0 - avirt;
  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  u3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(u3 - _j);
  avirt = u3 - bvirt;
  bround = _i - bvirt;
  around = _j - avirt;
  u[2] = around + bround;
  u[3] = u3;
  Dlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(C2length, C2, 4, u, D);

  return(D[Dlength - 1]);
}

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.counterclockwise(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL pa, GlobalMembersTriangle.REAL pb, GlobalMembersTriangle.REAL pc)
//#else
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.counterclockwise(m, b, pa, pb, pc)
mesh m;
behavior b;
GlobalMembersTriangle.REAL pa;
GlobalMembersTriangle.REAL pb;
GlobalMembersTriangle.REAL pc;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL detleft;
  GlobalMembersTriangle.REAL detright;
  GlobalMembersTriangle.REAL det;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL detsum;
  GlobalMembersTriangle.REAL errbound;

  m.counterclockcount++;

  detleft = (pa[0] - pc[0]) * (pb[1] - pc[1]);
  detright = (pa[1] - pc[1]) * (pb[0] - pc[0]);
  det = detleft - detright;

  if (b.noexact != 0)
  {
	return det;
  }

  if (detleft > 0.0)
  {
	if (detright <= 0.0)
	{
	  return det;
	}
	else
	{
	  detsum = detleft + detright;
	}
	}
  else if (detleft < 0.0)
  {
	if (detright >= 0.0)
	{
	  return det;
	}
	else
	{
	  detsum = -detleft - detright;
	}
	}
  else
  {
	return det;
  }

  errbound = GlobalMembersTriangle.ccwerrboundA * detsum;
  if ((det >= errbound) || (-det >= errbound))
  {
	return det;
  }

  return GlobalMembersTriangle.counterclockwiseadapt(pa, pb, pc, detsum);
}

//***************************************************************************
//                                                                           
//  incircle()   Return a positive value if the point pd lies inside the     
//               circle passing through pa, pb, and pc; a negative value if  
//               it lies outside; and zero if the four points are cocircular.
//               The points pa, pb, and pc must be in counterclockwise       
//               order, or the sign of the result will be reversed.          
//                                                                           
//  Uses exact arithmetic if necessary to ensure a correct answer.  The      
//  result returned is the determinant of a matrix.  This determinant is     
//  computed adaptively, in the sense that exact arithmetic is used only to  
//  the degree it is needed to ensure that the returned value has the        
//  correct sign.  Hence, this function is usually quite fast, but will run  
//  more slowly when the input points are cocircular or nearly so.           
//                                                                           
//  See my Robust Predicates paper for details.                              
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.incircleadapt(GlobalMembersTriangle.REAL pa, GlobalMembersTriangle.REAL pb, GlobalMembersTriangle.REAL pc, GlobalMembersTriangle.REAL * pd, GlobalMembersTriangle.REAL permanent)
//#else
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.incircleadapt(pa, pb, pc, pd, permanent)
GlobalMembersTriangle.REAL pa;
GlobalMembersTriangle.REAL pb;
GlobalMembersTriangle.REAL pc;
GlobalMembersTriangle.REAL pd;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL permanent;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL adx;
   GlobalMembersTriangle.REAL bdx;
   GlobalMembersTriangle.REAL cdx;
   GlobalMembersTriangle.REAL ady;
   GlobalMembersTriangle.REAL bdy;
   GlobalMembersTriangle.REAL cdy;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL det;
  GlobalMembersTriangle.REAL errbound;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bdxcdy1;
   GlobalMembersTriangle.REAL cdxbdy1;
   GlobalMembersTriangle.REAL cdxady1;
   GlobalMembersTriangle.REAL adxcdy1;
   GlobalMembersTriangle.REAL adxbdy1;
   GlobalMembersTriangle.REAL bdxady1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL bdxcdy0;
  GlobalMembersTriangle.REAL cdxbdy0;
  GlobalMembersTriangle.REAL cdxady0;
  GlobalMembersTriangle.REAL adxcdy0;
  GlobalMembersTriangle.REAL adxbdy0;
  GlobalMembersTriangle.REAL bdxady0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] bc = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] ca = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] ab = new GlobalMembersTriangle.REAL[4];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bc3;
   GlobalMembersTriangle.REAL ca3;
   GlobalMembersTriangle.REAL ab3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] axbc = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] axxbc = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] aybc = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] ayybc = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] adet = new GlobalMembersTriangle.REAL[32];
  int axbclen;
  int axxbclen;
  int aybclen;
  int ayybclen;
  int alen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] bxca = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] bxxca = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] byca = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] byyca = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] bdet = new GlobalMembersTriangle.REAL[32];
  int bxcalen;
  int bxxcalen;
  int bycalen;
  int byycalen;
  int blen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] cxab = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cxxab = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] cyab = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cyyab = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] cdet = new GlobalMembersTriangle.REAL[32];
  int cxablen;
  int cxxablen;
  int cyablen;
  int cyyablen;
  int clen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] abdet = new GlobalMembersTriangle.REAL[64];
  int ablen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] fin1 = new GlobalMembersTriangle.REAL[1152];
  GlobalMembersTriangle.REAL[] fin2 = new GlobalMembersTriangle.REAL[1152];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL finnow;
  GlobalMembersTriangle.REAL finother;
  GlobalMembersTriangle.REAL finswap;
  int finlength;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL adxtail;
  GlobalMembersTriangle.REAL bdxtail;
  GlobalMembersTriangle.REAL cdxtail;
  GlobalMembersTriangle.REAL adytail;
  GlobalMembersTriangle.REAL bdytail;
  GlobalMembersTriangle.REAL cdytail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL adxadx1;
   GlobalMembersTriangle.REAL adyady1;
   GlobalMembersTriangle.REAL bdxbdx1;
   GlobalMembersTriangle.REAL bdybdy1;
   GlobalMembersTriangle.REAL cdxcdx1;
   GlobalMembersTriangle.REAL cdycdy1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL adxadx0;
  GlobalMembersTriangle.REAL adyady0;
  GlobalMembersTriangle.REAL bdxbdx0;
  GlobalMembersTriangle.REAL bdybdy0;
  GlobalMembersTriangle.REAL cdxcdx0;
  GlobalMembersTriangle.REAL cdycdy0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] aa = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] bb = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] cc = new GlobalMembersTriangle.REAL[4];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL aa3;
   GlobalMembersTriangle.REAL bb3;
   GlobalMembersTriangle.REAL cc3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL ti1;
   GlobalMembersTriangle.REAL tj1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL ti0;
  GlobalMembersTriangle.REAL tj0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] u = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] v = new GlobalMembersTriangle.REAL[4];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL u3;
   GlobalMembersTriangle.REAL v3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] temp8 = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] temp16a = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] temp16b = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] temp16c = new GlobalMembersTriangle.REAL[16];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] temp32a = new GlobalMembersTriangle.REAL[32];
  GlobalMembersTriangle.REAL[] temp32b = new GlobalMembersTriangle.REAL[32];
  GlobalMembersTriangle.REAL[] temp48 = new GlobalMembersTriangle.REAL[48];
  GlobalMembersTriangle.REAL[] temp64 = new GlobalMembersTriangle.REAL[64];
  int temp8len;
  int temp16alen;
  int temp16blen;
  int temp16clen;
  int temp32alen;
  int temp32blen;
  int temp48len;
  int temp64len;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] axtbb = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] axtcc = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] aytbb = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] aytcc = new GlobalMembersTriangle.REAL[8];
  int axtbblen;
  int axtcclen;
  int aytbblen;
  int aytcclen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] bxtaa = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] bxtcc = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] bytaa = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] bytcc = new GlobalMembersTriangle.REAL[8];
  int bxtaalen;
  int bxtcclen;
  int bytaalen;
  int bytcclen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] cxtaa = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cxtbb = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cytaa = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cytbb = new GlobalMembersTriangle.REAL[8];
  int cxtaalen;
  int cxtbblen;
  int cytaalen;
  int cytbblen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] axtbc = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] aytbc = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] bxtca = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] bytca = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cxtab = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cytab = new GlobalMembersTriangle.REAL[8];
  int axtbclen = 0;
  int aytbclen = 0;
  int bxtcalen = 0;
  int bytcalen = 0;
  int cxtablen = 0;
  int cytablen = 0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] axtbct = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] aytbct = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] bxtcat = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] bytcat = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] cxtabt = new GlobalMembersTriangle.REAL[16];
  GlobalMembersTriangle.REAL[] cytabt = new GlobalMembersTriangle.REAL[16];
  int axtbctlen;
  int aytbctlen;
  int bxtcatlen;
  int bytcatlen;
  int cxtabtlen;
  int cytabtlen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] axtbctt = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] aytbctt = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] bxtcatt = new GlobalMembersTriangle.REAL[8];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] bytcatt = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cxtabtt = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cytabtt = new GlobalMembersTriangle.REAL[8];
  int axtbcttlen;
  int aytbcttlen;
  int bxtcattlen;
  int bytcattlen;
  int cxtabttlen;
  int cytabttlen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] abt = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] bct = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cat = new GlobalMembersTriangle.REAL[8];
  int abtlen;
  int bctlen;
  int catlen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] abtt = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] bctt = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] catt = new GlobalMembersTriangle.REAL[4];
  int abttlen;
  int bcttlen;
  int cattlen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL abtt3;
   GlobalMembersTriangle.REAL bctt3;
   GlobalMembersTriangle.REAL catt3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL negate;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bvirt;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL avirt;
  GlobalMembersTriangle.REAL bround;
  GlobalMembersTriangle.REAL around;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL c;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL abig;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL ahi;
  GlobalMembersTriangle.REAL alo;
  GlobalMembersTriangle.REAL bhi;
  GlobalMembersTriangle.REAL blo;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL err1;
  GlobalMembersTriangle.REAL err2;
  GlobalMembersTriangle.REAL err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL _i;
   GlobalMembersTriangle.REAL _j;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL _0;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  adx = (GlobalMembersTriangle.REAL)(pa[0] - pd[0]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bdx = (GlobalMembersTriangle.REAL)(pb[0] - pd[0]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  cdx = (GlobalMembersTriangle.REAL)(pc[0] - pd[0]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  ady = (GlobalMembersTriangle.REAL)(pa[1] - pd[1]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bdy = (GlobalMembersTriangle.REAL)(pb[1] - pd[1]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  cdy = (GlobalMembersTriangle.REAL)(pc[1] - pd[1]);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bdxcdy1 = (GlobalMembersTriangle.REAL)(bdx * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bdx);
  ahi = c - abig;
  alo = bdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - cdy);
  bhi = c - abig;
  blo = cdy - bhi;
  err1 = bdxcdy1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  bdxcdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  cdxbdy1 = (GlobalMembersTriangle.REAL)(cdx * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - cdx);
  ahi = c - abig;
  alo = cdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bdy);
  bhi = c - abig;
  blo = bdy - bhi;
  err1 = cdxbdy1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  cdxbdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(bdxcdy0 - cdxbdy0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(bdxcdy0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - cdxbdy0;
  around = bdxcdy0 - avirt;
  bc[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _j = (GlobalMembersTriangle.REAL)(bdxcdy1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_j - bdxcdy1);
  avirt = _j - bvirt;
  bround = _i - bvirt;
  around = bdxcdy1 - avirt;
  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(_0 - cdxbdy1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - cdxbdy1;
  around = _0 - avirt;
  bc[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bc3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(bc3 - _j);
  avirt = bc3 - bvirt;
  bround = _i - bvirt;
  around = _j - avirt;
  bc[2] = around + bround;
  bc[3] = bc3;
  axbclen = GlobalMembersTriangle.scale_expansion_zeroelim(4, bc, adx, axbc);
  axxbclen = GlobalMembersTriangle.scale_expansion_zeroelim(axbclen, axbc, adx, axxbc);
  aybclen = GlobalMembersTriangle.scale_expansion_zeroelim(4, bc, ady, aybc);
  ayybclen = GlobalMembersTriangle.scale_expansion_zeroelim(aybclen, aybc, ady, ayybc);
  alen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(axxbclen, axxbc, ayybclen, ayybc, adet);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  cdxady1 = (GlobalMembersTriangle.REAL)(cdx * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - cdx);
  ahi = c - abig;
  alo = cdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - ady);
  bhi = c - abig;
  blo = ady - bhi;
  err1 = cdxady1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  cdxady0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  adxcdy1 = (GlobalMembersTriangle.REAL)(adx * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - adx);
  ahi = c - abig;
  alo = adx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - cdy);
  bhi = c - abig;
  blo = cdy - bhi;
  err1 = adxcdy1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  adxcdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(cdxady0 - adxcdy0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(cdxady0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - adxcdy0;
  around = cdxady0 - avirt;
  ca[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _j = (GlobalMembersTriangle.REAL)(cdxady1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_j - cdxady1);
  avirt = _j - bvirt;
  bround = _i - bvirt;
  around = cdxady1 - avirt;
  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(_0 - adxcdy1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - adxcdy1;
  around = _0 - avirt;
  ca[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  ca3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(ca3 - _j);
  avirt = ca3 - bvirt;
  bround = _i - bvirt;
  around = _j - avirt;
  ca[2] = around + bround;
  ca[3] = ca3;
  bxcalen = GlobalMembersTriangle.scale_expansion_zeroelim(4, ca, bdx, bxca);
  bxxcalen = GlobalMembersTriangle.scale_expansion_zeroelim(bxcalen, bxca, bdx, bxxca);
  bycalen = GlobalMembersTriangle.scale_expansion_zeroelim(4, ca, bdy, byca);
  byycalen = GlobalMembersTriangle.scale_expansion_zeroelim(bycalen, byca, bdy, byyca);
  blen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(bxxcalen, bxxca, byycalen, byyca, bdet);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  adxbdy1 = (GlobalMembersTriangle.REAL)(adx * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - adx);
  ahi = c - abig;
  alo = adx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bdy);
  bhi = c - abig;
  blo = bdy - bhi;
  err1 = adxbdy1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  adxbdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bdxady1 = (GlobalMembersTriangle.REAL)(bdx * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bdx);
  ahi = c - abig;
  alo = bdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - ady);
  bhi = c - abig;
  blo = ady - bhi;
  err1 = bdxady1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  bdxady0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(adxbdy0 - bdxady0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(adxbdy0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - bdxady0;
  around = adxbdy0 - avirt;
  ab[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _j = (GlobalMembersTriangle.REAL)(adxbdy1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_j - adxbdy1);
  avirt = _j - bvirt;
  bround = _i - bvirt;
  around = adxbdy1 - avirt;
  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(_0 - bdxady1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - bdxady1;
  around = _0 - avirt;
  ab[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  ab3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(ab3 - _j);
  avirt = ab3 - bvirt;
  bround = _i - bvirt;
  around = _j - avirt;
  ab[2] = around + bround;
  ab[3] = ab3;
  cxablen = GlobalMembersTriangle.scale_expansion_zeroelim(4, ab, cdx, cxab);
  cxxablen = GlobalMembersTriangle.scale_expansion_zeroelim(cxablen, cxab, cdx, cxxab);
  cyablen = GlobalMembersTriangle.scale_expansion_zeroelim(4, ab, cdy, cyab);
  cyyablen = GlobalMembersTriangle.scale_expansion_zeroelim(cyablen, cyab, cdy, cyyab);
  clen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(cxxablen, cxxab, cyyablen, cyyab, cdet);

  ablen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(alen, adet, blen, bdet, abdet);
  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(ablen, abdet, clen, cdet, fin1);

  det = GlobalMembersTriangle.estimate(finlength, fin1);
  errbound = GlobalMembersTriangle.iccerrboundB * permanent;
  if ((det >= errbound) || (-det >= errbound))
  {
	return det;
  }

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pa[0] - adx);
  avirt = adx + bvirt;
  bround = bvirt - pd[0];
  around = pa[0] - avirt;
  adxtail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pa[1] - ady);
  avirt = ady + bvirt;
  bround = bvirt - pd[1];
  around = pa[1] - avirt;
  adytail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pb[0] - bdx);
  avirt = bdx + bvirt;
  bround = bvirt - pd[0];
  around = pb[0] - avirt;
  bdxtail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pb[1] - bdy);
  avirt = bdy + bvirt;
  bround = bvirt - pd[1];
  around = pb[1] - avirt;
  bdytail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pc[0] - cdx);
  avirt = cdx + bvirt;
  bround = bvirt - pd[0];
  around = pc[0] - avirt;
  cdxtail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pc[1] - cdy);
  avirt = cdy + bvirt;
  bround = bvirt - pd[1];
  around = pc[1] - avirt;
  cdytail = around + bround;
  if ((adxtail == 0.0) && (bdxtail == 0.0) && (cdxtail == 0.0) && (adytail == 0.0) && (bdytail == 0.0) && (cdytail == 0.0))
  {
	return det;
  }

  errbound = GlobalMembersTriangle.iccerrboundC * permanent + GlobalMembersTriangle.resulterrbound * ((det) >= 0.0 ? (det) : -(det));
  det += ((adx * adx + ady * ady) * ((bdx * cdytail + cdy * bdxtail) - (bdy * cdxtail + cdx * bdytail)) + 2.0 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx)) + ((bdx * bdx + bdy * bdy) * ((cdx * adytail + ady * cdxtail) - (cdy * adxtail + adx * cdytail)) + 2.0 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx)) + ((cdx * cdx + cdy * cdy) * ((adx * bdytail + bdy * adxtail) - (ady * bdxtail + bdx * adytail)) + 2.0 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));
  if ((det >= errbound) || (-det >= errbound))
  {
	return det;
  }

  finnow = fin1;
  finother = fin2;

  if ((bdxtail != 0.0) || (bdytail != 0.0) || (cdxtail != 0.0) || (cdytail != 0.0))
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	adxadx1 = (GlobalMembersTriangle.REAL)(adx * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	abig = (GlobalMembersTriangle.REAL)(c - adx);
	ahi = c - abig;
	alo = adx - ahi;
	err1 = adxadx1 - (ahi * ahi);
	err3 = err1 - ((ahi + ahi) * alo);
	adxadx0 = (alo * alo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	adyady1 = (GlobalMembersTriangle.REAL)(ady * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	abig = (GlobalMembersTriangle.REAL)(c - ady);
	ahi = c - abig;
	alo = ady - ahi;
	err1 = adyady1 - (ahi * ahi);
	err3 = err1 - ((ahi + ahi) * alo);
	adyady0 = (alo * alo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	_i = (GlobalMembersTriangle.REAL)(adxadx0 + adyady0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(_i - adxadx0);
	avirt = _i - bvirt;
	bround = adyady0 - bvirt;
	around = adxadx0 - avirt;
	aa[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	_j = (GlobalMembersTriangle.REAL)(adxadx1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(_j - adxadx1);
	avirt = _j - bvirt;
	bround = _i - bvirt;
	around = adxadx1 - avirt;
	_0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	_i = (GlobalMembersTriangle.REAL)(_0 + adyady1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(_i - _0);
	avirt = _i - bvirt;
	bround = adyady1 - bvirt;
	around = _0 - avirt;
	aa[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	aa3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(aa3 - _j);
	avirt = aa3 - bvirt;
	bround = _i - bvirt;
	around = _j - avirt;
	aa[2] = around + bround;
	aa[3] = aa3;
  }
  if ((cdxtail != 0.0) || (cdytail != 0.0) || (adxtail != 0.0) || (adytail != 0.0))
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bdxbdx1 = (GlobalMembersTriangle.REAL)(bdx * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	abig = (GlobalMembersTriangle.REAL)(c - bdx);
	ahi = c - abig;
	alo = bdx - ahi;
	err1 = bdxbdx1 - (ahi * ahi);
	err3 = err1 - ((ahi + ahi) * alo);
	bdxbdx0 = (alo * alo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bdybdy1 = (GlobalMembersTriangle.REAL)(bdy * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	abig = (GlobalMembersTriangle.REAL)(c - bdy);
	ahi = c - abig;
	alo = bdy - ahi;
	err1 = bdybdy1 - (ahi * ahi);
	err3 = err1 - ((ahi + ahi) * alo);
	bdybdy0 = (alo * alo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	_i = (GlobalMembersTriangle.REAL)(bdxbdx0 + bdybdy0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(_i - bdxbdx0);
	avirt = _i - bvirt;
	bround = bdybdy0 - bvirt;
	around = bdxbdx0 - avirt;
	bb[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	_j = (GlobalMembersTriangle.REAL)(bdxbdx1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(_j - bdxbdx1);
	avirt = _j - bvirt;
	bround = _i - bvirt;
	around = bdxbdx1 - avirt;
	_0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	_i = (GlobalMembersTriangle.REAL)(_0 + bdybdy1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(_i - _0);
	avirt = _i - bvirt;
	bround = bdybdy1 - bvirt;
	around = _0 - avirt;
	bb[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bb3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(bb3 - _j);
	avirt = bb3 - bvirt;
	bround = _i - bvirt;
	around = _j - avirt;
	bb[2] = around + bround;
	bb[3] = bb3;
  }
  if ((adxtail != 0.0) || (adytail != 0.0) || (bdxtail != 0.0) || (bdytail != 0.0))
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	cdxcdx1 = (GlobalMembersTriangle.REAL)(cdx * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	abig = (GlobalMembersTriangle.REAL)(c - cdx);
	ahi = c - abig;
	alo = cdx - ahi;
	err1 = cdxcdx1 - (ahi * ahi);
	err3 = err1 - ((ahi + ahi) * alo);
	cdxcdx0 = (alo * alo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	cdycdy1 = (GlobalMembersTriangle.REAL)(cdy * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	abig = (GlobalMembersTriangle.REAL)(c - cdy);
	ahi = c - abig;
	alo = cdy - ahi;
	err1 = cdycdy1 - (ahi * ahi);
	err3 = err1 - ((ahi + ahi) * alo);
	cdycdy0 = (alo * alo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	_i = (GlobalMembersTriangle.REAL)(cdxcdx0 + cdycdy0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(_i - cdxcdx0);
	avirt = _i - bvirt;
	bround = cdycdy0 - bvirt;
	around = cdxcdx0 - avirt;
	cc[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	_j = (GlobalMembersTriangle.REAL)(cdxcdx1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(_j - cdxcdx1);
	avirt = _j - bvirt;
	bround = _i - bvirt;
	around = cdxcdx1 - avirt;
	_0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	_i = (GlobalMembersTriangle.REAL)(_0 + cdycdy1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(_i - _0);
	avirt = _i - bvirt;
	bround = cdycdy1 - bvirt;
	around = _0 - avirt;
	cc[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	cc3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	bvirt = (GlobalMembersTriangle.REAL)(cc3 - _j);
	avirt = cc3 - bvirt;
	bround = _i - bvirt;
	around = _j - avirt;
	cc[2] = around + bround;
	cc[3] = cc3;
  }

  if (adxtail != 0.0)
  {
	axtbclen = GlobalMembersTriangle.scale_expansion_zeroelim(4, bc, adxtail, axtbc);
	temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(axtbclen, axtbc, 2.0 * adx, temp16a);

	axtcclen = GlobalMembersTriangle.scale_expansion_zeroelim(4, cc, adxtail, axtcc);
	temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(axtcclen, axtcc, bdy, temp16b);

	axtbblen = GlobalMembersTriangle.scale_expansion_zeroelim(4, bb, adxtail, axtbb);
	temp16clen = GlobalMembersTriangle.scale_expansion_zeroelim(axtbblen, axtbb, -cdy, temp16c);

	temp32alen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32a);
	temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16clen, temp16c, temp32alen, temp32a, temp48);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }
  if (adytail != 0.0)
  {
	aytbclen = GlobalMembersTriangle.scale_expansion_zeroelim(4, bc, adytail, aytbc);
	temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(aytbclen, aytbc, 2.0 * ady, temp16a);

	aytbblen = GlobalMembersTriangle.scale_expansion_zeroelim(4, bb, adytail, aytbb);
	temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(aytbblen, aytbb, cdx, temp16b);

	aytcclen = GlobalMembersTriangle.scale_expansion_zeroelim(4, cc, adytail, aytcc);
	temp16clen = GlobalMembersTriangle.scale_expansion_zeroelim(aytcclen, aytcc, -bdx, temp16c);

	temp32alen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32a);
	temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16clen, temp16c, temp32alen, temp32a, temp48);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }
  if (bdxtail != 0.0)
  {
	bxtcalen = GlobalMembersTriangle.scale_expansion_zeroelim(4, ca, bdxtail, bxtca);
	temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(bxtcalen, bxtca, 2.0 * bdx, temp16a);

	bxtaalen = GlobalMembersTriangle.scale_expansion_zeroelim(4, aa, bdxtail, bxtaa);
	temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(bxtaalen, bxtaa, cdy, temp16b);

	bxtcclen = GlobalMembersTriangle.scale_expansion_zeroelim(4, cc, bdxtail, bxtcc);
	temp16clen = GlobalMembersTriangle.scale_expansion_zeroelim(bxtcclen, bxtcc, -ady, temp16c);

	temp32alen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32a);
	temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16clen, temp16c, temp32alen, temp32a, temp48);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }
  if (bdytail != 0.0)
  {
	bytcalen = GlobalMembersTriangle.scale_expansion_zeroelim(4, ca, bdytail, bytca);
	temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(bytcalen, bytca, 2.0 * bdy, temp16a);

	bytcclen = GlobalMembersTriangle.scale_expansion_zeroelim(4, cc, bdytail, bytcc);
	temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(bytcclen, bytcc, adx, temp16b);

	bytaalen = GlobalMembersTriangle.scale_expansion_zeroelim(4, aa, bdytail, bytaa);
	temp16clen = GlobalMembersTriangle.scale_expansion_zeroelim(bytaalen, bytaa, -cdx, temp16c);

	temp32alen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32a);
	temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16clen, temp16c, temp32alen, temp32a, temp48);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }
  if (cdxtail != 0.0)
  {
	cxtablen = GlobalMembersTriangle.scale_expansion_zeroelim(4, ab, cdxtail, cxtab);
	temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(cxtablen, cxtab, 2.0 * cdx, temp16a);

	cxtbblen = GlobalMembersTriangle.scale_expansion_zeroelim(4, bb, cdxtail, cxtbb);
	temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(cxtbblen, cxtbb, ady, temp16b);

	cxtaalen = GlobalMembersTriangle.scale_expansion_zeroelim(4, aa, cdxtail, cxtaa);
	temp16clen = GlobalMembersTriangle.scale_expansion_zeroelim(cxtaalen, cxtaa, -bdy, temp16c);

	temp32alen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32a);
	temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16clen, temp16c, temp32alen, temp32a, temp48);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }
  if (cdytail != 0.0)
  {
	cytablen = GlobalMembersTriangle.scale_expansion_zeroelim(4, ab, cdytail, cytab);
	temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(cytablen, cytab, 2.0 * cdy, temp16a);

	cytaalen = GlobalMembersTriangle.scale_expansion_zeroelim(4, aa, cdytail, cytaa);
	temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(cytaalen, cytaa, bdx, temp16b);

	cytbblen = GlobalMembersTriangle.scale_expansion_zeroelim(4, bb, cdytail, cytbb);
	temp16clen = GlobalMembersTriangle.scale_expansion_zeroelim(cytbblen, cytbb, -adx, temp16c);

	temp32alen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32a);
	temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16clen, temp16c, temp32alen, temp32a, temp48);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }

  if ((adxtail != 0.0) || (adytail != 0.0))
  {
	if ((bdxtail != 0.0) || (bdytail != 0.0) || (cdxtail != 0.0) || (cdytail != 0.0))
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ti1 = (GlobalMembersTriangle.REAL)(bdxtail * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxtail);
	  ahi = c - abig;
	  alo = bdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdy);
	  bhi = c - abig;
	  blo = cdy - bhi;
	  err1 = ti1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ti0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  tj1 = (GlobalMembersTriangle.REAL)(bdx * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdx);
	  ahi = c - abig;
	  alo = bdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdytail);
	  bhi = c - abig;
	  blo = cdytail - bhi;
	  err1 = tj1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  tj0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(ti0 + tj0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - ti0);
	  avirt = _i - bvirt;
	  bround = tj0 - bvirt;
	  around = ti0 - avirt;
	  u[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(ti1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - ti1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = ti1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 + tj1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - _0);
	  avirt = _i - bvirt;
	  bround = tj1 - bvirt;
	  around = _0 - avirt;
	  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  u3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(u3 - _j);
	  avirt = u3 - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  u[2] = around + bround;
	  u[3] = u3;
	  negate = -bdy;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ti1 = (GlobalMembersTriangle.REAL)(cdxtail * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxtail);
	  ahi = c - abig;
	  alo = cdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  bhi = c - abig;
	  blo = negate - bhi;
	  err1 = ti1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ti0 = (alo * blo) - err3;
	  negate = -bdytail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  tj1 = (GlobalMembersTriangle.REAL)(cdx * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdx);
	  ahi = c - abig;
	  alo = cdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  bhi = c - abig;
	  blo = negate - bhi;
	  err1 = tj1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  tj0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(ti0 + tj0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - ti0);
	  avirt = _i - bvirt;
	  bround = tj0 - bvirt;
	  around = ti0 - avirt;
	  v[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(ti1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - ti1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = ti1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 + tj1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - _0);
	  avirt = _i - bvirt;
	  bround = tj1 - bvirt;
	  around = _0 - avirt;
	  v[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  v3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(v3 - _j);
	  avirt = v3 - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  v[2] = around + bround;
	  v[3] = v3;
	  bctlen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(4, u, 4, v, bct);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ti1 = (GlobalMembersTriangle.REAL)(bdxtail * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxtail);
	  ahi = c - abig;
	  alo = bdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdytail);
	  bhi = c - abig;
	  blo = cdytail - bhi;
	  err1 = ti1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ti0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  tj1 = (GlobalMembersTriangle.REAL)(cdxtail * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxtail);
	  ahi = c - abig;
	  alo = cdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdytail);
	  bhi = c - abig;
	  blo = bdytail - bhi;
	  err1 = tj1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  tj0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(ti0 - tj0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(ti0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - tj0;
	  around = ti0 - avirt;
	  bctt[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(ti1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - ti1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = ti1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 - tj1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - tj1;
	  around = _0 - avirt;
	  bctt[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bctt3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(bctt3 - _j);
	  avirt = bctt3 - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  bctt[2] = around + bround;
	  bctt[3] = bctt3;
	  bcttlen = 4;
	}
	else
	{
	  bct[0] = 0.0;
	  bctlen = 1;
	  bctt[0] = 0.0;
	  bcttlen = 1;
	}

	if (adxtail != 0.0)
	{
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(axtbclen, axtbc, adxtail, temp16a);
	  axtbctlen = GlobalMembersTriangle.scale_expansion_zeroelim(bctlen, bct, adxtail, axtbct);
	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(axtbctlen, axtbct, 2.0 * adx, temp32a);
	  temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp32alen, temp32a, temp48);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	  if (bdytail != 0.0)
	  {
		temp8len = GlobalMembersTriangle.scale_expansion_zeroelim(4, cc, adxtail, temp8);
		temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(temp8len, temp8, bdytail, temp16a);
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp16alen, temp16a, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }
	  if (cdytail != 0.0)
	  {
		temp8len = GlobalMembersTriangle.scale_expansion_zeroelim(4, bb, -adxtail, temp8);
		temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(temp8len, temp8, cdytail, temp16a);
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp16alen, temp16a, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }

	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(axtbctlen, axtbct, adxtail, temp32a);
	  axtbcttlen = GlobalMembersTriangle.scale_expansion_zeroelim(bcttlen, bctt, adxtail, axtbctt);
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(axtbcttlen, axtbctt, 2.0 * adx, temp16a);
	  temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(axtbcttlen, axtbctt, adxtail, temp16b);
	  temp32blen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32b);
	  temp64len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp32alen, temp32a, temp32blen, temp32b, temp64);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp64len, temp64, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	}
	if (adytail != 0.0)
	{
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(aytbclen, aytbc, adytail, temp16a);
	  aytbctlen = GlobalMembersTriangle.scale_expansion_zeroelim(bctlen, bct, adytail, aytbct);
	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(aytbctlen, aytbct, 2.0 * ady, temp32a);
	  temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp32alen, temp32a, temp48);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;


	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(aytbctlen, aytbct, adytail, temp32a);
	  aytbcttlen = GlobalMembersTriangle.scale_expansion_zeroelim(bcttlen, bctt, adytail, aytbctt);
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(aytbcttlen, aytbctt, 2.0 * ady, temp16a);
	  temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(aytbcttlen, aytbctt, adytail, temp16b);
	  temp32blen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32b);
	  temp64len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp32alen, temp32a, temp32blen, temp32b, temp64);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp64len, temp64, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	}
  }
  if ((bdxtail != 0.0) || (bdytail != 0.0))
  {
	if ((cdxtail != 0.0) || (cdytail != 0.0) || (adxtail != 0.0) || (adytail != 0.0))
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ti1 = (GlobalMembersTriangle.REAL)(cdxtail * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxtail);
	  ahi = c - abig;
	  alo = cdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - ady);
	  bhi = c - abig;
	  blo = ady - bhi;
	  err1 = ti1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ti0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  tj1 = (GlobalMembersTriangle.REAL)(cdx * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdx);
	  ahi = c - abig;
	  alo = cdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adytail);
	  bhi = c - abig;
	  blo = adytail - bhi;
	  err1 = tj1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  tj0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(ti0 + tj0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - ti0);
	  avirt = _i - bvirt;
	  bround = tj0 - bvirt;
	  around = ti0 - avirt;
	  u[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(ti1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - ti1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = ti1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 + tj1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - _0);
	  avirt = _i - bvirt;
	  bround = tj1 - bvirt;
	  around = _0 - avirt;
	  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  u3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(u3 - _j);
	  avirt = u3 - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  u[2] = around + bround;
	  u[3] = u3;
	  negate = -cdy;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ti1 = (GlobalMembersTriangle.REAL)(adxtail * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxtail);
	  ahi = c - abig;
	  alo = adxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  bhi = c - abig;
	  blo = negate - bhi;
	  err1 = ti1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ti0 = (alo * blo) - err3;
	  negate = -cdytail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  tj1 = (GlobalMembersTriangle.REAL)(adx * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adx);
	  ahi = c - abig;
	  alo = adx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  bhi = c - abig;
	  blo = negate - bhi;
	  err1 = tj1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  tj0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(ti0 + tj0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - ti0);
	  avirt = _i - bvirt;
	  bround = tj0 - bvirt;
	  around = ti0 - avirt;
	  v[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(ti1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - ti1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = ti1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 + tj1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - _0);
	  avirt = _i - bvirt;
	  bround = tj1 - bvirt;
	  around = _0 - avirt;
	  v[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  v3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(v3 - _j);
	  avirt = v3 - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  v[2] = around + bround;
	  v[3] = v3;
	  catlen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(4, u, 4, v, cat);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ti1 = (GlobalMembersTriangle.REAL)(cdxtail * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxtail);
	  ahi = c - abig;
	  alo = cdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adytail);
	  bhi = c - abig;
	  blo = adytail - bhi;
	  err1 = ti1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ti0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  tj1 = (GlobalMembersTriangle.REAL)(adxtail * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxtail);
	  ahi = c - abig;
	  alo = adxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdytail);
	  bhi = c - abig;
	  blo = cdytail - bhi;
	  err1 = tj1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  tj0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(ti0 - tj0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(ti0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - tj0;
	  around = ti0 - avirt;
	  catt[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(ti1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - ti1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = ti1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 - tj1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - tj1;
	  around = _0 - avirt;
	  catt[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  catt3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(catt3 - _j);
	  avirt = catt3 - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  catt[2] = around + bround;
	  catt[3] = catt3;
	  cattlen = 4;
	}
	else
	{
	  cat[0] = 0.0;
	  catlen = 1;
	  catt[0] = 0.0;
	  cattlen = 1;
	}

	if (bdxtail != 0.0)
	{
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(bxtcalen, bxtca, bdxtail, temp16a);
	  bxtcatlen = GlobalMembersTriangle.scale_expansion_zeroelim(catlen, cat, bdxtail, bxtcat);
	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(bxtcatlen, bxtcat, 2.0 * bdx, temp32a);
	  temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp32alen, temp32a, temp48);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	  if (cdytail != 0.0)
	  {
		temp8len = GlobalMembersTriangle.scale_expansion_zeroelim(4, aa, bdxtail, temp8);
		temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(temp8len, temp8, cdytail, temp16a);
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp16alen, temp16a, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }
	  if (adytail != 0.0)
	  {
		temp8len = GlobalMembersTriangle.scale_expansion_zeroelim(4, cc, -bdxtail, temp8);
		temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(temp8len, temp8, adytail, temp16a);
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp16alen, temp16a, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }

	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(bxtcatlen, bxtcat, bdxtail, temp32a);
	  bxtcattlen = GlobalMembersTriangle.scale_expansion_zeroelim(cattlen, catt, bdxtail, bxtcatt);
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(bxtcattlen, bxtcatt, 2.0 * bdx, temp16a);
	  temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(bxtcattlen, bxtcatt, bdxtail, temp16b);
	  temp32blen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32b);
	  temp64len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp32alen, temp32a, temp32blen, temp32b, temp64);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp64len, temp64, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	}
	if (bdytail != 0.0)
	{
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(bytcalen, bytca, bdytail, temp16a);
	  bytcatlen = GlobalMembersTriangle.scale_expansion_zeroelim(catlen, cat, bdytail, bytcat);
	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(bytcatlen, bytcat, 2.0 * bdy, temp32a);
	  temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp32alen, temp32a, temp48);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;


	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(bytcatlen, bytcat, bdytail, temp32a);
	  bytcattlen = GlobalMembersTriangle.scale_expansion_zeroelim(cattlen, catt, bdytail, bytcatt);
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(bytcattlen, bytcatt, 2.0 * bdy, temp16a);
	  temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(bytcattlen, bytcatt, bdytail, temp16b);
	  temp32blen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32b);
	  temp64len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp32alen, temp32a, temp32blen, temp32b, temp64);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp64len, temp64, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	}
  }
  if ((cdxtail != 0.0) || (cdytail != 0.0))
  {
	if ((adxtail != 0.0) || (adytail != 0.0) || (bdxtail != 0.0) || (bdytail != 0.0))
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ti1 = (GlobalMembersTriangle.REAL)(adxtail * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxtail);
	  ahi = c - abig;
	  alo = adxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdy);
	  bhi = c - abig;
	  blo = bdy - bhi;
	  err1 = ti1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ti0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  tj1 = (GlobalMembersTriangle.REAL)(adx * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adx);
	  ahi = c - abig;
	  alo = adx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdytail);
	  bhi = c - abig;
	  blo = bdytail - bhi;
	  err1 = tj1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  tj0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(ti0 + tj0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - ti0);
	  avirt = _i - bvirt;
	  bround = tj0 - bvirt;
	  around = ti0 - avirt;
	  u[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(ti1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - ti1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = ti1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 + tj1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - _0);
	  avirt = _i - bvirt;
	  bround = tj1 - bvirt;
	  around = _0 - avirt;
	  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  u3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(u3 - _j);
	  avirt = u3 - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  u[2] = around + bround;
	  u[3] = u3;
	  negate = -ady;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ti1 = (GlobalMembersTriangle.REAL)(bdxtail * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxtail);
	  ahi = c - abig;
	  alo = bdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  bhi = c - abig;
	  blo = negate - bhi;
	  err1 = ti1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ti0 = (alo * blo) - err3;
	  negate = -adytail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  tj1 = (GlobalMembersTriangle.REAL)(bdx * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdx);
	  ahi = c - abig;
	  alo = bdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  bhi = c - abig;
	  blo = negate - bhi;
	  err1 = tj1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  tj0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(ti0 + tj0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - ti0);
	  avirt = _i - bvirt;
	  bround = tj0 - bvirt;
	  around = ti0 - avirt;
	  v[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(ti1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - ti1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = ti1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 + tj1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_i - _0);
	  avirt = _i - bvirt;
	  bround = tj1 - bvirt;
	  around = _0 - avirt;
	  v[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  v3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(v3 - _j);
	  avirt = v3 - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  v[2] = around + bround;
	  v[3] = v3;
	  abtlen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(4, u, 4, v, abt);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ti1 = (GlobalMembersTriangle.REAL)(adxtail * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxtail);
	  ahi = c - abig;
	  alo = adxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdytail);
	  bhi = c - abig;
	  blo = bdytail - bhi;
	  err1 = ti1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ti0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  tj1 = (GlobalMembersTriangle.REAL)(bdxtail * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxtail);
	  ahi = c - abig;
	  alo = bdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adytail);
	  bhi = c - abig;
	  blo = adytail - bhi;
	  err1 = tj1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  tj0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(ti0 - tj0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(ti0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - tj0;
	  around = ti0 - avirt;
	  abtt[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(ti1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - ti1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = ti1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 - tj1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - tj1;
	  around = _0 - avirt;
	  abtt[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abtt3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(abtt3 - _j);
	  avirt = abtt3 - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  abtt[2] = around + bround;
	  abtt[3] = abtt3;
	  abttlen = 4;
	}
	else
	{
	  abt[0] = 0.0;
	  abtlen = 1;
	  abtt[0] = 0.0;
	  abttlen = 1;
	}

	if (cdxtail != 0.0)
	{
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(cxtablen, cxtab, cdxtail, temp16a);
	  cxtabtlen = GlobalMembersTriangle.scale_expansion_zeroelim(abtlen, abt, cdxtail, cxtabt);
	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(cxtabtlen, cxtabt, 2.0 * cdx, temp32a);
	  temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp32alen, temp32a, temp48);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	  if (adytail != 0.0)
	  {
		temp8len = GlobalMembersTriangle.scale_expansion_zeroelim(4, bb, cdxtail, temp8);
		temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(temp8len, temp8, adytail, temp16a);
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp16alen, temp16a, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }
	  if (bdytail != 0.0)
	  {
		temp8len = GlobalMembersTriangle.scale_expansion_zeroelim(4, aa, -cdxtail, temp8);
		temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(temp8len, temp8, bdytail, temp16a);
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp16alen, temp16a, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }

	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(cxtabtlen, cxtabt, cdxtail, temp32a);
	  cxtabttlen = GlobalMembersTriangle.scale_expansion_zeroelim(abttlen, abtt, cdxtail, cxtabtt);
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(cxtabttlen, cxtabtt, 2.0 * cdx, temp16a);
	  temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(cxtabttlen, cxtabtt, cdxtail, temp16b);
	  temp32blen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32b);
	  temp64len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp32alen, temp32a, temp32blen, temp32b, temp64);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp64len, temp64, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	}
	if (cdytail != 0.0)
	{
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(cytablen, cytab, cdytail, temp16a);
	  cytabtlen = GlobalMembersTriangle.scale_expansion_zeroelim(abtlen, abt, cdytail, cytabt);
	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(cytabtlen, cytabt, 2.0 * cdy, temp32a);
	  temp48len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp32alen, temp32a, temp48);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp48len, temp48, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;


	  temp32alen = GlobalMembersTriangle.scale_expansion_zeroelim(cytabtlen, cytabt, cdytail, temp32a);
	  cytabttlen = GlobalMembersTriangle.scale_expansion_zeroelim(abttlen, abtt, cdytail, cytabtt);
	  temp16alen = GlobalMembersTriangle.scale_expansion_zeroelim(cytabttlen, cytabtt, 2.0 * cdy, temp16a);
	  temp16blen = GlobalMembersTriangle.scale_expansion_zeroelim(cytabttlen, cytabtt, cdytail, temp16b);
	  temp32blen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp16alen, temp16a, temp16blen, temp16b, temp32b);
	  temp64len = GlobalMembersTriangle.fast_expansion_sum_zeroelim(temp32alen, temp32a, temp32blen, temp32b, temp64);
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, temp64len, temp64, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	}
  }

  return finnow[finlength - 1];
}

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.incircle(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL pa, GlobalMembersTriangle.REAL pb, GlobalMembersTriangle.REAL pc, GlobalMembersTriangle.REAL pd)
//#else
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.incircle(m, b, pa, pb, pc, pd)
mesh m;
behavior b;
GlobalMembersTriangle.REAL pa;
GlobalMembersTriangle.REAL pb;
GlobalMembersTriangle.REAL pc;
GlobalMembersTriangle.REAL pd;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL adx;
  GlobalMembersTriangle.REAL bdx;
  GlobalMembersTriangle.REAL cdx;
  GlobalMembersTriangle.REAL ady;
  GlobalMembersTriangle.REAL bdy;
  GlobalMembersTriangle.REAL cdy;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL bdxcdy;
  GlobalMembersTriangle.REAL cdxbdy;
  GlobalMembersTriangle.REAL cdxady;
  GlobalMembersTriangle.REAL adxcdy;
  GlobalMembersTriangle.REAL adxbdy;
  GlobalMembersTriangle.REAL bdxady;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL alift;
  GlobalMembersTriangle.REAL blift;
  GlobalMembersTriangle.REAL clift;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL det;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL permanent;
  GlobalMembersTriangle.REAL errbound;

  m.incirclecount++;

  adx = pa[0] - pd[0];
  bdx = pb[0] - pd[0];
  cdx = pc[0] - pd[0];
  ady = pa[1] - pd[1];
  bdy = pb[1] - pd[1];
  cdy = pc[1] - pd[1];

  bdxcdy = bdx * cdy;
  cdxbdy = cdx * bdy;
  alift = adx * adx + ady * ady;

  cdxady = cdx * ady;
  adxcdy = adx * cdy;
  blift = bdx * bdx + bdy * bdy;

  adxbdy = adx * bdy;
  bdxady = bdx * ady;
  clift = cdx * cdx + cdy * cdy;

  det = alift * (bdxcdy - cdxbdy) + blift * (cdxady - adxcdy) + clift * (adxbdy - bdxady);

  if (b.noexact != 0)
  {
	return det;
  }

  permanent = (((bdxcdy) >= 0.0 ? (bdxcdy) : -(bdxcdy)) + ((cdxbdy) >= 0.0 ? (cdxbdy) : -(cdxbdy))) * alift + (((cdxady) >= 0.0 ? (cdxady) : -(cdxady)) + ((adxcdy) >= 0.0 ? (adxcdy) : -(adxcdy))) * blift + (((adxbdy) >= 0.0 ? (adxbdy) : -(adxbdy)) + ((bdxady) >= 0.0 ? (bdxady) : -(bdxady))) * clift;
  errbound = GlobalMembersTriangle.iccerrboundA * permanent;
  if ((det > errbound) || (-det > errbound))
  {
	return det;
  }

  return GlobalMembersTriangle.incircleadapt(pa, pb, pc, pd, permanent);
}

//***************************************************************************
//                                                                           
//  orient3d()   Return a positive value if the point pd lies below the      
//               plane passing through pa, pb, and pc; "below" is defined so 
//               that pa, pb, and pc appear in counterclockwise order when   
//               viewed from above the plane.  Returns a negative value if   
//               pd lies above the plane.  Returns zero if the points are    
//               coplanar.  The result is also a rough approximation of six  
//               times the signed volume of the tetrahedron defined by the   
//               four points.                                                
//                                                                           
//  Uses exact arithmetic if necessary to ensure a correct answer.  The      
//  result returned is the determinant of a matrix.  This determinant is     
//  computed adaptively, in the sense that exact arithmetic is used only to  
//  the degree it is needed to ensure that the returned value has the        
//  correct sign.  Hence, this function is usually quite fast, but will run  
//  more slowly when the input points are coplanar or nearly so.             
//                                                                           
//  See my Robust Predicates paper for details.                              
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.orient3dadapt(GlobalMembersTriangle.REAL pa, GlobalMembersTriangle.REAL pb, GlobalMembersTriangle.REAL pc, GlobalMembersTriangle.REAL pd, GlobalMembersTriangle.REAL aheight, GlobalMembersTriangle.REAL bheight, GlobalMembersTriangle.REAL cheight, GlobalMembersTriangle.REAL dheight, GlobalMembersTriangle.REAL permanent)
//#else
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.orient3dadapt(pa, pb, pc, pd, aheight, bheight, cheight, dheight, permanent)
GlobalMembersTriangle.REAL pa;
GlobalMembersTriangle.REAL pb;
GlobalMembersTriangle.REAL pc;
GlobalMembersTriangle.REAL pd;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL aheight;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL bheight;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL cheight;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL dheight;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL permanent;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL adx;
   GlobalMembersTriangle.REAL bdx;
   GlobalMembersTriangle.REAL cdx;
   GlobalMembersTriangle.REAL ady;
   GlobalMembersTriangle.REAL bdy;
   GlobalMembersTriangle.REAL cdy;
   GlobalMembersTriangle.REAL adheight;
   GlobalMembersTriangle.REAL bdheight;
   GlobalMembersTriangle.REAL cdheight;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL det;
  GlobalMembersTriangle.REAL errbound;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bdxcdy1;
   GlobalMembersTriangle.REAL cdxbdy1;
   GlobalMembersTriangle.REAL cdxady1;
   GlobalMembersTriangle.REAL adxcdy1;
   GlobalMembersTriangle.REAL adxbdy1;
   GlobalMembersTriangle.REAL bdxady1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL bdxcdy0;
  GlobalMembersTriangle.REAL cdxbdy0;
  GlobalMembersTriangle.REAL cdxady0;
  GlobalMembersTriangle.REAL adxcdy0;
  GlobalMembersTriangle.REAL adxbdy0;
  GlobalMembersTriangle.REAL bdxady0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] bc = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] ca = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] ab = new GlobalMembersTriangle.REAL[4];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bc3;
   GlobalMembersTriangle.REAL ca3;
   GlobalMembersTriangle.REAL ab3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] adet = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] bdet = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cdet = new GlobalMembersTriangle.REAL[8];
  int alen;
  int blen;
  int clen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] abdet = new GlobalMembersTriangle.REAL[16];
  int ablen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL finnow;
  GlobalMembersTriangle.REAL finother;
  GlobalMembersTriangle.REAL finswap;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] fin1 = new GlobalMembersTriangle.REAL[192];
  GlobalMembersTriangle.REAL[] fin2 = new GlobalMembersTriangle.REAL[192];
  int finlength;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL adxtail;
  GlobalMembersTriangle.REAL bdxtail;
  GlobalMembersTriangle.REAL cdxtail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL adytail;
  GlobalMembersTriangle.REAL bdytail;
  GlobalMembersTriangle.REAL cdytail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL adheighttail;
  GlobalMembersTriangle.REAL bdheighttail;
  GlobalMembersTriangle.REAL cdheighttail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL at_blarge;
   GlobalMembersTriangle.REAL at_clarge;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bt_clarge;
   GlobalMembersTriangle.REAL bt_alarge;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL ct_alarge;
   GlobalMembersTriangle.REAL ct_blarge;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] at_b = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] at_c = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] bt_c = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] bt_a = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] ct_a = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] ct_b = new GlobalMembersTriangle.REAL[4];
  int at_blen;
  int at_clen;
  int bt_clen;
  int bt_alen;
  int ct_alen;
  int ct_blen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bdxt_cdy1;
   GlobalMembersTriangle.REAL cdxt_bdy1;
   GlobalMembersTriangle.REAL cdxt_ady1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL adxt_cdy1;
   GlobalMembersTriangle.REAL adxt_bdy1;
   GlobalMembersTriangle.REAL bdxt_ady1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL bdxt_cdy0;
  GlobalMembersTriangle.REAL cdxt_bdy0;
  GlobalMembersTriangle.REAL cdxt_ady0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL adxt_cdy0;
  GlobalMembersTriangle.REAL adxt_bdy0;
  GlobalMembersTriangle.REAL bdxt_ady0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bdyt_cdx1;
   GlobalMembersTriangle.REAL cdyt_bdx1;
   GlobalMembersTriangle.REAL cdyt_adx1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL adyt_cdx1;
   GlobalMembersTriangle.REAL adyt_bdx1;
   GlobalMembersTriangle.REAL bdyt_adx1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL bdyt_cdx0;
  GlobalMembersTriangle.REAL cdyt_bdx0;
  GlobalMembersTriangle.REAL cdyt_adx0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL adyt_cdx0;
  GlobalMembersTriangle.REAL adyt_bdx0;
  GlobalMembersTriangle.REAL bdyt_adx0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] bct = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] cat = new GlobalMembersTriangle.REAL[8];
  GlobalMembersTriangle.REAL[] abt = new GlobalMembersTriangle.REAL[8];
  int bctlen;
  int catlen;
  int abtlen;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bdxt_cdyt1;
   GlobalMembersTriangle.REAL cdxt_bdyt1;
   GlobalMembersTriangle.REAL cdxt_adyt1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL adxt_cdyt1;
   GlobalMembersTriangle.REAL adxt_bdyt1;
   GlobalMembersTriangle.REAL bdxt_adyt1;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL bdxt_cdyt0;
  GlobalMembersTriangle.REAL cdxt_bdyt0;
  GlobalMembersTriangle.REAL cdxt_adyt0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL adxt_cdyt0;
  GlobalMembersTriangle.REAL adxt_bdyt0;
  GlobalMembersTriangle.REAL bdxt_adyt0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] u = new GlobalMembersTriangle.REAL[4];
  GlobalMembersTriangle.REAL[] v = new GlobalMembersTriangle.REAL[12];
  GlobalMembersTriangle.REAL[] w = new GlobalMembersTriangle.REAL[16];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL u3;
  int vlength;
  int wlength;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL negate;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL bvirt;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL avirt;
  GlobalMembersTriangle.REAL bround;
  GlobalMembersTriangle.REAL around;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL c;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL abig;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL ahi;
  GlobalMembersTriangle.REAL alo;
  GlobalMembersTriangle.REAL bhi;
  GlobalMembersTriangle.REAL blo;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL err1;
  GlobalMembersTriangle.REAL err2;
  GlobalMembersTriangle.REAL err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
   GlobalMembersTriangle.REAL _i;
   GlobalMembersTriangle.REAL _j;
   GlobalMembersTriangle.REAL _k;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL _0;

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  adx = (GlobalMembersTriangle.REAL)(pa[0] - pd[0]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bdx = (GlobalMembersTriangle.REAL)(pb[0] - pd[0]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  cdx = (GlobalMembersTriangle.REAL)(pc[0] - pd[0]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  ady = (GlobalMembersTriangle.REAL)(pa[1] - pd[1]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bdy = (GlobalMembersTriangle.REAL)(pb[1] - pd[1]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  cdy = (GlobalMembersTriangle.REAL)(pc[1] - pd[1]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  adheight = (GlobalMembersTriangle.REAL)(aheight - dheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bdheight = (GlobalMembersTriangle.REAL)(bheight - dheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  cdheight = (GlobalMembersTriangle.REAL)(cheight - dheight);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bdxcdy1 = (GlobalMembersTriangle.REAL)(bdx * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bdx);
  ahi = c - abig;
  alo = bdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - cdy);
  bhi = c - abig;
  blo = cdy - bhi;
  err1 = bdxcdy1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  bdxcdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  cdxbdy1 = (GlobalMembersTriangle.REAL)(cdx * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - cdx);
  ahi = c - abig;
  alo = cdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bdy);
  bhi = c - abig;
  blo = bdy - bhi;
  err1 = cdxbdy1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  cdxbdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(bdxcdy0 - cdxbdy0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(bdxcdy0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - cdxbdy0;
  around = bdxcdy0 - avirt;
  bc[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _j = (GlobalMembersTriangle.REAL)(bdxcdy1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_j - bdxcdy1);
  avirt = _j - bvirt;
  bround = _i - bvirt;
  around = bdxcdy1 - avirt;
  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(_0 - cdxbdy1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - cdxbdy1;
  around = _0 - avirt;
  bc[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bc3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(bc3 - _j);
  avirt = bc3 - bvirt;
  bround = _i - bvirt;
  around = _j - avirt;
  bc[2] = around + bround;
  bc[3] = bc3;
  alen = GlobalMembersTriangle.scale_expansion_zeroelim(4, bc, adheight, adet);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  cdxady1 = (GlobalMembersTriangle.REAL)(cdx * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - cdx);
  ahi = c - abig;
  alo = cdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - ady);
  bhi = c - abig;
  blo = ady - bhi;
  err1 = cdxady1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  cdxady0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  adxcdy1 = (GlobalMembersTriangle.REAL)(adx * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - adx);
  ahi = c - abig;
  alo = adx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - cdy);
  bhi = c - abig;
  blo = cdy - bhi;
  err1 = adxcdy1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  adxcdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(cdxady0 - adxcdy0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(cdxady0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - adxcdy0;
  around = cdxady0 - avirt;
  ca[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _j = (GlobalMembersTriangle.REAL)(cdxady1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_j - cdxady1);
  avirt = _j - bvirt;
  bround = _i - bvirt;
  around = cdxady1 - avirt;
  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(_0 - adxcdy1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - adxcdy1;
  around = _0 - avirt;
  ca[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  ca3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(ca3 - _j);
  avirt = ca3 - bvirt;
  bround = _i - bvirt;
  around = _j - avirt;
  ca[2] = around + bround;
  ca[3] = ca3;
  blen = GlobalMembersTriangle.scale_expansion_zeroelim(4, ca, bdheight, bdet);

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  adxbdy1 = (GlobalMembersTriangle.REAL)(adx * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - adx);
  ahi = c - abig;
  alo = adx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bdy);
  bhi = c - abig;
  blo = bdy - bhi;
  err1 = adxbdy1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  adxbdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bdxady1 = (GlobalMembersTriangle.REAL)(bdx * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - bdx);
  ahi = c - abig;
  alo = bdx - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  abig = (GlobalMembersTriangle.REAL)(c - ady);
  bhi = c - abig;
  blo = ady - bhi;
  err1 = bdxady1 - (ahi * bhi);
  err2 = err1 - (alo * bhi);
  err3 = err2 - (ahi * blo);
  bdxady0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(adxbdy0 - bdxady0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(adxbdy0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - bdxady0;
  around = adxbdy0 - avirt;
  ab[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _j = (GlobalMembersTriangle.REAL)(adxbdy1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_j - adxbdy1);
  avirt = _j - bvirt;
  bround = _i - bvirt;
  around = adxbdy1 - avirt;
  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  _i = (GlobalMembersTriangle.REAL)(_0 - bdxady1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
  avirt = _i + bvirt;
  bround = bvirt - bdxady1;
  around = _0 - avirt;
  ab[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  ab3 = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(ab3 - _j);
  avirt = ab3 - bvirt;
  bround = _i - bvirt;
  around = _j - avirt;
  ab[2] = around + bround;
  ab[3] = ab3;
  clen = GlobalMembersTriangle.scale_expansion_zeroelim(4, ab, cdheight, cdet);

  ablen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(alen, adet, blen, bdet, abdet);
  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(ablen, abdet, clen, cdet, fin1);

  det = GlobalMembersTriangle.estimate(finlength, fin1);
  errbound = GlobalMembersTriangle.o3derrboundB * permanent;
  if ((det >= errbound) || (-det >= errbound))
  {
	return det;
  }

//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pa[0] - adx);
  avirt = adx + bvirt;
  bround = bvirt - pd[0];
  around = pa[0] - avirt;
  adxtail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pb[0] - bdx);
  avirt = bdx + bvirt;
  bround = bvirt - pd[0];
  around = pb[0] - avirt;
  bdxtail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pc[0] - cdx);
  avirt = cdx + bvirt;
  bround = bvirt - pd[0];
  around = pc[0] - avirt;
  cdxtail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pa[1] - ady);
  avirt = ady + bvirt;
  bround = bvirt - pd[1];
  around = pa[1] - avirt;
  adytail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pb[1] - bdy);
  avirt = bdy + bvirt;
  bround = bvirt - pd[1];
  around = pb[1] - avirt;
  bdytail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(pc[1] - cdy);
  avirt = cdy + bvirt;
  bround = bvirt - pd[1];
  around = pc[1] - avirt;
  cdytail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(aheight - adheight);
  avirt = adheight + bvirt;
  bround = bvirt - dheight;
  around = aheight - avirt;
  adheighttail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(bheight - bdheight);
  avirt = bdheight + bvirt;
  bround = bvirt - dheight;
  around = bheight - avirt;
  bdheighttail = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  bvirt = (GlobalMembersTriangle.REAL)(cheight - cdheight);
  avirt = cdheight + bvirt;
  bround = bvirt - dheight;
  around = cheight - avirt;
  cdheighttail = around + bround;

  if ((adxtail == 0.0) && (bdxtail == 0.0) && (cdxtail == 0.0) && (adytail == 0.0) && (bdytail == 0.0) && (cdytail == 0.0) && (adheighttail == 0.0) && (bdheighttail == 0.0) && (cdheighttail == 0.0))
  {
	return det;
  }

  errbound = GlobalMembersTriangle.o3derrboundC * permanent + GlobalMembersTriangle.resulterrbound * ((det) >= 0.0 ? (det) : -(det));
  det += (adheight * ((bdx * cdytail + cdy * bdxtail) - (bdy * cdxtail + cdx * bdytail)) + adheighttail * (bdx * cdy - bdy * cdx)) + (bdheight * ((cdx * adytail + ady * cdxtail) - (cdy * adxtail + adx * cdytail)) + bdheighttail * (cdx * ady - cdy * adx)) + (cdheight * ((adx * bdytail + bdy * adxtail) - (ady * bdxtail + bdx * adytail)) + cdheighttail * (adx * bdy - ady * bdx));
  if ((det >= errbound) || (-det >= errbound))
  {
	return det;
  }

  finnow = fin1;
  finother = fin2;

  if (adxtail == 0.0)
  {
	if (adytail == 0.0)
	{
	  at_b[0] = 0.0;
	  at_blen = 1;
	  at_c[0] = 0.0;
	  at_clen = 1;
	}
	else
	{
	  negate = -adytail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  at_blarge = (GlobalMembersTriangle.REAL)(negate * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  ahi = c - abig;
	  alo = negate - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdx);
	  bhi = c - abig;
	  blo = bdx - bhi;
	  err1 = at_blarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  at_b[0] = (alo * blo) - err3;
	  at_b[1] = at_blarge;
	  at_blen = 2;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  at_clarge = (GlobalMembersTriangle.REAL)(adytail * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adytail);
	  ahi = c - abig;
	  alo = adytail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdx);
	  bhi = c - abig;
	  blo = cdx - bhi;
	  err1 = at_clarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  at_c[0] = (alo * blo) - err3;
	  at_c[1] = at_clarge;
	  at_clen = 2;
	}
	}
  else
  {
	if (adytail == 0.0)
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  at_blarge = (GlobalMembersTriangle.REAL)(adxtail * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxtail);
	  ahi = c - abig;
	  alo = adxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdy);
	  bhi = c - abig;
	  blo = bdy - bhi;
	  err1 = at_blarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  at_b[0] = (alo * blo) - err3;
	  at_b[1] = at_blarge;
	  at_blen = 2;
	  negate = -adxtail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  at_clarge = (GlobalMembersTriangle.REAL)(negate * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  ahi = c - abig;
	  alo = negate - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdy);
	  bhi = c - abig;
	  blo = cdy - bhi;
	  err1 = at_clarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  at_c[0] = (alo * blo) - err3;
	  at_c[1] = at_clarge;
	  at_clen = 2;
	}
	else
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  adxt_bdy1 = (GlobalMembersTriangle.REAL)(adxtail * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxtail);
	  ahi = c - abig;
	  alo = adxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdy);
	  bhi = c - abig;
	  blo = bdy - bhi;
	  err1 = adxt_bdy1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  adxt_bdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  adyt_bdx1 = (GlobalMembersTriangle.REAL)(adytail * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adytail);
	  ahi = c - abig;
	  alo = adytail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdx);
	  bhi = c - abig;
	  blo = bdx - bhi;
	  err1 = adyt_bdx1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  adyt_bdx0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(adxt_bdy0 - adyt_bdx0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(adxt_bdy0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - adyt_bdx0;
	  around = adxt_bdy0 - avirt;
	  at_b[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(adxt_bdy1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - adxt_bdy1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = adxt_bdy1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 - adyt_bdx1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - adyt_bdx1;
	  around = _0 - avirt;
	  at_b[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  at_blarge = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(at_blarge - _j);
	  avirt = at_blarge - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  at_b[2] = around + bround;
	  at_b[3] = at_blarge;
	  at_blen = 4;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  adyt_cdx1 = (GlobalMembersTriangle.REAL)(adytail * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adytail);
	  ahi = c - abig;
	  alo = adytail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdx);
	  bhi = c - abig;
	  blo = cdx - bhi;
	  err1 = adyt_cdx1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  adyt_cdx0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  adxt_cdy1 = (GlobalMembersTriangle.REAL)(adxtail * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxtail);
	  ahi = c - abig;
	  alo = adxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdy);
	  bhi = c - abig;
	  blo = cdy - bhi;
	  err1 = adxt_cdy1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  adxt_cdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(adyt_cdx0 - adxt_cdy0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(adyt_cdx0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - adxt_cdy0;
	  around = adyt_cdx0 - avirt;
	  at_c[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(adyt_cdx1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - adyt_cdx1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = adyt_cdx1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 - adxt_cdy1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - adxt_cdy1;
	  around = _0 - avirt;
	  at_c[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  at_clarge = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(at_clarge - _j);
	  avirt = at_clarge - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  at_c[2] = around + bround;
	  at_c[3] = at_clarge;
	  at_clen = 4;
	}
  }
  if (bdxtail == 0.0)
  {
	if (bdytail == 0.0)
	{
	  bt_c[0] = 0.0;
	  bt_clen = 1;
	  bt_a[0] = 0.0;
	  bt_alen = 1;
	}
	else
	{
	  negate = -bdytail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bt_clarge = (GlobalMembersTriangle.REAL)(negate * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  ahi = c - abig;
	  alo = negate - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdx);
	  bhi = c - abig;
	  blo = cdx - bhi;
	  err1 = bt_clarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  bt_c[0] = (alo * blo) - err3;
	  bt_c[1] = bt_clarge;
	  bt_clen = 2;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bt_alarge = (GlobalMembersTriangle.REAL)(bdytail * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdytail);
	  ahi = c - abig;
	  alo = bdytail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adx);
	  bhi = c - abig;
	  blo = adx - bhi;
	  err1 = bt_alarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  bt_a[0] = (alo * blo) - err3;
	  bt_a[1] = bt_alarge;
	  bt_alen = 2;
	}
	}
  else
  {
	if (bdytail == 0.0)
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bt_clarge = (GlobalMembersTriangle.REAL)(bdxtail * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxtail);
	  ahi = c - abig;
	  alo = bdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdy);
	  bhi = c - abig;
	  blo = cdy - bhi;
	  err1 = bt_clarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  bt_c[0] = (alo * blo) - err3;
	  bt_c[1] = bt_clarge;
	  bt_clen = 2;
	  negate = -bdxtail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bt_alarge = (GlobalMembersTriangle.REAL)(negate * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  ahi = c - abig;
	  alo = negate - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - ady);
	  bhi = c - abig;
	  blo = ady - bhi;
	  err1 = bt_alarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  bt_a[0] = (alo * blo) - err3;
	  bt_a[1] = bt_alarge;
	  bt_alen = 2;
	}
	else
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bdxt_cdy1 = (GlobalMembersTriangle.REAL)(bdxtail * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxtail);
	  ahi = c - abig;
	  alo = bdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdy);
	  bhi = c - abig;
	  blo = cdy - bhi;
	  err1 = bdxt_cdy1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  bdxt_cdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bdyt_cdx1 = (GlobalMembersTriangle.REAL)(bdytail * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdytail);
	  ahi = c - abig;
	  alo = bdytail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdx);
	  bhi = c - abig;
	  blo = cdx - bhi;
	  err1 = bdyt_cdx1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  bdyt_cdx0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(bdxt_cdy0 - bdyt_cdx0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(bdxt_cdy0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - bdyt_cdx0;
	  around = bdxt_cdy0 - avirt;
	  bt_c[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(bdxt_cdy1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - bdxt_cdy1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = bdxt_cdy1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 - bdyt_cdx1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - bdyt_cdx1;
	  around = _0 - avirt;
	  bt_c[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bt_clarge = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(bt_clarge - _j);
	  avirt = bt_clarge - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  bt_c[2] = around + bround;
	  bt_c[3] = bt_clarge;
	  bt_clen = 4;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bdyt_adx1 = (GlobalMembersTriangle.REAL)(bdytail * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdytail);
	  ahi = c - abig;
	  alo = bdytail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adx);
	  bhi = c - abig;
	  blo = adx - bhi;
	  err1 = bdyt_adx1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  bdyt_adx0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bdxt_ady1 = (GlobalMembersTriangle.REAL)(bdxtail * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxtail);
	  ahi = c - abig;
	  alo = bdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - ady);
	  bhi = c - abig;
	  blo = ady - bhi;
	  err1 = bdxt_ady1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  bdxt_ady0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(bdyt_adx0 - bdxt_ady0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(bdyt_adx0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - bdxt_ady0;
	  around = bdyt_adx0 - avirt;
	  bt_a[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(bdyt_adx1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - bdyt_adx1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = bdyt_adx1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 - bdxt_ady1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - bdxt_ady1;
	  around = _0 - avirt;
	  bt_a[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bt_alarge = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(bt_alarge - _j);
	  avirt = bt_alarge - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  bt_a[2] = around + bround;
	  bt_a[3] = bt_alarge;
	  bt_alen = 4;
	}
  }
  if (cdxtail == 0.0)
  {
	if (cdytail == 0.0)
	{
	  ct_a[0] = 0.0;
	  ct_alen = 1;
	  ct_b[0] = 0.0;
	  ct_blen = 1;
	}
	else
	{
	  negate = -cdytail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ct_alarge = (GlobalMembersTriangle.REAL)(negate * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  ahi = c - abig;
	  alo = negate - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adx);
	  bhi = c - abig;
	  blo = adx - bhi;
	  err1 = ct_alarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ct_a[0] = (alo * blo) - err3;
	  ct_a[1] = ct_alarge;
	  ct_alen = 2;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ct_blarge = (GlobalMembersTriangle.REAL)(cdytail * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdytail);
	  ahi = c - abig;
	  alo = cdytail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdx);
	  bhi = c - abig;
	  blo = bdx - bhi;
	  err1 = ct_blarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ct_b[0] = (alo * blo) - err3;
	  ct_b[1] = ct_blarge;
	  ct_blen = 2;
	}
	}
  else
  {
	if (cdytail == 0.0)
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ct_alarge = (GlobalMembersTriangle.REAL)(cdxtail * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxtail);
	  ahi = c - abig;
	  alo = cdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - ady);
	  bhi = c - abig;
	  blo = ady - bhi;
	  err1 = ct_alarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ct_a[0] = (alo * blo) - err3;
	  ct_a[1] = ct_alarge;
	  ct_alen = 2;
	  negate = -cdxtail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ct_blarge = (GlobalMembersTriangle.REAL)(negate * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  ahi = c - abig;
	  alo = negate - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdy);
	  bhi = c - abig;
	  blo = bdy - bhi;
	  err1 = ct_blarge - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  ct_b[0] = (alo * blo) - err3;
	  ct_b[1] = ct_blarge;
	  ct_blen = 2;
	}
	else
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  cdxt_ady1 = (GlobalMembersTriangle.REAL)(cdxtail * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxtail);
	  ahi = c - abig;
	  alo = cdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * ady);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - ady);
	  bhi = c - abig;
	  blo = ady - bhi;
	  err1 = cdxt_ady1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  cdxt_ady0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  cdyt_adx1 = (GlobalMembersTriangle.REAL)(cdytail * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdytail);
	  ahi = c - abig;
	  alo = cdytail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adx);
	  bhi = c - abig;
	  blo = adx - bhi;
	  err1 = cdyt_adx1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  cdyt_adx0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(cdxt_ady0 - cdyt_adx0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(cdxt_ady0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - cdyt_adx0;
	  around = cdxt_ady0 - avirt;
	  ct_a[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(cdxt_ady1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - cdxt_ady1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = cdxt_ady1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 - cdyt_adx1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - cdyt_adx1;
	  around = _0 - avirt;
	  ct_a[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ct_alarge = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(ct_alarge - _j);
	  avirt = ct_alarge - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  ct_a[2] = around + bround;
	  ct_a[3] = ct_alarge;
	  ct_alen = 4;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  cdyt_bdx1 = (GlobalMembersTriangle.REAL)(cdytail * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdytail);
	  ahi = c - abig;
	  alo = cdytail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdx);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdx);
	  bhi = c - abig;
	  blo = bdx - bhi;
	  err1 = cdyt_bdx1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  cdyt_bdx0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  cdxt_bdy1 = (GlobalMembersTriangle.REAL)(cdxtail * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxtail);
	  ahi = c - abig;
	  alo = cdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdy);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdy);
	  bhi = c - abig;
	  blo = bdy - bhi;
	  err1 = cdxt_bdy1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  cdxt_bdy0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(cdyt_bdx0 - cdxt_bdy0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(cdyt_bdx0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - cdxt_bdy0;
	  around = cdyt_bdx0 - avirt;
	  ct_b[0] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(cdyt_bdx1 + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_j - cdyt_bdx1);
	  avirt = _j - bvirt;
	  bround = _i - bvirt;
	  around = cdyt_bdx1 - avirt;
	  _0 = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(_0 - cdxt_bdy1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_0 - _i);
	  avirt = _i + bvirt;
	  bround = bvirt - cdxt_bdy1;
	  around = _0 - avirt;
	  ct_b[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ct_blarge = (GlobalMembersTriangle.REAL)(_j + _i);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(ct_blarge - _j);
	  avirt = ct_blarge - bvirt;
	  bround = _i - bvirt;
	  around = _j - avirt;
	  ct_b[2] = around + bround;
	  ct_b[3] = ct_blarge;
	  ct_blen = 4;
	}
  }

  bctlen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(bt_clen, bt_c, ct_blen, ct_b, bct);
  wlength = GlobalMembersTriangle.scale_expansion_zeroelim(bctlen, bct, adheight, w);
  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, wlength, w, finother);
  finswap = finnow;
  finnow = finother;
  finother = finswap;

  catlen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(ct_alen, ct_a, at_clen, at_c, cat);
  wlength = GlobalMembersTriangle.scale_expansion_zeroelim(catlen, cat, bdheight, w);
  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, wlength, w, finother);
  finswap = finnow;
  finnow = finother;
  finother = finswap;

  abtlen = GlobalMembersTriangle.fast_expansion_sum_zeroelim(at_blen, at_b, bt_alen, bt_a, abt);
  wlength = GlobalMembersTriangle.scale_expansion_zeroelim(abtlen, abt, cdheight, w);
  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, wlength, w, finother);
  finswap = finnow;
  finnow = finother;
  finother = finswap;

  if (adheighttail != 0.0)
  {
	vlength = GlobalMembersTriangle.scale_expansion_zeroelim(4, bc, adheighttail, v);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, vlength, v, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }
  if (bdheighttail != 0.0)
  {
	vlength = GlobalMembersTriangle.scale_expansion_zeroelim(4, ca, bdheighttail, v);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, vlength, v, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }
  if (cdheighttail != 0.0)
  {
	vlength = GlobalMembersTriangle.scale_expansion_zeroelim(4, ab, cdheighttail, v);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, vlength, v, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }

  if (adxtail != 0.0)
  {
	if (bdytail != 0.0)
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  adxt_bdyt1 = (GlobalMembersTriangle.REAL)(adxtail * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxtail);
	  ahi = c - abig;
	  alo = adxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdytail);
	  bhi = c - abig;
	  blo = bdytail - bhi;
	  err1 = adxt_bdyt1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  adxt_bdyt0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdheight);
	  bhi = c - abig;
	  blo = cdheight - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(adxt_bdyt0 * cdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxt_bdyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxt_bdyt0);
	  ahi = c - abig;
	  alo = adxt_bdyt0 - ahi;
	  err1 = _i - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(adxt_bdyt1 * cdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxt_bdyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxt_bdyt1);
	  ahi = c - abig;
	  alo = adxt_bdyt1 - ahi;
	  err1 = _j - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  _0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
	  avirt = _k - bvirt;
	  bround = _0 - bvirt;
	  around = _i - avirt;
	  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  u3 = (GlobalMembersTriangle.REAL)(_j + _k);
	  bvirt = u3 - _j;
	  u[2] = _k - bvirt;
	  u[3] = u3;
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	  if (cdheighttail != 0.0)
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - cdheighttail);
		bhi = c - abig;
		blo = cdheighttail - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_i = (GlobalMembersTriangle.REAL)(adxt_bdyt0 * cdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxt_bdyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - adxt_bdyt0);
		ahi = c - abig;
		alo = adxt_bdyt0 - ahi;
		err1 = _i - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_j = (GlobalMembersTriangle.REAL)(adxt_bdyt1 * cdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxt_bdyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - adxt_bdyt1);
		ahi = c - abig;
		alo = adxt_bdyt1 - ahi;
		err1 = _j - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		_0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
		avirt = _k - bvirt;
		bround = _0 - bvirt;
		around = _i - avirt;
		u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		u3 = (GlobalMembersTriangle.REAL)(_j + _k);
		bvirt = u3 - _j;
		u[2] = _k - bvirt;
		u[3] = u3;
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }
	}
	if (cdytail != 0.0)
	{
	  negate = -adxtail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  adxt_cdyt1 = (GlobalMembersTriangle.REAL)(negate * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  ahi = c - abig;
	  alo = negate - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdytail);
	  bhi = c - abig;
	  blo = cdytail - bhi;
	  err1 = adxt_cdyt1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  adxt_cdyt0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdheight);
	  bhi = c - abig;
	  blo = bdheight - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(adxt_cdyt0 * bdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxt_cdyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxt_cdyt0);
	  ahi = c - abig;
	  alo = adxt_cdyt0 - ahi;
	  err1 = _i - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(adxt_cdyt1 * bdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxt_cdyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adxt_cdyt1);
	  ahi = c - abig;
	  alo = adxt_cdyt1 - ahi;
	  err1 = _j - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  _0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
	  avirt = _k - bvirt;
	  bround = _0 - bvirt;
	  around = _i - avirt;
	  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  u3 = (GlobalMembersTriangle.REAL)(_j + _k);
	  bvirt = u3 - _j;
	  u[2] = _k - bvirt;
	  u[3] = u3;
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	  if (bdheighttail != 0.0)
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - bdheighttail);
		bhi = c - abig;
		blo = bdheighttail - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_i = (GlobalMembersTriangle.REAL)(adxt_cdyt0 * bdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxt_cdyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - adxt_cdyt0);
		ahi = c - abig;
		alo = adxt_cdyt0 - ahi;
		err1 = _i - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_j = (GlobalMembersTriangle.REAL)(adxt_cdyt1 * bdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adxt_cdyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - adxt_cdyt1);
		ahi = c - abig;
		alo = adxt_cdyt1 - ahi;
		err1 = _j - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		_0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
		avirt = _k - bvirt;
		bround = _0 - bvirt;
		around = _i - avirt;
		u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		u3 = (GlobalMembersTriangle.REAL)(_j + _k);
		bvirt = u3 - _j;
		u[2] = _k - bvirt;
		u[3] = u3;
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }
	}
  }
  if (bdxtail != 0.0)
  {
	if (cdytail != 0.0)
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bdxt_cdyt1 = (GlobalMembersTriangle.REAL)(bdxtail * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxtail);
	  ahi = c - abig;
	  alo = bdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdytail);
	  bhi = c - abig;
	  blo = cdytail - bhi;
	  err1 = bdxt_cdyt1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  bdxt_cdyt0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adheight);
	  bhi = c - abig;
	  blo = adheight - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(bdxt_cdyt0 * adheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxt_cdyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxt_cdyt0);
	  ahi = c - abig;
	  alo = bdxt_cdyt0 - ahi;
	  err1 = _i - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(bdxt_cdyt1 * adheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxt_cdyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxt_cdyt1);
	  ahi = c - abig;
	  alo = bdxt_cdyt1 - ahi;
	  err1 = _j - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  _0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
	  avirt = _k - bvirt;
	  bround = _0 - bvirt;
	  around = _i - avirt;
	  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  u3 = (GlobalMembersTriangle.REAL)(_j + _k);
	  bvirt = u3 - _j;
	  u[2] = _k - bvirt;
	  u[3] = u3;
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	  if (adheighttail != 0.0)
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - adheighttail);
		bhi = c - abig;
		blo = adheighttail - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_i = (GlobalMembersTriangle.REAL)(bdxt_cdyt0 * adheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxt_cdyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - bdxt_cdyt0);
		ahi = c - abig;
		alo = bdxt_cdyt0 - ahi;
		err1 = _i - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_j = (GlobalMembersTriangle.REAL)(bdxt_cdyt1 * adheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxt_cdyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - bdxt_cdyt1);
		ahi = c - abig;
		alo = bdxt_cdyt1 - ahi;
		err1 = _j - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		_0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
		avirt = _k - bvirt;
		bround = _0 - bvirt;
		around = _i - avirt;
		u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		u3 = (GlobalMembersTriangle.REAL)(_j + _k);
		bvirt = u3 - _j;
		u[2] = _k - bvirt;
		u[3] = u3;
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }
	}
	if (adytail != 0.0)
	{
	  negate = -bdxtail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bdxt_adyt1 = (GlobalMembersTriangle.REAL)(negate * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  ahi = c - abig;
	  alo = negate - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adytail);
	  bhi = c - abig;
	  blo = adytail - bhi;
	  err1 = bdxt_adyt1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  bdxt_adyt0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdheight);
	  bhi = c - abig;
	  blo = cdheight - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(bdxt_adyt0 * cdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxt_adyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxt_adyt0);
	  ahi = c - abig;
	  alo = bdxt_adyt0 - ahi;
	  err1 = _i - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(bdxt_adyt1 * cdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxt_adyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdxt_adyt1);
	  ahi = c - abig;
	  alo = bdxt_adyt1 - ahi;
	  err1 = _j - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  _0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
	  avirt = _k - bvirt;
	  bround = _0 - bvirt;
	  around = _i - avirt;
	  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  u3 = (GlobalMembersTriangle.REAL)(_j + _k);
	  bvirt = u3 - _j;
	  u[2] = _k - bvirt;
	  u[3] = u3;
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	  if (cdheighttail != 0.0)
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - cdheighttail);
		bhi = c - abig;
		blo = cdheighttail - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_i = (GlobalMembersTriangle.REAL)(bdxt_adyt0 * cdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxt_adyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - bdxt_adyt0);
		ahi = c - abig;
		alo = bdxt_adyt0 - ahi;
		err1 = _i - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_j = (GlobalMembersTriangle.REAL)(bdxt_adyt1 * cdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdxt_adyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - bdxt_adyt1);
		ahi = c - abig;
		alo = bdxt_adyt1 - ahi;
		err1 = _j - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		_0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
		avirt = _k - bvirt;
		bround = _0 - bvirt;
		around = _i - avirt;
		u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		u3 = (GlobalMembersTriangle.REAL)(_j + _k);
		bvirt = u3 - _j;
		u[2] = _k - bvirt;
		u[3] = u3;
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }
	}
  }
  if (cdxtail != 0.0)
  {
	if (adytail != 0.0)
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  cdxt_adyt1 = (GlobalMembersTriangle.REAL)(cdxtail * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxtail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxtail);
	  ahi = c - abig;
	  alo = cdxtail - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adytail);
	  bhi = c - abig;
	  blo = adytail - bhi;
	  err1 = cdxt_adyt1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  cdxt_adyt0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdheight);
	  bhi = c - abig;
	  blo = bdheight - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(cdxt_adyt0 * bdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxt_adyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxt_adyt0);
	  ahi = c - abig;
	  alo = cdxt_adyt0 - ahi;
	  err1 = _i - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(cdxt_adyt1 * bdheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxt_adyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxt_adyt1);
	  ahi = c - abig;
	  alo = cdxt_adyt1 - ahi;
	  err1 = _j - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  _0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
	  avirt = _k - bvirt;
	  bround = _0 - bvirt;
	  around = _i - avirt;
	  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  u3 = (GlobalMembersTriangle.REAL)(_j + _k);
	  bvirt = u3 - _j;
	  u[2] = _k - bvirt;
	  u[3] = u3;
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	  if (bdheighttail != 0.0)
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - bdheighttail);
		bhi = c - abig;
		blo = bdheighttail - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_i = (GlobalMembersTriangle.REAL)(cdxt_adyt0 * bdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxt_adyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - cdxt_adyt0);
		ahi = c - abig;
		alo = cdxt_adyt0 - ahi;
		err1 = _i - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_j = (GlobalMembersTriangle.REAL)(cdxt_adyt1 * bdheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxt_adyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - cdxt_adyt1);
		ahi = c - abig;
		alo = cdxt_adyt1 - ahi;
		err1 = _j - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		_0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
		avirt = _k - bvirt;
		bround = _0 - bvirt;
		around = _i - avirt;
		u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		u3 = (GlobalMembersTriangle.REAL)(_j + _k);
		bvirt = u3 - _j;
		u[2] = _k - bvirt;
		u[3] = u3;
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }
	}
	if (bdytail != 0.0)
	{
	  negate = -cdxtail;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  cdxt_bdyt1 = (GlobalMembersTriangle.REAL)(negate * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * negate);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - negate);
	  ahi = c - abig;
	  alo = negate - ahi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * bdytail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - bdytail);
	  bhi = c - abig;
	  blo = bdytail - bhi;
	  err1 = cdxt_bdyt1 - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  cdxt_bdyt0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - adheight);
	  bhi = c - abig;
	  blo = adheight - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _i = (GlobalMembersTriangle.REAL)(cdxt_bdyt0 * adheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxt_bdyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxt_bdyt0);
	  ahi = c - abig;
	  alo = cdxt_bdyt0 - ahi;
	  err1 = _i - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _j = (GlobalMembersTriangle.REAL)(cdxt_bdyt1 * adheight);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxt_bdyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  abig = (GlobalMembersTriangle.REAL)(c - cdxt_bdyt1);
	  ahi = c - abig;
	  alo = cdxt_bdyt1 - ahi;
	  err1 = _j - (ahi * bhi);
	  err2 = err1 - (alo * bhi);
	  err3 = err2 - (ahi * blo);
	  _0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  _k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
	  avirt = _k - bvirt;
	  bround = _0 - bvirt;
	  around = _i - avirt;
	  u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  u3 = (GlobalMembersTriangle.REAL)(_j + _k);
	  bvirt = u3 - _j;
	  u[2] = _k - bvirt;
	  u[3] = u3;
	  finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
	  finswap = finnow;
	  finnow = finother;
	  finother = finswap;
	  if (adheighttail != 0.0)
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * adheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - adheighttail);
		bhi = c - abig;
		blo = adheighttail - bhi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_i = (GlobalMembersTriangle.REAL)(cdxt_bdyt0 * adheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxt_bdyt0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - cdxt_bdyt0);
		ahi = c - abig;
		alo = cdxt_bdyt0 - ahi;
		err1 = _i - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		u[0] = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_j = (GlobalMembersTriangle.REAL)(cdxt_bdyt1 * adheighttail);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		c = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.splitter * cdxt_bdyt1);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		abig = (GlobalMembersTriangle.REAL)(c - cdxt_bdyt1);
		ahi = c - abig;
		alo = cdxt_bdyt1 - ahi;
		err1 = _j - (ahi * bhi);
		err2 = err1 - (alo * bhi);
		err3 = err2 - (ahi * blo);
		_0 = (alo * blo) - err3;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		_k = (GlobalMembersTriangle.REAL)(_i + _0);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		bvirt = (GlobalMembersTriangle.REAL)(_k - _i);
		avirt = _k - bvirt;
		bround = _0 - bvirt;
		around = _i - avirt;
		u[1] = around + bround;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		u3 = (GlobalMembersTriangle.REAL)(_j + _k);
		bvirt = u3 - _j;
		u[2] = _k - bvirt;
		u[3] = u3;
		finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, 4, u, finother);
		finswap = finnow;
		finnow = finother;
		finother = finswap;
	  }
	}
  }

  if (adheighttail != 0.0)
  {
	wlength = GlobalMembersTriangle.scale_expansion_zeroelim(bctlen, bct, adheighttail, w);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, wlength, w, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }
  if (bdheighttail != 0.0)
  {
	wlength = GlobalMembersTriangle.scale_expansion_zeroelim(catlen, cat, bdheighttail, w);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, wlength, w, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }
  if (cdheighttail != 0.0)
  {
	wlength = GlobalMembersTriangle.scale_expansion_zeroelim(abtlen, abt, cdheighttail, w);
	finlength = GlobalMembersTriangle.fast_expansion_sum_zeroelim(finlength, finnow, wlength, w, finother);
	finswap = finnow;
	finnow = finother;
	finother = finswap;
  }

  return finnow[finlength - 1];
}

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.orient3d(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL pa, GlobalMembersTriangle.REAL pb, GlobalMembersTriangle.REAL pc, GlobalMembersTriangle.REAL pd, GlobalMembersTriangle.REAL aheight, GlobalMembersTriangle.REAL bheight, GlobalMembersTriangle.REAL cheight, GlobalMembersTriangle.REAL dheight)
//#else
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.orient3d(m, b, pa, pb, pc, pd, aheight, bheight, cheight, dheight)
mesh m;
behavior b;
GlobalMembersTriangle.REAL pa;
GlobalMembersTriangle.REAL pb;
GlobalMembersTriangle.REAL pc;
GlobalMembersTriangle.REAL pd;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL aheight;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL bheight;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL cheight;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL dheight;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL adx;
  GlobalMembersTriangle.REAL bdx;
  GlobalMembersTriangle.REAL cdx;
  GlobalMembersTriangle.REAL ady;
  GlobalMembersTriangle.REAL bdy;
  GlobalMembersTriangle.REAL cdy;
  GlobalMembersTriangle.REAL adheight;
  GlobalMembersTriangle.REAL bdheight;
  GlobalMembersTriangle.REAL cdheight;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL bdxcdy;
  GlobalMembersTriangle.REAL cdxbdy;
  GlobalMembersTriangle.REAL cdxady;
  GlobalMembersTriangle.REAL adxcdy;
  GlobalMembersTriangle.REAL adxbdy;
  GlobalMembersTriangle.REAL bdxady;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL det;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL permanent;
  GlobalMembersTriangle.REAL errbound;

  m.orient3dcount++;

  adx = pa[0] - pd[0];
  bdx = pb[0] - pd[0];
  cdx = pc[0] - pd[0];
  ady = pa[1] - pd[1];
  bdy = pb[1] - pd[1];
  cdy = pc[1] - pd[1];
  adheight = aheight - dheight;
  bdheight = bheight - dheight;
  cdheight = cheight - dheight;

  bdxcdy = bdx * cdy;
  cdxbdy = cdx * bdy;

  cdxady = cdx * ady;
  adxcdy = adx * cdy;

  adxbdy = adx * bdy;
  bdxady = bdx * ady;

  det = adheight * (bdxcdy - cdxbdy) + bdheight * (cdxady - adxcdy) + cdheight * (adxbdy - bdxady);

  if (b.noexact != 0)
  {
	return det;
  }

  permanent = (((bdxcdy) >= 0.0 ? (bdxcdy) : -(bdxcdy)) + ((cdxbdy) >= 0.0 ? (cdxbdy) : -(cdxbdy))) * ((adheight) >= 0.0 ? (adheight) : -(adheight)) + (((cdxady) >= 0.0 ? (cdxady) : -(cdxady)) + ((adxcdy) >= 0.0 ? (adxcdy) : -(adxcdy))) * ((bdheight) >= 0.0 ? (bdheight) : -(bdheight)) + (((adxbdy) >= 0.0 ? (adxbdy) : -(adxbdy)) + ((bdxady) >= 0.0 ? (bdxady) : -(bdxady))) * ((cdheight) >= 0.0 ? (cdheight) : -(cdheight));
  errbound = GlobalMembersTriangle.o3derrboundA * permanent;
  if ((det > errbound) || (-det > errbound))
  {
	return det;
  }

  return GlobalMembersTriangle.orient3dadapt(pa, pb, pc, pd, aheight, bheight, cheight, dheight, permanent);
}

//***************************************************************************
//                                                                           
//  nonregular()   Return a positive value if the point pd is incompatible   
//                 with the circle or plane passing through pa, pb, and pc   
//                 (meaning that pd is inside the circle or below the        
//                 plane); a negative value if it is compatible; and zero if 
//                 the four points are cocircular/coplanar.  The points pa,  
//                 pb, and pc must be in counterclockwise order, or the sign 
//                 of the result will be reversed.                           
//                                                                           
//  If the -w switch is used, the points are lifted onto the parabolic       
//  lifting map, then they are dropped according to their weights, then the  
//  3D orientation test is applied.  If the -W switch is used, the points'   
//  heights are already provided, so the 3D orientation test is applied      
//  directly.  If neither switch is used, the incircle test is applied.      
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.nonregular(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL pa, GlobalMembersTriangle.REAL pb, GlobalMembersTriangle.REAL pc, GlobalMembersTriangle.REAL pd)
//#else
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.nonregular(m, b, pa, pb, pc, pd)
mesh m;
behavior b;
GlobalMembersTriangle.REAL pa;
GlobalMembersTriangle.REAL pb;
GlobalMembersTriangle.REAL pc;
GlobalMembersTriangle.REAL pd;
//#endif // not ANSI_DECLARATORS

{
  if (b.weighted == 0)
  {
	return GlobalMembersTriangle.incircle(m, b, pa, pb, pc, pd);
  }
  else if (b.weighted == 1)
  {
	return GlobalMembersTriangle.orient3d(m, b, pa, pb, pc, pd, pa[0] pa[0] + pa[1] pa[1] - pa[2], pb[0] pb[0] + pb[1] pb[1] - pb[2], pc[0] pc[0] + pc[1] pc[1] - pc[2], pd[0] pd[0] + pd[1] pd[1] - pd[2]);
  }
  else
  {
	return GlobalMembersTriangle.orient3d(m, b, pa, pb, pc, pd, pa[2], pb[2], pc[2], pd[2]);
  }
}

//***************************************************************************
//                                                                           
//  findcircumcenter()   Find the circumcenter of a triangle.                
//                                                                           
//  The result is returned both in terms of x-y coordinates and xi-eta       
//  (barycentric) coordinates.  The xi-eta coordinate system is defined in   
//  terms of the triangle:  the origin of the triangle is the origin of the  
//  coordinate system; the destination of the triangle is one unit along the 
//  xi axis; and the apex of the triangle is one unit along the eta axis.    
//  This procedure also returns the square of the length of the triangle's   
//  shortest edge.                                                           
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
void GlobalMembersTriangle.findcircumcenter(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL * torg, GlobalMembersTriangle.REAL * tdest, GlobalMembersTriangle.REAL * tapex, GlobalMembersTriangle.REAL * circumcenter, GlobalMembersTriangle.REAL *xi, GlobalMembersTriangle.REAL *eta, int offcenter)
//#else
void GlobalMembersTriangle.findcircumcenter(m, b, torg, tdest, tapex, circumcenter, xi, eta, offcenter)
mesh m;
behavior b;
GlobalMembersTriangle.REAL torg;
GlobalMembersTriangle.REAL tdest;
GlobalMembersTriangle.REAL tapex;
GlobalMembersTriangle.REAL circumcenter;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL xi;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL eta;
int offcenter;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL xdo;
  GlobalMembersTriangle.REAL ydo;
  GlobalMembersTriangle.REAL xao;
  GlobalMembersTriangle.REAL yao;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL dodist;
  GlobalMembersTriangle.REAL aodist;
  GlobalMembersTriangle.REAL dadist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL denominator;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL dx;
  GlobalMembersTriangle.REAL dy;
  GlobalMembersTriangle.REAL dxoff;
  GlobalMembersTriangle.REAL dyoff;

  m.circumcentercount++;

  // Compute the circumcenter of the triangle. 
  xdo = tdest[0] - torg[0];
  ydo = tdest[1] - torg[1];
  xao = tapex[0] - torg[0];
  yao = tapex[1] - torg[1];
  dodist = xdo * xdo + ydo * ydo;
  aodist = xao * xao + yao * yao;
  dadist = (tdest[0] - tapex[0]) * (tdest[0] - tapex[0]) + (tdest[1] - tapex[1]) * (tdest[1] - tapex[1]);
  if (b.noexact != 0)
  {
	denominator = 0.5 / (xdo * yao - xao * ydo);
  }
  else
  {
	// Use the counterclockwise() routine to ensure a positive (and 
	//   reasonably accurate) result, avoiding any possibility of   
	//   division by zero.                                          
	denominator = 0.5 / GlobalMembersTriangle.counterclockwise(m, b, tdest, tapex, torg);
	// Don't count the above as an orientation test. 
	m.counterclockcount--;
  }
  dx = (yao * dodist - ydo * aodist) * denominator;
  dy = (xdo * aodist - xao * dodist) * denominator;

  // Find the (squared) length of the triangle's shortest edge.  This   
  //   serves as a conservative estimate of the insertion radius of the 
  //   circumcenter's parent.  The estimate is used to ensure that      
  //   the algorithm terminates even if very small angles appear in     
  //   the input PSLG.                                                  
  if ((dodist < aodist) && (dodist < dadist))
  {
	if (offcenter != 0 && (b.offconstant > 0.0))
	{
	  // Find the position of the off-center, as described by Alper Ungor. 
	  dxoff = 0.5 * xdo - b.offconstant * ydo;
	  dyoff = 0.5 * ydo + b.offconstant * xdo;
	  // If the off-center is closer to the origin than the 
	  //   circumcenter, use the off-center instead.        
	  if (dxoff * dxoff + dyoff * dyoff < dx * dx + dy * dy)
	  {
		dx = dxoff;
		dy = dyoff;
	  }
	}
	  }
  else if (aodist < dadist)
  {
	if (offcenter != 0 && (b.offconstant > 0.0))
	{
	  dxoff = 0.5 * xao + b.offconstant * yao;
	  dyoff = 0.5 * yao - b.offconstant * xao;
	  // If the off-center is closer to the origin than the 
	  //   circumcenter, use the off-center instead.        
	  if (dxoff * dxoff + dyoff * dyoff < dx * dx + dy * dy)
	  {
		dx = dxoff;
		dy = dyoff;
	  }
	}
	  }
  else
  {
	if (offcenter != 0 && (b.offconstant > 0.0))
	{
	  dxoff = 0.5 * (tapex[0] - tdest[0]) - b.offconstant * (tapex[1] - tdest[1]);
	  dyoff = 0.5 * (tapex[1] - tdest[1]) + b.offconstant * (tapex[0] - tdest[0]);
	  // If the off-center is closer to the destination than the 
	  //   circumcenter, use the off-center instead.             
	  if (dxoff * dxoff + dyoff * dyoff < (dx - xdo) * (dx - xdo) + (dy - ydo) * (dy - ydo))
	  {
		dx = xdo + dxoff;
		dy = ydo + dyoff;
	  }
	}
  }

  circumcenter[0] = torg[0] + dx;
  circumcenter[1] = torg[1] + dy;

  // To interpolate vertex attributes for the new vertex inserted at 
  //   the circumcenter, define a coordinate system with a xi-axis,  
  //   directed from the triangle's origin to its destination, and   
  //   an eta-axis, directed from its origin to its apex.            
  //   Calculate the xi and eta coordinates of the circumcenter.     
  xi = (yao * dx - xao * dy) * (2.0 * denominator);
  eta = (xdo * dy - ydo * dx) * (2.0 * denominator);
}

//*                                                                         *
//*                                                                         *
//******** Geometric primitives end here                             ********

//***************************************************************************
//                                                                           
//  triangleinit()   Initialize some variables.                              
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.triangleinit(struct mesh m)
//#else
void GlobalMembersTriangle.triangleinit(m)
mesh m;
//#endif // not ANSI_DECLARATORS

{
  GlobalMembersTriangle.poolzero(m.vertices);
  GlobalMembersTriangle.poolzero(m.triangles);
  GlobalMembersTriangle.poolzero(m.subsegs);
  GlobalMembersTriangle.poolzero(m.viri);
  GlobalMembersTriangle.poolzero(m.badsubsegs);
  GlobalMembersTriangle.poolzero(m.badtriangles);
  GlobalMembersTriangle.poolzero(m.flipstackers);
  GlobalMembersTriangle.poolzero(m.splaynodes);

  m.recenttri.tri = (GlobalMembersTriangle.REAL ** *) null; // No triangle has been visited yet.
  m.undeads = 0; // No eliminated input vertices yet.
  m.samples = 1; // Point location should take at least one sample.
  m.checksegments = 0; // There are no segments in the triangulation yet.
  m.checkquality = 0; // The quality triangulation stage has not begun.
  m.incirclecount = m.counterclockcount = m.orient3dcount = 0;
  m.hyperbolacount = m.circletopcount = m.circumcentercount = 0;
  GlobalMembersTriangle.randomseed = 1;

  GlobalMembersTriangle.exactinit(); // Initialize exact arithmetic constants.
}

//***************************************************************************
//                                                                           
//  randomnation()   Generate a random number between 0 and `choices' - 1.   
//                                                                           
//  This is a simple linear congruential random number generator.  Hence, it 
//  is a bad random number generator, but good enough for most randomized    
//  geometric algorithms.                                                    
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int GlobalMembersTriangle.randomnation(int choices)
//#else
int GlobalMembersTriangle.randomnation(choices)
int choices;
//#endif // not ANSI_DECLARATORS

{
  GlobalMembersTriangle.randomseed = (GlobalMembersTriangle.randomseed * 1366l + 150889l) % 714025l;
  return GlobalMembersTriangle.randomseed / (714025l / choices + 1);
}

//******** Mesh quality testing routines begin here                  ********
//*                                                                         *
//*                                                                         *

//***************************************************************************
//                                                                           
//  checkmesh()   Test the mesh for topological consistency.                 
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.checkmesh(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.checkmesh(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri triangleloop = new otri();
  otri oppotri = new otri();
  otri oppooppotri = new otri();
  GlobalMembersTriangle.REAL triorg.argvalue;
  GlobalMembersTriangle.REAL tridest.argvalue;
  GlobalMembersTriangle.REAL triapex.argvalue;
  GlobalMembersTriangle.REAL oppoorg;
  GlobalMembersTriangle.REAL oppodest;
  int horrors;
  int saveexact;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().

  // Temporarily turn on exact arithmetic if it's off. 
  saveexact = b.noexact;
  b.noexact = 0;
  if (b.quiet == 0)
  {
	System.out.print("  Checking consistency of mesh...\n");
  }
  horrors = 0;
  // Run through the list of triangles, checking each one. 
  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	// Check all three edges of the triangle. 
	for (triangleloop.orient = 0; triangleloop.orient < 3; triangleloop.orient++)
	{
	  triorg.argvalue = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.plus1mod3[(triangleloop).orient] + 3];
	  tridest.argvalue = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.minus1mod3[(triangleloop).orient] + 3];
	  if (triangleloop.orient == 0) // Only test for inversion once.
	  {
		// Test if the triangle is flat or inverted. 
		triapex.argvalue = (GlobalMembersTriangle.REAL)(triangleloop).tri[(triangleloop).orient + 3];
		if (GlobalMembersTriangle.counterclockwise(m, b, triorg.argvalue, tridest.argvalue, triapex.argvalue) <= 0.0)
		{
		  System.out.print("  !! !! Inverted ");
		  GlobalMembersTriangle.printtriangle(m, b, triangleloop);
		  horrors++;
		}
	  }
	  // Find the neighboring triangle on this edge. 
	  ptr = (triangleloop).tri[(triangleloop).orient];
	  (oppotri).orient = (int)((int)(ptr) & (int) 3l);
	  (oppotri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(oppotri).orient);
	  ;
	  if (oppotri.tri != m.dummytri)
	  {
		// Check that the triangle's neighbor knows it's a neighbor. 
		ptr = (oppotri).tri[(oppotri).orient];
		(oppooppotri).orient = (int)((int)(ptr) & (int) 3l);
		(oppooppotri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(oppooppotri).orient);
		;
		if ((triangleloop.tri != oppooppotri.tri) || (triangleloop.orient != oppooppotri.orient))
		{
		  System.out.print("  !! !! Asymmetric triangle-triangle bond:\n");
		  if (triangleloop.tri == oppooppotri.tri)
		  {
			System.out.print("   (Right triangle, wrong orientation)\n");
		  }
		  System.out.print("    First ");
		  GlobalMembersTriangle.printtriangle(m, b, triangleloop);
		  System.out.print("    Second (nonreciprocating) ");
		  GlobalMembersTriangle.printtriangle(m, b, oppotri);
		  horrors++;
		}
		// Check that both triangles agree on the identities 
		//   of their shared vertices.                       
		oppoorg = (GlobalMembersTriangle.REAL)(oppotri).tri[GlobalMembersTriangle.plus1mod3[(oppotri).orient] + 3];
		oppodest = (GlobalMembersTriangle.REAL)(oppotri).tri[GlobalMembersTriangle.minus1mod3[(oppotri).orient] + 3];
		if ((triorg.argvalue != oppodest) || (tridest.argvalue != oppoorg))
		{
		  System.out.print("  !! !! Mismatched edge coordinates between two triangles:\n");
		  System.out.print("    First mismatched ");
		  GlobalMembersTriangle.printtriangle(m, b, triangleloop);
		  System.out.print("    Second mismatched ");
		  GlobalMembersTriangle.printtriangle(m, b, oppotri);
		  horrors++;
		}
	  }
	}
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  }
  if (horrors == 0)
  {
	if (b.quiet == 0)
	{
	  System.out.print("  In my studied opinion, the mesh appears to be consistent.\n");
	}
	}
  else if (horrors == 1)
  {
	System.out.print("  !! !! !! !! Precisely one festering wound discovered.\n");
  }
  else
  {
	System.out.printf("  !! !! !! !! %d abominations witnessed.\n", horrors);
  }
  // Restore the status of exact arithmetic. 
  b.noexact = saveexact;
}

//#endif // not REDUCED

//***************************************************************************
//                                                                           
//  checkdelaunay()   Ensure that the mesh is (constrained) Delaunay.        
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.checkdelaunay(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.checkdelaunay(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri triangleloop = new otri();
  otri oppotri = new otri();
  osub opposubseg = new osub();
  GlobalMembersTriangle.REAL triorg.argvalue;
  GlobalMembersTriangle.REAL tridest.argvalue;
  GlobalMembersTriangle.REAL triapex.argvalue;
  GlobalMembersTriangle.REAL oppoapex;
  int shouldbedelaunay;
  int horrors;
  int saveexact;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  // Temporarily turn on exact arithmetic if it's off. 
  saveexact = b.noexact;
  b.noexact = 0;
  if (b.quiet == 0)
  {
	System.out.print("  Checking Delaunay property of mesh...\n");
  }
  horrors = 0;
  // Run through the list of triangles, checking each one. 
  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	// Check all three edges of the triangle. 
	for (triangleloop.orient = 0; triangleloop.orient < 3; triangleloop.orient++)
	{
	  triorg.argvalue = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.plus1mod3[(triangleloop).orient] + 3];
	  tridest.argvalue = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.minus1mod3[(triangleloop).orient] + 3];
	  triapex.argvalue = (GlobalMembersTriangle.REAL)(triangleloop).tri[(triangleloop).orient + 3];
	  ptr = (triangleloop).tri[(triangleloop).orient];
	  (oppotri).orient = (int)((int)(ptr) & (int) 3l);
	  (oppotri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(oppotri).orient);
	  ;
	  oppoapex = (GlobalMembersTriangle.REAL)(oppotri).tri[(oppotri).orient + 3];
	  // Only test that the edge is locally Delaunay if there is an   
	  //   adjoining triangle whose pointer is larger (to ensure that 
	  //   each pair isn't tested twice).                             
	  shouldbedelaunay = (oppotri.tri != m.dummytri) && !((oppotri.tri)[1] == (GlobalMembersTriangle.REAL) null) && (triangleloop.tri < oppotri.tri) && (triorg.argvalue != m.infvertex1) && (triorg.argvalue != m.infvertex2) && (triorg.argvalue != m.infvertex3) && (tridest.argvalue != m.infvertex1) && (tridest.argvalue != m.infvertex2) && (tridest.argvalue != m.infvertex3) && (triapex.argvalue != m.infvertex1) && (triapex.argvalue != m.infvertex2) && (triapex.argvalue != m.infvertex3) && (oppoapex != m.infvertex1) && (oppoapex != m.infvertex2) && (oppoapex != m.infvertex3);
	  if (m.checksegments != 0 && shouldbedelaunay != 0)
	  {
		// If a subsegment separates the triangles, then the edge is 
		//   constrained, so no local Delaunay test should be done.  
		sptr = (GlobalMembersTriangle.REAL)(triangleloop).tri[6 + (triangleloop).orient];
		(opposubseg).ssorient = (int)((int)(sptr) & (int) 1l);
		(opposubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		if (opposubseg.ss != m.dummysub)
		{
		  shouldbedelaunay = 0;
		}
	  }
	  if (shouldbedelaunay != 0)
	  {
		if (GlobalMembersTriangle.nonregular(m, b, triorg.argvalue, tridest.argvalue, triapex.argvalue, oppoapex) > 0.0)
		{
		  if (b.weighted == 0)
		  {
			System.out.print("  !! !! Non-Delaunay pair of triangles:\n");
			System.out.print("    First non-Delaunay ");
			GlobalMembersTriangle.printtriangle(m, b, triangleloop);
			System.out.print("    Second non-Delaunay ");
		  }
		  else
		  {
			System.out.print("  !! !! Non-regular pair of triangles:\n");
			System.out.print("    First non-regular ");
			GlobalMembersTriangle.printtriangle(m, b, triangleloop);
			System.out.print("    Second non-regular ");
		  }
		  GlobalMembersTriangle.printtriangle(m, b, oppotri);
		  horrors++;
		}
	  }
	}
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  }
  if (horrors == 0)
  {
	if (b.quiet == 0)
	{
	  System.out.print("  By virtue of my perceptive intelligence, I declare the mesh Delaunay.\n");
	}
	}
  else if (horrors == 1)
  {
	System.out.print("  !! !! !! !! Precisely one terrifying transgression identified.\n");
  }
  else
  {
	System.out.printf("  !! !! !! !! %d obscenities viewed with horror.\n", horrors);
  }
  // Restore the status of exact arithmetic. 
  b.noexact = saveexact;
}

//#endif // not REDUCED

//***************************************************************************
//                                                                           
//  enqueuebadtriang()   Add a bad triangle data structure to the end of a   
//                       queue.                                              
//                                                                           
//  The queue is actually a set of 4096 queues.  I use multiple queues to    
//  give priority to smaller angles.  I originally implemented a heap, but   
//  the queues are faster by a larger margin than I'd suspected.             
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.enqueuebadtriang(struct mesh m, struct behavior b, struct badtriang *badtri)
//#else
void GlobalMembersTriangle.enqueuebadtriang(m, b, badtri)
mesh m;
behavior b;
badtriang badtri;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL length;
  GlobalMembersTriangle.REAL multiplier;
  int exponent;
  int expincrement;
  int queuenumber;
  int posexponent;
  int i;

  if (b.verbose > 2)
  {
	System.out.print("  Queueing bad triangle:\n");
	System.out.printf("    (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n", badtri.triangorg[0], badtri.triangorg[1], badtri.triangdest[0], badtri.triangdest[1], badtri.triangapex[0], badtri.triangapex[1]);
  }

  // Determine the appropriate queue to put the bad triangle into.    
  //   Recall that the key is the square of its shortest edge length. 
  if (badtri.key >= 1.0)
  {
	length = badtri.key;
	posexponent = 1;
  }
  else
  {
	// `badtri->key' is 2.0 to a negative exponent, so we'll record that 
	//   fact and use the reciprocal of `badtri->key', which is > 1.0.   
	length = 1.0 / badtri.key;
	posexponent = 0;
  }
  // `length' is approximately 2.0 to what exponent?  The following code 
  //   determines the answer in time logarithmic in the exponent.        
  exponent = 0;
  while (length > 2.0)
  {
	// Find an approximation by repeated squaring of two. 
	expincrement = 1;
	multiplier = 0.5;
	while (length * multiplier * multiplier > 1.0)
	{
	  expincrement *= 2;
	  multiplier *= multiplier;
	}
	// Reduce the value of `length', then iterate if necessary. 
	exponent += expincrement;
	length *= multiplier;
  }
  // `length' is approximately squareroot(2.0) to what exponent? 
  exponent = (int)(2.0 * exponent + (length > DefineConstantsTriangle.SQUAREROOTTWO)); // [MA] int casting
  // `exponent' is now in the range 0...2047 for IEEE double precision.   
  //   Choose a queue in the range 0...4095.  The shortest edges have the 
  //   highest priority (queue 4095).                                     
  if (posexponent != 0)
  {
	queuenumber = 2047 - exponent;
  }
  else
  {
	queuenumber = 2048 + exponent;
  }

  // Are we inserting into an empty queue? 
  if (m.queuefront[queuenumber] == (badtriang) null)
  {
	// Yes, we are inserting into an empty queue.     
	//   Will this become the highest-priority queue? 
	if (queuenumber > m.firstnonemptyq)
	{
	  // Yes, this is the highest-priority queue. 
	  m.nextnonemptyq[queuenumber] = m.firstnonemptyq;
	  m.firstnonemptyq = queuenumber;
	}
	else
	{
	  // No, this is not the highest-priority queue. 
	  //   Find the queue with next higher priority. 
	  i = queuenumber + 1;
	  while (m.queuefront[i] == (badtriang) null)
	  {
		i++;
	  }
	  // Mark the newly nonempty queue as following a higher-priority queue. 
	  m.nextnonemptyq[queuenumber] = m.nextnonemptyq[i];
	  m.nextnonemptyq[i] = queuenumber;
	}
	// Put the bad triangle at the beginning of the (empty) queue. 
	m.queuefront[queuenumber] = badtri;
	  }
  else
  {
	// Add the bad triangle to the end of an already nonempty queue. 
	m.queuetail[queuenumber].nexttriang = badtri;
  }
  // Maintain a pointer to the last triangle of the queue. 
  m.queuetail[queuenumber] = badtri;
  // Newly enqueued bad triangle has no successor in the queue. 
  badtri.nexttriang = (badtriang) null;
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  enqueuebadtri()   Add a bad triangle to the end of a queue.              
//                                                                           
//  Allocates a badtriang data structure for the triangle, then passes it to 
//  enqueuebadtriang().                                                      
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
void GlobalMembersTriangle.enqueuebadtri(struct mesh m, struct behavior b, struct otri *enqtri, GlobalMembersTriangle.REAL minedge, GlobalMembersTriangle.REAL * enqapex, GlobalMembersTriangle.REAL * enqorg, GlobalMembersTriangle.REAL * enqdest)
//#else
void GlobalMembersTriangle.enqueuebadtri(m, b, enqtri, minedge, enqapex, enqorg, enqdest)
mesh m;
behavior b;
otri enqtri;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL minedge;
GlobalMembersTriangle.REAL enqapex;
GlobalMembersTriangle.REAL enqorg;
GlobalMembersTriangle.REAL enqdest;
//#endif // not ANSI_DECLARATORS

{
  badtriang newbad;

  // Allocate space for the bad triangle. 
  newbad = (badtriang) GlobalMembersTriangle.poolalloc(m.badtriangles);
  newbad.poortri = (GlobalMembersTriangle.REAL)((int) enqtri.tri | (int) enqtri.orient);
  newbad.key = minedge;
  newbad.triangapex = enqapex;
  newbad.triangorg = enqorg;
  newbad.triangdest = enqdest;
  GlobalMembersTriangle.enqueuebadtriang(m, b, newbad);
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  dequeuebadtriang()   Remove a triangle from the front of the queue.      
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
struct badtriang *GlobalMembersTriangle.dequeuebadtriang(struct mesh m)
//#else
struct badtriang *GlobalMembersTriangle.dequeuebadtriang(m)
mesh m;
//#endif // not ANSI_DECLARATORS

{
  badtriang result;

  // If no queues are nonempty, return NULL. 
  if (m.firstnonemptyq < 0)
  {
	return (badtriang) null;
  }
  // Find the first triangle of the highest-priority queue. 
  result = m.queuefront[m.firstnonemptyq];
  // Remove the triangle from the queue. 
  m.queuefront[m.firstnonemptyq] = result.nexttriang;
  // If this queue is now empty, note the new highest-priority 
  //   nonempty queue.                                         
  if (result == m.queuetail[m.firstnonemptyq])
  {
	m.firstnonemptyq = m.nextnonemptyq[m.firstnonemptyq];
  }
  return result;
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  checkseg4encroach()   Check a subsegment to see if it is encroached; add 
//                        it to the list if it is.                           
//                                                                           
//  A subsegment is encroached if there is a vertex in its diametral lens.   
//  For Ruppert's algorithm (-D switch), the "diametral lens" is the         
//  diametral circle.  For Chew's algorithm (default), the diametral lens is 
//  just big enough to enclose two isosceles triangles whose bases are the   
//  subsegment.  Each of the two isosceles triangles has two angles equal    
//  to `b->minangle'.                                                        
//                                                                           
//  Chew's algorithm does not require diametral lenses at all--but they save 
//  time.  Any vertex inside a subsegment's diametral lens implies that the  
//  triangle adjoining the subsegment will be too skinny, so it's only a     
//  matter of time before the encroaching vertex is deleted by Chew's        
//  algorithm.  It's faster to simply not insert the doomed vertex in the    
//  first place, which is why I use diametral lenses with Chew's algorithm.  
//                                                                           
//  Returns a nonzero value if the subsegment is encroached.                 
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int GlobalMembersTriangle.checkseg4encroach(struct mesh m, struct behavior b, struct osub *testsubseg)
//#else
int GlobalMembersTriangle.checkseg4encroach(m, b, testsubseg)
mesh m;
behavior b;
osub testsubseg;
//#endif // not ANSI_DECLARATORS

{
  otri neighbortri = new otri();
  osub testsym = new osub();
  badsubseg encroachedseg;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL dotproduct;
  int encroached;
  int sides;
  GlobalMembersTriangle.REAL eorg;
  GlobalMembersTriangle.REAL edest;
  GlobalMembersTriangle.REAL eapex;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by stpivot().

  encroached = 0;
  sides = 0;

  eorg = (GlobalMembersTriangle.REAL) testsubseg.ss[2 + testsubseg.ssorient];
  edest = (GlobalMembersTriangle.REAL) testsubseg.ss[3 - testsubseg.ssorient];
  // Check one neighbor of the subsegment. 
  ptr = (GlobalMembersTriangle.REAL) testsubseg.ss[6 + testsubseg.ssorient];
  (neighbortri).orient = (int)((int)(ptr) & (int) 3l);
  (neighbortri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(neighbortri).orient);
  // Does the neighbor exist, or is this a boundary edge? 
  if (neighbortri.tri != m.dummytri)
  {
	sides++;
	// Find a vertex opposite this subsegment. 
	eapex = (GlobalMembersTriangle.REAL)(neighbortri).tri[(neighbortri).orient + 3];
	// Check whether the apex is in the diametral lens of the subsegment 
	//   (the diametral circle if `conformdel' is set).  A dot product   
	//   of two sides of the triangle is used to check whether the angle 
	//   at the apex is greater than (180 - 2 `minangle') degrees (for   
	//   lenses; 90 degrees for diametral circles).                      
	dotproduct = (eorg[0] - eapex[0]) * (edest[0] - eapex[0]) + (eorg[1] - eapex[1]) * (edest[1] - eapex[1]);
	if (dotproduct < 0.0)
	{
	  if (b.conformdel != 0 || (dotproduct * dotproduct >= (2.0 b.goodangle - 1.0) * (2.0 b.goodangle - 1.0) * ((eorg[0] - eapex[0]) * (eorg[0] - eapex[0]) + (eorg[1] - eapex[1]) * (eorg[1] - eapex[1])) * ((edest[0] - eapex[0]) * (edest[0] - eapex[0]) + (edest[1] - eapex[1]) * (edest[1] - eapex[1]))))
	  {
		encroached = 1;
	  }
	}
  }
  // Check the other neighbor of the subsegment. 
  (testsym).ss = testsubseg.ss;
  (testsym).ssorient = 1 - testsubseg.ssorient;
  ptr = (GlobalMembersTriangle.REAL)(testsym).ss[6 + (testsym).ssorient];
  (neighbortri).orient = (int)((int)(ptr) & (int) 3l);
  (neighbortri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(neighbortri).orient);
  // Does the neighbor exist, or is this a boundary edge? 
  if (neighbortri.tri != m.dummytri)
  {
	sides++;
	// Find the other vertex opposite this subsegment. 
	eapex = (GlobalMembersTriangle.REAL)(neighbortri).tri[(neighbortri).orient + 3];
	// Check whether the apex is in the diametral lens of the subsegment 
	//   (or the diametral circle, if `conformdel' is set).              
	dotproduct = (eorg[0] - eapex[0]) * (edest[0] - eapex[0]) + (eorg[1] - eapex[1]) * (edest[1] - eapex[1]);
	if (dotproduct < 0.0)
	{
	  if (b.conformdel != 0 || (dotproduct * dotproduct >= (2.0 b.goodangle - 1.0) * (2.0 b.goodangle - 1.0) * ((eorg[0] - eapex[0]) * (eorg[0] - eapex[0]) + (eorg[1] - eapex[1]) * (eorg[1] - eapex[1])) * ((edest[0] - eapex[0]) * (edest[0] - eapex[0]) + (edest[1] - eapex[1]) * (edest[1] - eapex[1]))))
	  {
		encroached += 2;
	  }
	}
  }

  if (encroached != 0 && (b.nobisect == 0 || ((b.nobisect == 1) && (sides == 2))))
  {
	if (b.verbose > 2)
	{
	  System.out.printf("  Queueing encroached subsegment (%.12g, %.12g) (%.12g, %.12g).\n", eorg[0], eorg[1], edest[0], edest[1]);
	}
	// Add the subsegment to the list of encroached subsegments. 
	//   Be sure to get the orientation right.                   
	encroachedseg = (badsubseg) GlobalMembersTriangle.poolalloc(m.badsubsegs);
	if (encroached == 1)
	{
	  encroachedseg.encsubseg = (GlobalMembersTriangle.REAL)((int) testsubseg.ss | (int) testsubseg.ssorient);
	  encroachedseg.subsegorg = eorg;
	  encroachedseg.subsegdest = edest;
	}
	else
	{
	  encroachedseg.encsubseg = (GlobalMembersTriangle.REAL)((int)(testsym).ss | (int)(testsym).ssorient);
	  encroachedseg.subsegorg = edest;
	  encroachedseg.subsegdest = eorg;
	}
  }

  return encroached;
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  testtriangle()   Test a triangle for quality and size.                   
//                                                                           
//  Tests a triangle to see if it satisfies the minimum angle condition and  
//  the maximum area condition.  Triangles that aren't up to spec are added  
//  to the bad triangle queue.                                               
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.testtriangle(struct mesh m, struct behavior b, struct otri *testtri)
//#else
void GlobalMembersTriangle.testtriangle(m, b, testtri)
mesh m;
behavior b;
otri testtri;
//#endif // not ANSI_DECLARATORS

{
  otri tri1 = new otri();
  otri tri2 = new otri();
  osub testsub = new osub();
  GlobalMembersTriangle.REAL torg;
  GlobalMembersTriangle.REAL tdest;
  GlobalMembersTriangle.REAL tapex;
  GlobalMembersTriangle.REAL base1;
  GlobalMembersTriangle.REAL base2;
  GlobalMembersTriangle.REAL org1;
  GlobalMembersTriangle.REAL dest1;
  GlobalMembersTriangle.REAL org2;
  GlobalMembersTriangle.REAL dest2;
  GlobalMembersTriangle.REAL joinvertex;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL dxod;
  GlobalMembersTriangle.REAL dyod;
  GlobalMembersTriangle.REAL dxda;
  GlobalMembersTriangle.REAL dyda;
  GlobalMembersTriangle.REAL dxao;
  GlobalMembersTriangle.REAL dyao;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL dxod2;
  GlobalMembersTriangle.REAL dyod2;
  GlobalMembersTriangle.REAL dxda2;
  GlobalMembersTriangle.REAL dyda2;
  GlobalMembersTriangle.REAL dxao2;
  GlobalMembersTriangle.REAL dyao2;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL apexlen;
  GlobalMembersTriangle.REAL orglen;
  GlobalMembersTriangle.REAL destlen;
  GlobalMembersTriangle.REAL minedge;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL angle;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL area;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL dist1;
  GlobalMembersTriangle.REAL dist2;
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by oprev() and dnext().

  torg = (GlobalMembersTriangle.REAL) testtri.tri[GlobalMembersTriangle.plus1mod3[testtri.orient] + 3];
  tdest = (GlobalMembersTriangle.REAL) testtri.tri[GlobalMembersTriangle.minus1mod3[testtri.orient] + 3];
  tapex = (GlobalMembersTriangle.REAL) testtri.tri[testtri.orient + 3];
  dxod = torg[0] - tdest[0];
  dyod = torg[1] - tdest[1];
  dxda = tdest[0] - tapex[0];
  dyda = tdest[1] - tapex[1];
  dxao = tapex[0] - torg[0];
  dyao = tapex[1] - torg[1];
  dxod2 = dxod * dxod;
  dyod2 = dyod * dyod;
  dxda2 = dxda * dxda;
  dyda2 = dyda * dyda;
  dxao2 = dxao * dxao;
  dyao2 = dyao * dyao;
  // Find the lengths of the triangle's three edges. 
  apexlen = dxod2 + dyod2;
  orglen = dxda2 + dyda2;
  destlen = dxao2 + dyao2;

  if ((apexlen < orglen) && (apexlen < destlen))
  {
	// The edge opposite the apex is shortest. 
	minedge = apexlen;
	// Find the square of the cosine of the angle at the apex. 
	angle = dxda * dxao + dyda * dyao;
	angle = angle * angle / (orglen * destlen);
	base1 = torg;
	base2 = tdest;
	(tri1).tri = testtri.tri;
	(tri1).orient = testtri.orient;
  }
  else if (orglen < destlen)
  {
	// The edge opposite the origin is shortest. 
	minedge = orglen;
	// Find the square of the cosine of the angle at the origin. 
	angle = dxod * dxao + dyod * dyao;
	angle = angle * angle / (apexlen * destlen);
	base1 = tdest;
	base2 = tapex;
	(tri1).tri = testtri.tri;
	(tri1).orient = GlobalMembersTriangle.plus1mod3[testtri.orient];
  }
  else
  {
	// The edge opposite the destination is shortest. 
	minedge = destlen;
	// Find the square of the cosine of the angle at the destination. 
	angle = dxod * dxda + dyod * dyda;
	angle = angle * angle / (apexlen * orglen);
	base1 = tapex;
	base2 = torg;
	(tri1).tri = testtri.tri;
	(tri1).orient = GlobalMembersTriangle.minus1mod3[testtri.orient];
  }

  if (b.vararea != 0 || b.fixedarea || b.usertest != 0)
  {
	// Check whether the area is larger than permitted. 
	area = 0.5 * (dxod * dyda - dyod * dxda);
	if (b.fixedarea != 0 && (area > b.maxarea))
	{
	  // Add this triangle to the list of bad triangles. 
	  GlobalMembersTriangle.enqueuebadtri(m, b, testtri, minedge, tapex, torg, tdest);
	  return;
	}

	// Nonpositive area constraints are treated as unconstrained. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	if ((b.vararea) && (area > ((GlobalMembersTriangle.REAL) testtri.tri)[m.areaboundindex]) && (((GlobalMembersTriangle.REAL) testtri.tri)[m.areaboundindex] > 0.0))
	{
	  // Add this triangle to the list of bad triangles. 
	  GlobalMembersTriangle.enqueuebadtri(m, b, testtri, minedge, tapex, torg, tdest);
	  return;
	}

	if (b.usertest != 0)
	{
	  // Check whether the user thinks this triangle is too large. 
	  if GlobalMembersTriangle.triunsuitable(torg, tdest, tapex, area)
	  {
		GlobalMembersTriangle.enqueuebadtri(m, b, testtri, minedge, tapex, torg, tdest);
		return;
	  }
	}
  }

  // Check whether the angle is smaller than permitted. 
  if (angle > b.goodangle)
  {
	// Use the rules of Miller, Pav, and Walkington to decide that certain 
	//   triangles should not be split, even if they have bad angles.      
	//   A skinny triangle is not split if its shortest edge subtends a    
	//   small input angle, and both endpoints of the edge lie on a        
	//   concentric circular shell.  For convenience, I make a small       
	//   adjustment to that rule:  I check if the endpoints of the edge    
	//   both lie in segment interiors, equidistant from the apex where    
	//   the two segments meet.                                            
	// First, check if both points lie in segment interiors.               
	if ((((int)(base1))[m.vertexmarkindex + 1] == DefineConstantsTriangle.SEGMENTVERTEX) && (((int)(base2))[m.vertexmarkindex + 1] == DefineConstantsTriangle.SEGMENTVERTEX))
	{
	  // Check if both points lie in a common segment.  If they do, the 
	  //   skinny triangle is enqueued to be split as usual.            
	  sptr = (GlobalMembersTriangle.REAL)(tri1).tri[6 + (tri1).orient];
	  (testsub).ssorient = (int)((int)(sptr) & (int) 1l);
	  (testsub).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  if (testsub.ss == m.dummysub)
	  {
		// No common segment.  Find a subsegment that contains `torg'. 
		(tri2).tri = (tri1).tri;
		(tri2).orient = (tri1).orient;
		do
		{
		  ptr = (tri1).tri[(tri1).orient];
		  (tri1).orient = (int)((int)(ptr) & (int) 3l);
		  (tri1).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(tri1).orient);
		  ;
		  (tri1).orient = GlobalMembersTriangle.plus1mod3[(tri1).orient];
		  ;
		  sptr = (GlobalMembersTriangle.REAL)(tri1).tri[6 + (tri1).orient];
		  (testsub).ssorient = (int)((int)(sptr) & (int) 1l);
		  (testsub).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		} while (testsub.ss == m.dummysub);
		// Find the endpoints of the containing segment. 
		org1 = (GlobalMembersTriangle.REAL)(testsub).ss[4 + (testsub).ssorient];
		dest1 = (GlobalMembersTriangle.REAL)(testsub).ss[5 - (testsub).ssorient];
		// Find a subsegment that contains `tdest'. 
		do
		{
		  ptr = (tri2).tri[(tri2).orient];
		  (tri2).orient = (int)((int)(ptr) & (int) 3l);
		  (tri2).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(tri2).orient);
		  ;
		  (tri2).orient = GlobalMembersTriangle.minus1mod3[(tri2).orient];
		  ;
		  sptr = (GlobalMembersTriangle.REAL)(tri2).tri[6 + (tri2).orient];
		  (testsub).ssorient = (int)((int)(sptr) & (int) 1l);
		  (testsub).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		} while (testsub.ss == m.dummysub);
		// Find the endpoints of the containing segment. 
		org2 = (GlobalMembersTriangle.REAL)(testsub).ss[4 + (testsub).ssorient];
		dest2 = (GlobalMembersTriangle.REAL)(testsub).ss[5 - (testsub).ssorient];
		// Check if the two containing segments have an endpoint in common. 
		joinvertex = (GlobalMembersTriangle.REAL) null;
		if ((dest1[0] == org2[0]) && (dest1[1] == org2[1]))
		{
		  joinvertex = dest1;
		}
		else if ((org1[0] == dest2[0]) && (org1[1] == dest2[1]))
		{
		  joinvertex = org1;
		}
		if (joinvertex != (GlobalMembersTriangle.REAL) null)
		{
		  // Compute the distance from the common endpoint (of the two  
		  //   segments) to each of the endpoints of the shortest edge. 
		  dist1 = ((base1[0] - joinvertex[0]) * (base1[0] - joinvertex[0]) + (base1[1] - joinvertex[1]) * (base1[1] - joinvertex[1]));
		  dist2 = ((base2[0] - joinvertex[0]) * (base2[0] - joinvertex[0]) + (base2[1] - joinvertex[1]) * (base2[1] - joinvertex[1]));
		  // If the two distances are equal, don't split the triangle. 
		  if ((dist1 < 1.001 * dist2) && (dist1 > 0.999 * dist2))
		  {
			// Return now to avoid enqueueing the bad triangle. 
			return;
		  }
		}
	  }
	}

	// Add this triangle to the list of bad triangles. 
	GlobalMembersTriangle.enqueuebadtri(m, b, testtri, minedge, tapex, torg, tdest);
  }
}

//#endif // not CDT_ONLY

//*                                                                         *
//*                                                                         *
//******** Mesh quality testing routines end here                    ********

//******** Point location routines begin here                        ********
//*                                                                         *
//*                                                                         *

//***************************************************************************
//                                                                           
//  makevertexmap()   Construct a mapping from vertices to triangles to      
//                    improve the speed of point location for segment        
//                    insertion.                                             
//                                                                           
//  Traverses all the triangles, and provides each corner of each triangle   
//  with a pointer to that triangle.  Of course, pointers will be            
//  overwritten by other pointers because (almost) each vertex is a corner   
//  of several triangles, but in the end every vertex will point to some     
//  triangle that contains it.                                               
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.makevertexmap(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.makevertexmap(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri triangleloop = new otri();
  GlobalMembersTriangle.REAL triorg.argvalue;

  if (b.verbose != 0)
  {
	System.out.print("    Constructing mapping from vertices to triangles.\n");
  }
  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	// Check all three vertices of the triangle. 
	for (triangleloop.orient = 0; triangleloop.orient < 3; triangleloop.orient++)
	{
	  triorg.argvalue = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.plus1mod3[(triangleloop).orient] + 3];
	  ((GlobalMembersTriangle.REAL ** *)(triorg.argvalue))[m.vertex2triindex] = (GlobalMembersTriangle.REAL)((int)(triangleloop).tri | (int)(triangleloop).orient);
	}
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  }
}

//***************************************************************************
//                                                                           
//  preciselocate()   Find a triangle or edge containing a given point.      
//                                                                           
//  Begins its search from `searchtri'.  It is important that `searchtri'    
//  be a handle with the property that `searchpoint' is strictly to the left 
//  of the edge denoted by `searchtri', or is collinear with that edge and   
//  does not intersect that edge.  (In particular, `searchpoint' should not  
//  be the origin or destination of that edge.)                              
//                                                                           
//  These conditions are imposed because preciselocate() is normally used in 
//  one of two situations:                                                   
//                                                                           
//  (1)  To try to find the location to insert a new point.  Normally, we    
//       know an edge that the point is strictly to the left of.  In the     
//       incremental Delaunay algorithm, that edge is a bounding box edge.   
//       In Ruppert's Delaunay refinement algorithm for quality meshing,     
//       that edge is the shortest edge of the triangle whose circumcenter   
//       is being inserted.                                                  
//                                                                           
//  (2)  To try to find an existing point.  In this case, any edge on the    
//       convex hull is a good starting edge.  You must screen out the       
//       possibility that the vertex sought is an endpoint of the starting   
//       edge before you call preciselocate().                               
//                                                                           
//  On completion, `searchtri' is a triangle that contains `searchpoint'.    
//                                                                           
//  This implementation differs from that given by Guibas and Stolfi.  It    
//  walks from triangle to triangle, crossing an edge only if `searchpoint'  
//  is on the other side of the line containing that edge.  After entering   
//  a triangle, there are two edges by which one can leave that triangle.    
//  If both edges are valid (`searchpoint' is on the other side of both      
//  edges), one of the two is chosen by drawing a line perpendicular to      
//  the entry edge (whose endpoints are `forg' and `fdest') passing through  
//  `fapex'.  Depending on which side of this perpendicular `searchpoint'    
//  falls on, an exit edge is chosen.                                        
//                                                                           
//  This implementation is empirically faster than the Guibas and Stolfi     
//  point location routine (which I originally used), which tends to spiral  
//  in toward its target.                                                    
//                                                                           
//  Returns ONVERTEX if the point lies on an existing vertex.  `searchtri'   
//  is a handle whose origin is the existing vertex.                         
//                                                                           
//  Returns ONEDGE if the point lies on a mesh edge.  `searchtri' is a       
//  handle whose primary edge is the edge on which the point lies.           
//                                                                           
//  Returns INTRIANGLE if the point lies strictly within a triangle.         
//  `searchtri' is a handle on the triangle that contains the point.         
//                                                                           
//  Returns OUTSIDE if the point lies outside the mesh.  `searchtri' is a    
//  handle whose primary edge the point is to the right of.  This might      
//  occur when the circumcenter of a triangle falls just slightly outside    
//  the mesh due to floating-point roundoff error.  It also occurs when      
//  seeking a hole or region point that a foolish user has placed outside    
//  the mesh.                                                                
//                                                                           
//  If `stopatsubsegment' is nonzero, the search will stop if it tries to    
//  walk through a subsegment, and will return OUTSIDE.                      
//                                                                           
//  WARNING:  This routine is designed for convex triangulations, and will   
//  not generally work after the holes and concavities have been carved.     
//  However, it can still be used to find the circumcenter of a triangle, as 
//  long as the search is begun from the triangle in question.               
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
enum locateresult GlobalMembersTriangle.preciselocate(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL * searchpoint, struct otri *searchtri, int stopatsubsegment)
//#else
enum locateresult GlobalMembersTriangle.preciselocate(m, b, searchpoint, searchtri, stopatsubsegment)
mesh m;
behavior b;
GlobalMembersTriangle.REAL searchpoint;
otri searchtri;
int stopatsubsegment;
//#endif // not ANSI_DECLARATORS

{
  otri backtracktri = new otri();
  osub checkedge = new osub();
  GlobalMembersTriangle.REAL forg;
  GlobalMembersTriangle.REAL fdest;
  GlobalMembersTriangle.REAL fapex;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL orgorient;
  GlobalMembersTriangle.REAL destorient;
  int moveleft;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  if (b.verbose > 2)
  {
	System.out.printf("  Searching for point (%.12g, %.12g).\n", searchpoint[0], searchpoint[1]);
  }
  // Where are we? 
  forg = (GlobalMembersTriangle.REAL) searchtri.tri[GlobalMembersTriangle.plus1mod3[searchtri.orient] + 3];
  fdest = (GlobalMembersTriangle.REAL) searchtri.tri[GlobalMembersTriangle.minus1mod3[searchtri.orient] + 3];
  fapex = (GlobalMembersTriangle.REAL) searchtri.tri[searchtri.orient + 3];
  while (1)
  {
	if (b.verbose > 2)
	{
	  System.out.printf("    At (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n", forg[0], forg[1], fdest[0], fdest[1], fapex[0], fapex[1]);
	}
	// Check whether the apex is the point we seek. 
	if ((fapex[0] == searchpoint[0]) && (fapex[1] == searchpoint[1]))
	{
	  searchtri.orient = GlobalMembersTriangle.minus1mod3[searchtri.orient];
	  return locateresult.ONVERTEX;
	}
	// Does the point lie on the other side of the line defined by the 
	//   triangle edge opposite the triangle's destination?            
	destorient = GlobalMembersTriangle.counterclockwise(m, b, forg, fapex, searchpoint);
	// Does the point lie on the other side of the line defined by the 
	//   triangle edge opposite the triangle's origin?                 
	orgorient = GlobalMembersTriangle.counterclockwise(m, b, fapex, fdest, searchpoint);
	if (destorient > 0.0)
	{
	  if (orgorient > 0.0)
	  {
		// Move left if the inner product of (fapex - searchpoint) and  
		//   (fdest - forg) is positive.  This is equivalent to drawing 
		//   a line perpendicular to the line (forg, fdest) and passing 
		//   through `fapex', and determining which side of this line   
		//   `searchpoint' falls on.                                    
		moveleft = (fapex[0] - searchpoint[0]) * (fdest[0] - forg[0]) + (fapex[1] - searchpoint[1]) * (fdest[1] - forg[1]) > 0.0;
	  }
	  else
	  {
		moveleft = 1;
	  }
	  }
	else
	{
	  if (orgorient > 0.0)
	  {
		moveleft = 0;
	  }
	  else
	  {
		// The point we seek must be on the boundary of or inside this 
		//   triangle.                                                 
		if (destorient == 0.0)
		{
		  searchtri.orient = GlobalMembersTriangle.minus1mod3[searchtri.orient];
		  return locateresult.ONEDGE;
		}
		if (orgorient == 0.0)
		{
		  searchtri.orient = GlobalMembersTriangle.plus1mod3[searchtri.orient];
		  return locateresult.ONEDGE;
		}
		return locateresult.INTRIANGLE;
	  }
	}

	// Move to another triangle.  Leave a trace `backtracktri' in case 
	//   floating-point roundoff or some such bogey causes us to walk  
	//   off a boundary of the triangulation.                          
	if (moveleft != 0)
	{
	  (backtracktri).tri = searchtri.tri;
	  (backtracktri).orient = GlobalMembersTriangle.minus1mod3[searchtri.orient];
	  fdest = fapex;
	}
	else
	{
	  (backtracktri).tri = searchtri.tri;
	  (backtracktri).orient = GlobalMembersTriangle.plus1mod3[searchtri.orient];
	  forg = fapex;
	}
	ptr = (backtracktri).tri[(backtracktri).orient];
	searchtri.orient = (int)((int)(ptr) & (int) 3l);
	searchtri.tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int) searchtri.orient);
	;

	if (m.checksegments != 0 && stopatsubsegment != 0)
	{
	  // Check for walking through a subsegment. 
	  sptr = (GlobalMembersTriangle.REAL)(backtracktri).tri[6 + (backtracktri).orient];
	  (checkedge).ssorient = (int)((int)(sptr) & (int) 1l);
	  (checkedge).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  if (checkedge.ss != m.dummysub)
	  {
		// Go back to the last triangle. 
		searchtri.tri = (backtracktri).tri;
		searchtri.orient = (backtracktri).orient;
		return locateresult.OUTSIDE;
	  }
	}
	// Check for walking right out of the triangulation. 
	if (searchtri.tri == m.dummytri)
	{
	  // Go back to the last triangle. 
	  searchtri.tri = (backtracktri).tri;
	  searchtri.orient = (backtracktri).orient;
	  return locateresult.OUTSIDE;
	}

	fapex = (GlobalMembersTriangle.REAL) searchtri.tri[searchtri.orient + 3];
  }
}

//***************************************************************************
//                                                                           
//  locate()   Find a triangle or edge containing a given point.             
//                                                                           
//  Searching begins from one of:  the input `searchtri', a recently         
//  encountered triangle `recenttri', or from a triangle chosen from a       
//  random sample.  The choice is made by determining which triangle's       
//  origin is closest to the point we are searching for.  Normally,          
//  `searchtri' should be a handle on the convex hull of the triangulation.  
//                                                                           
//  Details on the random sampling method can be found in the Mucke, Saias,  
//  and Zhu paper cited in the header of this code.                          
//                                                                           
//  On completion, `searchtri' is a triangle that contains `searchpoint'.    
//                                                                           
//  Returns ONVERTEX if the point lies on an existing vertex.  `searchtri'   
//  is a handle whose origin is the existing vertex.                         
//                                                                           
//  Returns ONEDGE if the point lies on a mesh edge.  `searchtri' is a       
//  handle whose primary edge is the edge on which the point lies.           
//                                                                           
//  Returns INTRIANGLE if the point lies strictly within a triangle.         
//  `searchtri' is a handle on the triangle that contains the point.         
//                                                                           
//  Returns OUTSIDE if the point lies outside the mesh.  `searchtri' is a    
//  handle whose primary edge the point is to the right of.  This might      
//  occur when the circumcenter of a triangle falls just slightly outside    
//  the mesh due to floating-point roundoff error.  It also occurs when      
//  seeking a hole or region point that a foolish user has placed outside    
//  the mesh.                                                                
//                                                                           
//  WARNING:  This routine is designed for convex triangulations, and will   
//  not generally work after the holes and concavities have been carved.     
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
enum locateresult GlobalMembersTriangle.locate(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL searchpoint, struct otri searchtri)
//#else
enum locateresult GlobalMembersTriangle.locate(m, b, searchpoint, searchtri)
mesh m;
behavior b;
GlobalMembersTriangle.REAL searchpoint;
otri searchtri;
//#endif // not ANSI_DECLARATORS

{
  int[] sampleblock;
  String firsttri;
  otri sampletri = new otri();
  GlobalMembersTriangle.REAL torg;
  GlobalMembersTriangle.REAL tdest;
  int alignptr;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL searchdist;
  GlobalMembersTriangle.REAL dist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL ahead;
  int samplesperblock;
  int totalsamplesleft;
  int samplesleft;
  int population;
  int totalpopulation;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().

  if (b.verbose > 2)
  {
	System.out.printf("  Randomly sampling for a triangle near point (%.12g, %.12g).\n", searchpoint[0], searchpoint[1]);
  }
  // Record the distance from the suggested starting triangle to the 
  //   point we seek.                                                
  torg = (GlobalMembersTriangle.REAL) searchtri.tri[GlobalMembersTriangle.plus1mod3[searchtri.orient] + 3];
  searchdist = (searchpoint[0] - torg[0]) * (searchpoint[0] - torg[0]) + (searchpoint[1] - torg[1]) * (searchpoint[1] - torg[1]);
  if (b.verbose > 2)
  {
	System.out.printf("    Boundary triangle has origin (%.12g, %.12g).\n", torg[0], torg[1]);
  }

  // If a recently encountered triangle has been recorded and has not been 
  //   deallocated, test it as a good starting point.                      
  if (m.recenttri.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	if (!((m.recenttri.tri)[1] == (GlobalMembersTriangle.REAL) null))
	{
	  torg = (GlobalMembersTriangle.REAL)(m.recenttri).tri[GlobalMembersTriangle.plus1mod3[(m.recenttri).orient] + 3];
	  if ((torg[0] == searchpoint[0]) && (torg[1] == searchpoint[1]))
	  {
		searchtri.tri = (m.recenttri).tri;
		searchtri.orient = (m.recenttri).orient;
		return locateresult.ONVERTEX;
	  }
	  dist = (searchpoint[0] - torg[0]) * (searchpoint[0] - torg[0]) + (searchpoint[1] - torg[1]) * (searchpoint[1] - torg[1]);
	  if (dist < searchdist)
	  {
		searchtri.tri = (m.recenttri).tri;
		searchtri.orient = (m.recenttri).orient;
		searchdist = dist;
		if (b.verbose > 2)
		{
		  System.out.printf("    Choosing recent triangle with origin (%.12g, %.12g).\n", torg[0], torg[1]);
		}
	  }
	}
  }

  // The number of random samples taken is proportional to the cube root of 
  //   the number of triangles in the mesh.  The next bit of code assumes   
  //   that the number of triangles increases monotonically (or at least    
  //   doesn't decrease enough to matter).                                  
  while (DefineConstantsTriangle.SAMPLEFACTOR m.samples m.samples m.samples < m.triangles.items)
  {
	m.samples++;
  }

  // We'll draw ceiling(samples * TRIPERBLOCK / maxitems) random samples  
  //   from each block of triangles (except the first)--until we meet the 
  //   sample quota.  The ceiling means that blocks at the end might be   
  //   neglected, but I don't care.                                       
  samplesperblock = (m.samples * DefineConstantsTriangle.TRIPERBLOCK - 1) / m.triangles.maxitems + 1;
  // We'll draw ceiling(samples * itemsfirstblock / maxitems) random samples 
  //   from the first block of triangles.                                    
  samplesleft = (m.samples m.triangles.itemsfirstblock - 1) / m.triangles.maxitems + 1;
  totalsamplesleft = m.samples;
  population = m.triangles.itemsfirstblock;
  totalpopulation = m.triangles.maxitems;
  sampleblock = m.triangles.firstblock;
  sampletri.orient = 0;
  while (totalsamplesleft > 0)
  {
	// If we're in the last block, `population' needs to be corrected. 
	if (population > totalpopulation)
	{
	  population = totalpopulation;
	}
	// Find a pointer to the first triangle in the block. 
	alignptr = (int)(sampleblock + 1);
	firsttri = (char)(alignptr + (int) m.triangles.alignbytes - (alignptr % (int) m.triangles.alignbytes));

	// Choose `samplesleft' randomly sampled triangles in this block. 
	do
	{
	  sampletri.tri = (GlobalMembersTriangle.REAL ** *)(firsttri + (GlobalMembersTriangle.randomnation((int) population) m.triangles.itembytes));
	  if (!((sampletri.tri)[1] == (GlobalMembersTriangle.REAL) null))
	  {
		torg = (GlobalMembersTriangle.REAL)(sampletri).tri[GlobalMembersTriangle.plus1mod3[(sampletri).orient] + 3];
		dist = (searchpoint[0] - torg[0]) * (searchpoint[0] - torg[0]) + (searchpoint[1] - torg[1]) * (searchpoint[1] - torg[1]);
		if (dist < searchdist)
		{
		  searchtri.tri = (sampletri).tri;
		  searchtri.orient = (sampletri).orient;
		  searchdist = dist;
		  if (b.verbose > 2)
		  {
			System.out.printf("    Choosing triangle with origin (%.12g, %.12g).\n", torg[0], torg[1]);
		  }
		}
	  }

	  samplesleft--;
	  totalsamplesleft--;
	} while ((samplesleft > 0) && (totalsamplesleft > 0));

	if (totalsamplesleft > 0)
	{
	  sampleblock = (int) *sampleblock;
	  samplesleft = samplesperblock;
	  totalpopulation -= population;
	  population = DefineConstantsTriangle.TRIPERBLOCK;
	}
  }

  // Where are we? 
  torg = (GlobalMembersTriangle.REAL) searchtri.tri[GlobalMembersTriangle.plus1mod3[searchtri.orient] + 3];
  tdest = (GlobalMembersTriangle.REAL) searchtri.tri[GlobalMembersTriangle.minus1mod3[searchtri.orient] + 3];
  // Check the starting triangle's vertices. 
  if ((torg[0] == searchpoint[0]) && (torg[1] == searchpoint[1]))
  {
	return locateresult.ONVERTEX;
  }
  if ((tdest[0] == searchpoint[0]) && (tdest[1] == searchpoint[1]))
  {
	searchtri.orient = GlobalMembersTriangle.plus1mod3[searchtri.orient];
	return locateresult.ONVERTEX;
  }
  // Orient `searchtri' to fit the preconditions of calling preciselocate(). 
  ahead = GlobalMembersTriangle.counterclockwise(m, b, torg, tdest, searchpoint);
  if (ahead < 0.0)
  {
	// Turn around so that `searchpoint' is to the left of the 
	//   edge specified by `searchtri'.                        
	ptr = searchtri.tri[searchtri.orient];
	searchtri.orient = (int)((int)(ptr) & (int) 3l);
	searchtri.tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int) searchtri.orient);
	;
  }
  else if (ahead == 0.0)
  {
	// Check if `searchpoint' is between `torg' and `tdest'. 
	if (((torg[0] < searchpoint[0]) == (searchpoint[0] < tdest[0])) && ((torg[1] < searchpoint[1]) == (searchpoint[1] < tdest[1])))
	{
	  return locateresult.ONEDGE;
	}
  }
  return GlobalMembersTriangle.preciselocate(m, b, searchpoint, searchtri, 0);
}

//*                                                                         *
//*                                                                         *
//******** Point location routines end here                          ********

//******** Mesh transformation routines begin here                   ********
//*                                                                         *
//*                                                                         *

//***************************************************************************
//                                                                           
//  insertsubseg()   Create a new subsegment and insert it between two       
//                   triangles.                                              
//                                                                           
//  The new subsegment is inserted at the edge described by the handle       
//  `tri'.  Its vertices are properly initialized.  The marker `subsegmark'  
//  is applied to the subsegment and, if appropriate, its vertices.          
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.insertsubseg(struct mesh m, struct behavior b, struct otri *tri, int subsegmark)
//#else
void GlobalMembersTriangle.insertsubseg(m, b, tri, subsegmark)
mesh m;
behavior b;
otri tri; // Edge at which to insert the new subsegment.
int subsegmark; // Marker for the new subsegment.
//#endif // not ANSI_DECLARATORS

{
  otri oppotri = new otri();
  osub newsubseg = new osub();
  GlobalMembersTriangle.REAL triorg.argvalue;
  GlobalMembersTriangle.REAL tridest.argvalue;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  triorg.argvalue = (GlobalMembersTriangle.REAL) tri.tri[GlobalMembersTriangle.plus1mod3[tri.orient] + 3];
  tridest.argvalue = (GlobalMembersTriangle.REAL) tri.tri[GlobalMembersTriangle.minus1mod3[tri.orient] + 3];
  // Mark vertices if possible. 
  if (((int)(triorg.argvalue))[m.vertexmarkindex] == 0)
  {
	((int)(triorg.argvalue))[m.vertexmarkindex] = subsegmark;
  }
  if (((int)(tridest.argvalue))[m.vertexmarkindex] == 0)
  {
	((int)(tridest.argvalue))[m.vertexmarkindex] = subsegmark;
  }
  // Check if there's already a subsegment here. 
  sptr = (GlobalMembersTriangle.REAL) tri.tri[6 + tri.orient];
  (newsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
  (newsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
  if (newsubseg.ss == m.dummysub)
  {
	// Make new subsegment and initialize its vertices. 
	GlobalMembersTriangle.makesubseg(m, newsubseg);
	(newsubseg).ss[2 + (newsubseg).ssorient] = (GlobalMembersTriangle.REAL) tridest.argvalue;
	(newsubseg).ss[3 - (newsubseg).ssorient] = (GlobalMembersTriangle.REAL) triorg.argvalue;
	(newsubseg).ss[4 + (newsubseg).ssorient] = (GlobalMembersTriangle.REAL) tridest.argvalue;
	(newsubseg).ss[5 - (newsubseg).ssorient] = (GlobalMembersTriangle.REAL) triorg.argvalue;
	// Bond new subsegment to the two triangles it is sandwiched between. 
	//   Note that the facing triangle `oppotri' might be equal to        
	//   `dummytri' (outer space), but the new subsegment is bonded to it 
	//   all the same.                                                    
	tri.tri[6 + tri.orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(newsubseg).ss | (int)(newsubseg).ssorient);
	(newsubseg).ss[6 + (newsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int) tri.tri | (int) tri.orient);
	ptr = tri.tri[tri.orient];
	(oppotri).orient = (int)((int)(ptr) & (int) 3l);
	(oppotri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(oppotri).orient);
	;
	(newsubseg).ssorient = 1 - (newsubseg).ssorient;
	(oppotri).tri[6 + (oppotri).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(newsubseg).ss | (int)(newsubseg).ssorient);
	(newsubseg).ss[6 + (newsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(oppotri).tri | (int)(oppotri).orient);
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
//	* (int *)((newsubseg).ss + 8) = subsegmark;
	if (b.verbose > 2)
	{
	  System.out.print("  Inserting new ");
	  GlobalMembersTriangle.printsubseg(m, b, newsubseg);
	}
	}
  else
  {
	if ((* (int)((newsubseg).ss + 8)) == 0)
	{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
//	  * (int *)((newsubseg).ss + 8) = subsegmark;
	}
  }
}

//***************************************************************************
//                                                                           
//  Terminology                                                              
//                                                                           
//  A "local transformation" replaces a small set of triangles with another  
//  set of triangles.  This may or may not involve inserting or deleting a   
//  vertex.                                                                  
//                                                                           
//  The term "casing" is used to describe the set of triangles that are      
//  attached to the triangles being transformed, but are not transformed     
//  themselves.  Think of the casing as a fixed hollow structure inside      
//  which all the action happens.  A "casing" is only defined relative to    
//  a single transformation; each occurrence of a transformation will        
//  involve a different casing.                                              
//                                                                           
//***************************************************************************

//***************************************************************************
//                                                                           
//  flip()   Transform two triangles to two different triangles by flipping  
//           an edge counterclockwise within a quadrilateral.                
//                                                                           
//  Imagine the original triangles, abc and bad, oriented so that the        
//  shared edge ab lies in a horizontal plane, with the vertex b on the left 
//  and the vertex a on the right.  The vertex c lies below the edge, and    
//  the vertex d lies above the edge.  The `flipedge' handle holds the edge  
//  ab of triangle abc, and is directed left, from vertex a to vertex b.     
//                                                                           
//  The triangles abc and bad are deleted and replaced by the triangles cdb  
//  and dca.  The triangles that represent abc and bad are NOT deallocated;  
//  they are reused for dca and cdb, respectively.  Hence, any handles that  
//  may have held the original triangles are still valid, although not       
//  directed as they were before.                                            
//                                                                           
//  Upon completion of this routine, the `flipedge' handle holds the edge    
//  dc of triangle dca, and is directed down, from vertex d to vertex c.     
//  (Hence, the two triangles have rotated counterclockwise.)                
//                                                                           
//  WARNING:  This transformation is geometrically valid only if the         
//  quadrilateral adbc is convex.  Furthermore, this transformation is       
//  valid only if there is not a subsegment between the triangles abc and    
//  bad.  This routine does not check either of these preconditions, and     
//  it is the responsibility of the calling routine to ensure that they are  
//  met.  If they are not, the streets shall be filled with wailing and      
//  gnashing of teeth.                                                       
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.flip(struct mesh m, struct behavior b, struct otri *flipedge)
//#else
void GlobalMembersTriangle.flip(m, b, flipedge)
mesh m;
behavior b;
otri flipedge; // Handle for the triangle abc.
//#endif // not ANSI_DECLARATORS

{
  otri botleft = new otri();
  otri botright = new otri();
  otri topleft = new otri();
  otri topright = new otri();
  otri top = new otri();
  otri botlcasing = new otri();
  otri botrcasing = new otri();
  otri toplcasing = new otri();
  otri toprcasing = new otri();
  osub botlsubseg = new osub();
  osub botrsubseg = new osub();
  osub toplsubseg = new osub();
  osub toprsubseg = new osub();
  GlobalMembersTriangle.REAL leftvertex;
  GlobalMembersTriangle.REAL rightvertex;
  GlobalMembersTriangle.REAL botvertex;
  GlobalMembersTriangle.REAL farvertex;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  // Identify the vertices of the quadrilateral. 
  rightvertex = (GlobalMembersTriangle.REAL) flipedge.tri[GlobalMembersTriangle.plus1mod3[flipedge.orient] + 3];
  leftvertex = (GlobalMembersTriangle.REAL) flipedge.tri[GlobalMembersTriangle.minus1mod3[flipedge.orient] + 3];
  botvertex = (GlobalMembersTriangle.REAL) flipedge.tri[flipedge.orient + 3];
  ptr = flipedge.tri[flipedge.orient];
  (top).orient = (int)((int)(ptr) & (int) 3l);
  (top).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(top).orient);
  ;
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if SELF_CHECK
  if (top.tri == m.dummytri)
  {
	System.out.print("Internal error in flip():  Attempt to flip on boundary.\n");
	flipedge.orient = GlobalMembersTriangle.plus1mod3[flipedge.orient];
	return;
  }
  if (m.checksegments != 0)
  {
	sptr = (GlobalMembersTriangle.REAL) flipedge.tri[6 + flipedge.orient];
	(toplsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(toplsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	if (toplsubseg.ss != m.dummysub)
	{
	  System.out.print("Internal error in flip():  Attempt to flip a segment.\n");
	  flipedge.orient = GlobalMembersTriangle.plus1mod3[flipedge.orient];
	  return;
	}
  }
//#endif // SELF_CHECK
  farvertex = (GlobalMembersTriangle.REAL)(top).tri[(top).orient + 3];

  // Identify the casing of the quadrilateral. 
  (topleft).tri = (top).tri;
  (topleft).orient = GlobalMembersTriangle.minus1mod3[(top).orient];
  ptr = (topleft).tri[(topleft).orient];
  (toplcasing).orient = (int)((int)(ptr) & (int) 3l);
  (toplcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(toplcasing).orient);
  ;
  (topright).tri = (top).tri;
  (topright).orient = GlobalMembersTriangle.plus1mod3[(top).orient];
  ptr = (topright).tri[(topright).orient];
  (toprcasing).orient = (int)((int)(ptr) & (int) 3l);
  (toprcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(toprcasing).orient);
  ;
  (botleft).tri = flipedge.tri;
  (botleft).orient = GlobalMembersTriangle.plus1mod3[flipedge.orient];
  ptr = (botleft).tri[(botleft).orient];
  (botlcasing).orient = (int)((int)(ptr) & (int) 3l);
  (botlcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botlcasing).orient);
  ;
  (botright).tri = flipedge.tri;
  (botright).orient = GlobalMembersTriangle.minus1mod3[flipedge.orient];
  ptr = (botright).tri[(botright).orient];
  (botrcasing).orient = (int)((int)(ptr) & (int) 3l);
  (botrcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botrcasing).orient);
  ;
  // Rotate the quadrilateral one-quarter turn counterclockwise. 
  (topleft).tri[(topleft).orient] = (GlobalMembersTriangle.REAL)((int)(botlcasing).tri | (int)(botlcasing).orient);
  (botlcasing).tri[(botlcasing).orient] = (GlobalMembersTriangle.REAL)((int)(topleft).tri | (int)(topleft).orient);
  (botleft).tri[(botleft).orient] = (GlobalMembersTriangle.REAL)((int)(botrcasing).tri | (int)(botrcasing).orient);
  (botrcasing).tri[(botrcasing).orient] = (GlobalMembersTriangle.REAL)((int)(botleft).tri | (int)(botleft).orient);
  (botright).tri[(botright).orient] = (GlobalMembersTriangle.REAL)((int)(toprcasing).tri | (int)(toprcasing).orient);
  (toprcasing).tri[(toprcasing).orient] = (GlobalMembersTriangle.REAL)((int)(botright).tri | (int)(botright).orient);
  (topright).tri[(topright).orient] = (GlobalMembersTriangle.REAL)((int)(toplcasing).tri | (int)(toplcasing).orient);
  (toplcasing).tri[(toplcasing).orient] = (GlobalMembersTriangle.REAL)((int)(topright).tri | (int)(topright).orient);

  if (m.checksegments != 0)
  {
	// Check for subsegments and rebond them to the quadrilateral. 
	sptr = (GlobalMembersTriangle.REAL)(topleft).tri[6 + (topleft).orient];
	(toplsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(toplsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	sptr = (GlobalMembersTriangle.REAL)(botleft).tri[6 + (botleft).orient];
	(botlsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(botlsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	sptr = (GlobalMembersTriangle.REAL)(botright).tri[6 + (botright).orient];
	(botrsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(botrsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	sptr = (GlobalMembersTriangle.REAL)(topright).tri[6 + (topright).orient];
	(toprsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(toprsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	if (toplsubseg.ss == m.dummysub)
	{
	  (topright).tri[6 + (topright).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
	}
	else
	{
	  (topright).tri[6 + (topright).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(toplsubseg).ss | (int)(toplsubseg).ssorient);
	  (toplsubseg).ss[6 + (toplsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(topright).tri | (int)(topright).orient);
	}
	if (botlsubseg.ss == m.dummysub)
	{
	  (topleft).tri[6 + (topleft).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
	}
	else
	{
	  (topleft).tri[6 + (topleft).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botlsubseg).ss | (int)(botlsubseg).ssorient);
	  (botlsubseg).ss[6 + (botlsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(topleft).tri | (int)(topleft).orient);
	}
	if (botrsubseg.ss == m.dummysub)
	{
	  (botleft).tri[6 + (botleft).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
	}
	else
	{
	  (botleft).tri[6 + (botleft).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botrsubseg).ss | (int)(botrsubseg).ssorient);
	  (botrsubseg).ss[6 + (botrsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botleft).tri | (int)(botleft).orient);
	}
	if (toprsubseg.ss == m.dummysub)
	{
	  (botright).tri[6 + (botright).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
	}
	else
	{
	  (botright).tri[6 + (botright).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(toprsubseg).ss | (int)(toprsubseg).ssorient);
	  (toprsubseg).ss[6 + (toprsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botright).tri | (int)(botright).orient);
	}
  }

  // New vertex assignments for the rotated quadrilateral. 
  flipedge.tri[GlobalMembersTriangle.plus1mod3[flipedge.orient] + 3] = (GlobalMembersTriangle.REAL) farvertex;
  flipedge.tri[GlobalMembersTriangle.minus1mod3[flipedge.orient] + 3] = (GlobalMembersTriangle.REAL) botvertex;
  flipedge.tri[flipedge.orient + 3] = (GlobalMembersTriangle.REAL) rightvertex;
  (top).tri[GlobalMembersTriangle.plus1mod3[(top).orient] + 3] = (GlobalMembersTriangle.REAL) botvertex;
  (top).tri[GlobalMembersTriangle.minus1mod3[(top).orient] + 3] = (GlobalMembersTriangle.REAL) farvertex;
  (top).tri[(top).orient + 3] = (GlobalMembersTriangle.REAL) leftvertex;
  if (b.verbose > 2)
  {
	System.out.print("  Edge flip results in left ");
	GlobalMembersTriangle.printtriangle(m, b, top);
	System.out.print("  and right ");
	GlobalMembersTriangle.printtriangle(m, b, flipedge);
  }
}

//***************************************************************************
//                                                                           
//  unflip()   Transform two triangles to two different triangles by         
//             flipping an edge clockwise within a quadrilateral.  Reverses  
//             the flip() operation so that the data structures representing 
//             the triangles are back where they were before the flip().     
//                                                                           
//  Imagine the original triangles, abc and bad, oriented so that the        
//  shared edge ab lies in a horizontal plane, with the vertex b on the left 
//  and the vertex a on the right.  The vertex c lies below the edge, and    
//  the vertex d lies above the edge.  The `flipedge' handle holds the edge  
//  ab of triangle abc, and is directed left, from vertex a to vertex b.     
//                                                                           
//  The triangles abc and bad are deleted and replaced by the triangles cdb  
//  and dca.  The triangles that represent abc and bad are NOT deallocated;  
//  they are reused for cdb and dca, respectively.  Hence, any handles that  
//  may have held the original triangles are still valid, although not       
//  directed as they were before.                                            
//                                                                           
//  Upon completion of this routine, the `flipedge' handle holds the edge    
//  cd of triangle cdb, and is directed up, from vertex c to vertex d.       
//  (Hence, the two triangles have rotated clockwise.)                       
//                                                                           
//  WARNING:  This transformation is geometrically valid only if the         
//  quadrilateral adbc is convex.  Furthermore, this transformation is       
//  valid only if there is not a subsegment between the triangles abc and    
//  bad.  This routine does not check either of these preconditions, and     
//  it is the responsibility of the calling routine to ensure that they are  
//  met.  If they are not, the streets shall be filled with wailing and      
//  gnashing of teeth.                                                       
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.unflip(struct mesh m, struct behavior b, struct otri flipedge)
//#else
void GlobalMembersTriangle.unflip(m, b, flipedge)
mesh m;
behavior b;
otri flipedge; // Handle for the triangle abc.
//#endif // not ANSI_DECLARATORS

{
  otri botleft = new otri();
  otri botright = new otri();
  otri topleft = new otri();
  otri topright = new otri();
  otri top = new otri();
  otri botlcasing = new otri();
  otri botrcasing = new otri();
  otri toplcasing = new otri();
  otri toprcasing = new otri();
  osub botlsubseg = new osub();
  osub botrsubseg = new osub();
  osub toplsubseg = new osub();
  osub toprsubseg = new osub();
  GlobalMembersTriangle.REAL leftvertex;
  GlobalMembersTriangle.REAL rightvertex;
  GlobalMembersTriangle.REAL botvertex;
  GlobalMembersTriangle.REAL farvertex;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  // Identify the vertices of the quadrilateral. 
  rightvertex = (GlobalMembersTriangle.REAL) flipedge.tri[GlobalMembersTriangle.plus1mod3[flipedge.orient] + 3];
  leftvertex = (GlobalMembersTriangle.REAL) flipedge.tri[GlobalMembersTriangle.minus1mod3[flipedge.orient] + 3];
  botvertex = (GlobalMembersTriangle.REAL) flipedge.tri[flipedge.orient + 3];
  ptr = flipedge.tri[flipedge.orient];
  (top).orient = (int)((int)(ptr) & (int) 3l);
  (top).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(top).orient);
  ;
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if SELF_CHECK
  if (top.tri == m.dummytri)
  {
	System.out.print("Internal error in unflip():  Attempt to flip on boundary.\n");
	flipedge.orient = GlobalMembersTriangle.plus1mod3[flipedge.orient];
	return;
  }
  if (m.checksegments != 0)
  {
	sptr = (GlobalMembersTriangle.REAL) flipedge.tri[6 + flipedge.orient];
	(toplsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(toplsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	if (toplsubseg.ss != m.dummysub)
	{
	  System.out.print("Internal error in unflip():  Attempt to flip a subsegment.\n");
	  flipedge.orient = GlobalMembersTriangle.plus1mod3[flipedge.orient];
	  return;
	}
  }
//#endif // SELF_CHECK
  farvertex = (GlobalMembersTriangle.REAL)(top).tri[(top).orient + 3];

  // Identify the casing of the quadrilateral. 
  (topleft).tri = (top).tri;
  (topleft).orient = GlobalMembersTriangle.minus1mod3[(top).orient];
  ptr = (topleft).tri[(topleft).orient];
  (toplcasing).orient = (int)((int)(ptr) & (int) 3l);
  (toplcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(toplcasing).orient);
  ;
  (topright).tri = (top).tri;
  (topright).orient = GlobalMembersTriangle.plus1mod3[(top).orient];
  ptr = (topright).tri[(topright).orient];
  (toprcasing).orient = (int)((int)(ptr) & (int) 3l);
  (toprcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(toprcasing).orient);
  ;
  (botleft).tri = flipedge.tri;
  (botleft).orient = GlobalMembersTriangle.plus1mod3[flipedge.orient];
  ptr = (botleft).tri[(botleft).orient];
  (botlcasing).orient = (int)((int)(ptr) & (int) 3l);
  (botlcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botlcasing).orient);
  ;
  (botright).tri = flipedge.tri;
  (botright).orient = GlobalMembersTriangle.minus1mod3[flipedge.orient];
  ptr = (botright).tri[(botright).orient];
  (botrcasing).orient = (int)((int)(ptr) & (int) 3l);
  (botrcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botrcasing).orient);
  ;
  // Rotate the quadrilateral one-quarter turn clockwise. 
  (topleft).tri[(topleft).orient] = (GlobalMembersTriangle.REAL)((int)(toprcasing).tri | (int)(toprcasing).orient);
  (toprcasing).tri[(toprcasing).orient] = (GlobalMembersTriangle.REAL)((int)(topleft).tri | (int)(topleft).orient);
  (botleft).tri[(botleft).orient] = (GlobalMembersTriangle.REAL)((int)(toplcasing).tri | (int)(toplcasing).orient);
  (toplcasing).tri[(toplcasing).orient] = (GlobalMembersTriangle.REAL)((int)(botleft).tri | (int)(botleft).orient);
  (botright).tri[(botright).orient] = (GlobalMembersTriangle.REAL)((int)(botlcasing).tri | (int)(botlcasing).orient);
  (botlcasing).tri[(botlcasing).orient] = (GlobalMembersTriangle.REAL)((int)(botright).tri | (int)(botright).orient);
  (topright).tri[(topright).orient] = (GlobalMembersTriangle.REAL)((int)(botrcasing).tri | (int)(botrcasing).orient);
  (botrcasing).tri[(botrcasing).orient] = (GlobalMembersTriangle.REAL)((int)(topright).tri | (int)(topright).orient);

  if (m.checksegments != 0)
  {
	// Check for subsegments and rebond them to the quadrilateral. 
	sptr = (GlobalMembersTriangle.REAL)(topleft).tri[6 + (topleft).orient];
	(toplsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(toplsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	sptr = (GlobalMembersTriangle.REAL)(botleft).tri[6 + (botleft).orient];
	(botlsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(botlsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	sptr = (GlobalMembersTriangle.REAL)(botright).tri[6 + (botright).orient];
	(botrsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(botrsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	sptr = (GlobalMembersTriangle.REAL)(topright).tri[6 + (topright).orient];
	(toprsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(toprsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	if (toplsubseg.ss == m.dummysub)
	{
	  (botleft).tri[6 + (botleft).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
	}
	else
	{
	  (botleft).tri[6 + (botleft).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(toplsubseg).ss | (int)(toplsubseg).ssorient);
	  (toplsubseg).ss[6 + (toplsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botleft).tri | (int)(botleft).orient);
	}
	if (botlsubseg.ss == m.dummysub)
	{
	  (botright).tri[6 + (botright).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
	}
	else
	{
	  (botright).tri[6 + (botright).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botlsubseg).ss | (int)(botlsubseg).ssorient);
	  (botlsubseg).ss[6 + (botlsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botright).tri | (int)(botright).orient);
	}
	if (botrsubseg.ss == m.dummysub)
	{
	  (topright).tri[6 + (topright).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
	}
	else
	{
	  (topright).tri[6 + (topright).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botrsubseg).ss | (int)(botrsubseg).ssorient);
	  (botrsubseg).ss[6 + (botrsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(topright).tri | (int)(topright).orient);
	}
	if (toprsubseg.ss == m.dummysub)
	{
	  (topleft).tri[6 + (topleft).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
	}
	else
	{
	  (topleft).tri[6 + (topleft).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(toprsubseg).ss | (int)(toprsubseg).ssorient);
	  (toprsubseg).ss[6 + (toprsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(topleft).tri | (int)(topleft).orient);
	}
  }

  // New vertex assignments for the rotated quadrilateral. 
  flipedge.tri[GlobalMembersTriangle.plus1mod3[flipedge.orient] + 3] = (GlobalMembersTriangle.REAL) botvertex;
  flipedge.tri[GlobalMembersTriangle.minus1mod3[flipedge.orient] + 3] = (GlobalMembersTriangle.REAL) farvertex;
  flipedge.tri[flipedge.orient + 3] = (GlobalMembersTriangle.REAL) leftvertex;
  (top).tri[GlobalMembersTriangle.plus1mod3[(top).orient] + 3] = (GlobalMembersTriangle.REAL) farvertex;
  (top).tri[GlobalMembersTriangle.minus1mod3[(top).orient] + 3] = (GlobalMembersTriangle.REAL) botvertex;
  (top).tri[(top).orient + 3] = (GlobalMembersTriangle.REAL) rightvertex;
  if (b.verbose > 2)
  {
	System.out.print("  Edge unflip results in left ");
	GlobalMembersTriangle.printtriangle(m, b, flipedge);
	System.out.print("  and right ");
	GlobalMembersTriangle.printtriangle(m, b, top);
  }
}

//***************************************************************************
//                                                                           
//  insertvertex()   Insert a vertex into a Delaunay triangulation,          
//                   performing flips as necessary to maintain the Delaunay  
//                   property.                                               
//                                                                           
//  The point `insertvertex' is located.  If `searchtri.tri' is not NULL,    
//  the search for the containing triangle begins from `searchtri'.  If      
//  `searchtri.tri' is NULL, a full point location procedure is called.      
//  If `insertvertex' is found inside a triangle, the triangle is split into 
//  three; if `insertvertex' lies on an edge, the edge is split in two,      
//  thereby splitting the two adjacent triangles into four.  Edge flips are  
//  used to restore the Delaunay property.  If `insertvertex' lies on an     
//  existing vertex, no action is taken, and the value DUPLICATEVERTEX is    
//  returned.  On return, `searchtri' is set to a handle whose origin is the 
//  existing vertex.                                                         
//                                                                           
//  Normally, the parameter `splitseg' is set to NULL, implying that no      
//  subsegment should be split.  In this case, if `insertvertex' is found to 
//  lie on a segment, no action is taken, and the value VIOLATINGVERTEX is   
//  returned.  On return, `searchtri' is set to a handle whose primary edge  
//  is the violated subsegment.                                              
//                                                                           
//  If the calling routine wishes to split a subsegment by inserting a       
//  vertex in it, the parameter `splitseg' should be that subsegment.  In    
//  this case, `searchtri' MUST be the triangle handle reached by pivoting   
//  from that subsegment; no point location is done.                         
//                                                                           
//  `segmentflaws' and `triflaws' are flags that indicate whether or not     
//  there should be checks for the creation of encroached subsegments or bad 
//  quality triangles.  If a newly inserted vertex encroaches upon           
//  subsegments, these subsegments are added to the list of subsegments to   
//  be split if `segmentflaws' is set.  If bad triangles are created, these  
//  are added to the queue if `triflaws' is set.                             
//                                                                           
//  If a duplicate vertex or violated segment does not prevent the vertex    
//  from being inserted, the return value will be ENCROACHINGVERTEX if the   
//  vertex encroaches upon a subsegment (and checking is enabled), or        
//  SUCCESSFULVERTEX otherwise.  In either case, `searchtri' is set to a     
//  handle whose origin is the newly inserted vertex.                        
//                                                                           
//  insertvertex() does not use flip() for reasons of speed; some            
//  information can be reused from edge flip to edge flip, like the          
//  locations of subsegments.                                                
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
enum insertvertexresult GlobalMembersTriangle.insertvertex(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL newvertex, struct otri searchtri, struct osub *splitseg, int segmentflaws, int triflaws)
//#else
enum insertvertexresult GlobalMembersTriangle.insertvertex(m, b, newvertex, searchtri, splitseg, segmentflaws, triflaws)
mesh m;
behavior b;
GlobalMembersTriangle.REAL newvertex;
otri searchtri;
osub splitseg;
int segmentflaws;
int triflaws;
//#endif // not ANSI_DECLARATORS

{
  otri horiz = new otri();
  otri top = new otri();
  otri botleft = new otri();
  otri botright = new otri();
  otri topleft = new otri();
  otri topright = new otri();
  otri newbotleft = new otri();
  otri newbotright = new otri();
  otri newtopright = new otri();
  otri botlcasing = new otri();
  otri botrcasing = new otri();
  otri toplcasing = new otri();
  otri toprcasing = new otri();
  otri testtri = new otri();
  osub botlsubseg = new osub();
  osub botrsubseg = new osub();
  osub toplsubseg = new osub();
  osub toprsubseg = new osub();
  osub brokensubseg = new osub();
  osub checksubseg = new osub();
  osub rightsubseg = new osub();
  osub newsubseg = new osub();
  badsubseg encroached;
  flipstacker newflip;
  GlobalMembersTriangle.REAL first;
  GlobalMembersTriangle.REAL leftvertex;
  GlobalMembersTriangle.REAL rightvertex;
  GlobalMembersTriangle.REAL botvertex;
  GlobalMembersTriangle.REAL topvertex;
  GlobalMembersTriangle.REAL farvertex;
  GlobalMembersTriangle.REAL segmentorg;
  GlobalMembersTriangle.REAL segmentdest;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL attrib;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL area;
  insertvertexresult success;
  locateresult intersect;
  int doflip;
  int mirrorflag;
  int enq;
  int i;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by spivot() and tspivot().

  if (b.verbose > 1)
  {
	System.out.printf("  Inserting (%.12g, %.12g).\n", newvertex[0], newvertex[1]);
  }

  if (splitseg == (osub) null)
  {
	// Find the location of the vertex to be inserted.  Check if a good 
	//   starting triangle has already been provided by the caller.     
	if (searchtri.tri == m.dummytri)
	{
	  // Find a boundary triangle. 
	  horiz.tri = m.dummytri;
	  horiz.orient = 0;
	  ptr = (horiz).tri[(horiz).orient];
	  (horiz).orient = (int)((int)(ptr) & (int) 3l);
	  (horiz).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(horiz).orient);
	  ;
	  // Search for a triangle containing `newvertex'. 
	  intersect = GlobalMembersTriangle.locate(m, b, newvertex, horiz);
	}
	else
	{
	  // Start searching from the triangle provided by the caller. 
	  (horiz).tri = searchtri.tri;
	  (horiz).orient = searchtri.orient;
	  intersect = GlobalMembersTriangle.preciselocate(m, b, newvertex, horiz, 1);
	}
	}
  else
  {
	// The calling routine provides the subsegment in which 
	//   the vertex is inserted.                             
	(horiz).tri = searchtri.tri;
	(horiz).orient = searchtri.orient;
	intersect = locateresult.ONEDGE;
  }

  if (intersect == locateresult.ONVERTEX)
  {
	// There's already a vertex there.  Return in `searchtri' a triangle 
	//   whose origin is the existing vertex.                            
	searchtri.tri = (horiz).tri;
	searchtri.orient = (horiz).orient;
	(m.recenttri).tri = (horiz).tri;
	(m.recenttri).orient = (horiz).orient;
	return insertvertexresult.DUPLICATEVERTEX;
  }
  if ((intersect == locateresult.ONEDGE) || (intersect == locateresult.OUTSIDE))
  {
	// The vertex falls on an edge or boundary. 
	if (m.checksegments != 0 && (splitseg == (osub) null))
	{
	  // Check whether the vertex falls on a subsegment. 
	  sptr = (GlobalMembersTriangle.REAL)(horiz).tri[6 + (horiz).orient];
	  (brokensubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (brokensubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  if (brokensubseg.ss != m.dummysub)
	  {
		// The vertex falls on a subsegment, and hence will not be inserted. 
		if (segmentflaws != 0)
		{
		  enq = b.nobisect != 2;
		  if (enq != 0 && (b.nobisect == 1))
		  {
			// This subsegment may be split only if it is an 
			//   internal boundary.                          
			ptr = (horiz).tri[(horiz).orient];
			(testtri).orient = (int)((int)(ptr) & (int) 3l);
			(testtri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(testtri).orient);
			;
			enq = testtri.tri != m.dummytri;
		  }
		  if (enq != 0)
		  {
			// Add the subsegment to the list of encroached subsegments. 
			encroached = (badsubseg) GlobalMembersTriangle.poolalloc(m.badsubsegs);
			encroached.encsubseg = (GlobalMembersTriangle.REAL)((int)(brokensubseg).ss | (int)(brokensubseg).ssorient);
			encroached.subsegorg = (GlobalMembersTriangle.REAL)(brokensubseg).ss[2 + (brokensubseg).ssorient];
			encroached.subsegdest = (GlobalMembersTriangle.REAL)(brokensubseg).ss[3 - (brokensubseg).ssorient];
			if (b.verbose > 2)
			{
			  System.out.printf("  Queueing encroached subsegment (%.12g, %.12g) (%.12g, %.12g).\n", encroached.subsegorg[0], encroached.subsegorg[1], encroached.subsegdest[0], encroached.subsegdest[1]);
			}
		  }
		}
		// Return a handle whose primary edge contains the vertex, 
		//   which has not been inserted.                          
		searchtri.tri = (horiz).tri;
		searchtri.orient = (horiz).orient;
		(m.recenttri).tri = (horiz).tri;
		(m.recenttri).orient = (horiz).orient;
		return insertvertexresult.VIOLATINGVERTEX;
	  }
	}

	// Insert the vertex on an edge, dividing one triangle into two (if 
	//   the edge lies on a boundary) or two triangles into four.       
	(botright).tri = (horiz).tri;
	(botright).orient = GlobalMembersTriangle.minus1mod3[(horiz).orient];
	ptr = (botright).tri[(botright).orient];
	(botrcasing).orient = (int)((int)(ptr) & (int) 3l);
	(botrcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botrcasing).orient);
	;
	ptr = (horiz).tri[(horiz).orient];
	(topright).orient = (int)((int)(ptr) & (int) 3l);
	(topright).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(topright).orient);
	;
	// Is there a second triangle?  (Or does this edge lie on a boundary?) 
	mirrorflag = topright.tri != m.dummytri;
	if (mirrorflag != 0)
	{
	  (topright).orient = GlobalMembersTriangle.plus1mod3[(topright).orient];
	  ptr = (topright).tri[(topright).orient];
	  (toprcasing).orient = (int)((int)(ptr) & (int) 3l);
	  (toprcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(toprcasing).orient);
	  ;
	  GlobalMembersTriangle.maketriangle(m, b, newtopright);
	}
	else
	{
	  // Splitting a boundary edge increases the number of boundary edges. 
	  m.hullsize++;
	}
	GlobalMembersTriangle.maketriangle(m, b, newbotright);

	// Set the vertices of changed and new triangles. 
	rightvertex = (GlobalMembersTriangle.REAL)(horiz).tri[GlobalMembersTriangle.plus1mod3[(horiz).orient] + 3];
	leftvertex = (GlobalMembersTriangle.REAL)(horiz).tri[GlobalMembersTriangle.minus1mod3[(horiz).orient] + 3];
	botvertex = (GlobalMembersTriangle.REAL)(horiz).tri[(horiz).orient + 3];
	(newbotright).tri[GlobalMembersTriangle.plus1mod3[(newbotright).orient] + 3] = (GlobalMembersTriangle.REAL) botvertex;
	(newbotright).tri[GlobalMembersTriangle.minus1mod3[(newbotright).orient] + 3] = (GlobalMembersTriangle.REAL) rightvertex;
	(newbotright).tri[(newbotright).orient + 3] = (GlobalMembersTriangle.REAL) newvertex;
	(horiz).tri[GlobalMembersTriangle.plus1mod3[(horiz).orient] + 3] = (GlobalMembersTriangle.REAL) newvertex;
	for (i = 0; i < m.eextras; i++)
	{
	  // Set the element attributes of a new triangle. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ((GlobalMembersTriangle.REAL)(newbotright).tri)[m.elemattribindex + (i)] = ((GlobalMembersTriangle.REAL)(botright).tri)[m.elemattribindex + (i)];
	}
	if (b.vararea != 0)
	{
	  // Set the area constraint of a new triangle. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ((GlobalMembersTriangle.REAL)(newbotright).tri)[m.areaboundindex] = ((GlobalMembersTriangle.REAL)(botright).tri)[m.areaboundindex];
	}
	if (mirrorflag != 0)
	{
	  topvertex = (GlobalMembersTriangle.REAL)(topright).tri[GlobalMembersTriangle.minus1mod3[(topright).orient] + 3];
	  (newtopright).tri[GlobalMembersTriangle.plus1mod3[(newtopright).orient] + 3] = (GlobalMembersTriangle.REAL) rightvertex;
	  (newtopright).tri[GlobalMembersTriangle.minus1mod3[(newtopright).orient] + 3] = (GlobalMembersTriangle.REAL) topvertex;
	  (newtopright).tri[(newtopright).orient + 3] = (GlobalMembersTriangle.REAL) newvertex;
	  (topright).tri[GlobalMembersTriangle.plus1mod3[(topright).orient] + 3] = (GlobalMembersTriangle.REAL) newvertex;
	  for (i = 0; i < m.eextras; i++)
	  {
		// Set the element attributes of another new triangle. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		((GlobalMembersTriangle.REAL)(newtopright).tri)[m.elemattribindex + (i)] = ((GlobalMembersTriangle.REAL)(topright).tri)[m.elemattribindex + (i)];
	  }
	  if (b.vararea != 0)
	  {
		// Set the area constraint of another new triangle. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		((GlobalMembersTriangle.REAL)(newtopright).tri)[m.areaboundindex] = ((GlobalMembersTriangle.REAL)(topright).tri)[m.areaboundindex];
	  }
	}

	// There may be subsegments that need to be bonded 
	//   to the new triangle(s).                       
	if (m.checksegments != 0)
	{
	  sptr = (GlobalMembersTriangle.REAL)(botright).tri[6 + (botright).orient];
	  (botrsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (botrsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  if (botrsubseg.ss != m.dummysub)
	  {
		(botright).tri[6 + (botright).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
		(newbotright).tri[6 + (newbotright).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botrsubseg).ss | (int)(botrsubseg).ssorient);
		(botrsubseg).ss[6 + (botrsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(newbotright).tri | (int)(newbotright).orient);
	  }
	  if (mirrorflag != 0)
	  {
		sptr = (GlobalMembersTriangle.REAL)(topright).tri[6 + (topright).orient];
		(toprsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
		(toprsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		if (toprsubseg.ss != m.dummysub)
		{
		  (topright).tri[6 + (topright).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
		  (newtopright).tri[6 + (newtopright).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(toprsubseg).ss | (int)(toprsubseg).ssorient);
		  (toprsubseg).ss[6 + (toprsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(newtopright).tri | (int)(newtopright).orient);
		}
	  }
	}

	// Bond the new triangle(s) to the surrounding triangles. 
	(newbotright).tri[(newbotright).orient] = (GlobalMembersTriangle.REAL)((int)(botrcasing).tri | (int)(botrcasing).orient);
	(botrcasing).tri[(botrcasing).orient] = (GlobalMembersTriangle.REAL)((int)(newbotright).tri | (int)(newbotright).orient);
	(newbotright).orient = GlobalMembersTriangle.minus1mod3[(newbotright).orient];
	(newbotright).tri[(newbotright).orient] = (GlobalMembersTriangle.REAL)((int)(botright).tri | (int)(botright).orient);
	(botright).tri[(botright).orient] = (GlobalMembersTriangle.REAL)((int)(newbotright).tri | (int)(newbotright).orient);
	(newbotright).orient = GlobalMembersTriangle.minus1mod3[(newbotright).orient];
	if (mirrorflag != 0)
	{
	  (newtopright).tri[(newtopright).orient] = (GlobalMembersTriangle.REAL)((int)(toprcasing).tri | (int)(toprcasing).orient);
	  (toprcasing).tri[(toprcasing).orient] = (GlobalMembersTriangle.REAL)((int)(newtopright).tri | (int)(newtopright).orient);
	  (newtopright).orient = GlobalMembersTriangle.plus1mod3[(newtopright).orient];
	  (newtopright).tri[(newtopright).orient] = (GlobalMembersTriangle.REAL)((int)(topright).tri | (int)(topright).orient);
	  (topright).tri[(topright).orient] = (GlobalMembersTriangle.REAL)((int)(newtopright).tri | (int)(newtopright).orient);
	  (newtopright).orient = GlobalMembersTriangle.plus1mod3[(newtopright).orient];
	  (newtopright).tri[(newtopright).orient] = (GlobalMembersTriangle.REAL)((int)(newbotright).tri | (int)(newbotright).orient);
	  (newbotright).tri[(newbotright).orient] = (GlobalMembersTriangle.REAL)((int)(newtopright).tri | (int)(newtopright).orient);
	}

	if (splitseg != (osub) null)
	{
	  // Split the subsegment into two. 
	  splitseg.ss[3 - splitseg.ssorient] = (GlobalMembersTriangle.REAL) newvertex;
	  segmentorg = (GlobalMembersTriangle.REAL) splitseg.ss[4 + splitseg.ssorient];
	  segmentdest = (GlobalMembersTriangle.REAL) splitseg.ss[5 - splitseg.ssorient];
	  splitseg.ssorient = 1 - splitseg.ssorient;
	  sptr = splitseg.ss[splitseg.ssorient];
	  (rightsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (rightsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  GlobalMembersTriangle.insertsubseg(m, b, newbotright, (* (int)(splitseg.ss + 8)));
	  sptr = (GlobalMembersTriangle.REAL)(newbotright).tri[6 + (newbotright).orient];
	  (newsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (newsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  (newsubseg).ss[4 + (newsubseg).ssorient] = (GlobalMembersTriangle.REAL) segmentorg;
	  (newsubseg).ss[5 - (newsubseg).ssorient] = (GlobalMembersTriangle.REAL) segmentdest;
	  splitseg.ss[splitseg.ssorient] = (GlobalMembersTriangle.REAL)((int)(newsubseg).ss | (int)(newsubseg).ssorient);
	  (newsubseg).ss[(newsubseg).ssorient] = (GlobalMembersTriangle.REAL)((int) splitseg.ss | (int) splitseg.ssorient);
	  (newsubseg).ssorient = 1 - (newsubseg).ssorient;
	  (newsubseg).ss[(newsubseg).ssorient] = (GlobalMembersTriangle.REAL)((int)(rightsubseg).ss | (int)(rightsubseg).ssorient);
	  (rightsubseg).ss[(rightsubseg).ssorient] = (GlobalMembersTriangle.REAL)((int)(newsubseg).ss | (int)(newsubseg).ssorient);
	  splitseg.ssorient = 1 - splitseg.ssorient;
	  // Transfer the subsegment's boundary marker to the vertex 
	  //   if required.                                          
	  if (((int)(newvertex))[m.vertexmarkindex] == 0)
	  {
		((int)(newvertex))[m.vertexmarkindex] = (* (int)(splitseg.ss + 8));
	  }
	}

	if (m.checkquality != 0)
	{
	  GlobalMembersTriangle.poolrestart(m.flipstackers);
	  m.lastflip = (flipstacker) GlobalMembersTriangle.poolalloc(m.flipstackers);
	  m.lastflip.flippedtri = (GlobalMembersTriangle.REAL)((int)(horiz).tri | (int)(horiz).orient);
	  m.lastflip.prevflip = (flipstacker) GlobalMembersTriangle.insertvertex;
	}

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if SELF_CHECK
	if (GlobalMembersTriangle.counterclockwise(m, b, rightvertex, leftvertex, botvertex) < 0.0)
	{
	  System.out.print("Internal error in insertvertex():\n");
	  System.out.print("  Clockwise triangle prior to edge vertex insertion (bottom).\n");
	}
	if (mirrorflag != 0)
	{
	  if (GlobalMembersTriangle.counterclockwise(m, b, leftvertex, rightvertex, topvertex) < 0.0)
	  {
		System.out.print("Internal error in insertvertex():\n");
		System.out.print("  Clockwise triangle prior to edge vertex insertion (top).\n");
	  }
	  if (GlobalMembersTriangle.counterclockwise(m, b, rightvertex, topvertex, newvertex) < 0.0)
	  {
		System.out.print("Internal error in insertvertex():\n");
		System.out.print("  Clockwise triangle after edge vertex insertion (top right).\n");
	  }
	  if (GlobalMembersTriangle.counterclockwise(m, b, topvertex, leftvertex, newvertex) < 0.0)
	  {
		System.out.print("Internal error in insertvertex():\n");
		System.out.print("  Clockwise triangle after edge vertex insertion (top left).\n");
	  }
	}
	if (GlobalMembersTriangle.counterclockwise(m, b, leftvertex, botvertex, newvertex) < 0.0)
	{
	  System.out.print("Internal error in insertvertex():\n");
	  System.out.print("  Clockwise triangle after edge vertex insertion (bottom left).\n");
	}
	if (GlobalMembersTriangle.counterclockwise(m, b, botvertex, rightvertex, newvertex) < 0.0)
	{
	  System.out.print("Internal error in insertvertex():\n");
	  System.out.print("  Clockwise triangle after edge vertex insertion (bottom right).\n");
	}
//#endif // SELF_CHECK
	if (b.verbose > 2)
	{
	  System.out.print("  Updating bottom left ");
	  GlobalMembersTriangle.printtriangle(m, b, botright);
	  if (mirrorflag != 0)
	  {
		System.out.print("  Updating top left ");
		GlobalMembersTriangle.printtriangle(m, b, topright);
		System.out.print("  Creating top right ");
		GlobalMembersTriangle.printtriangle(m, b, newtopright);
	  }
	  System.out.print("  Creating bottom right ");
	  GlobalMembersTriangle.printtriangle(m, b, newbotright);
	}

	// Position `horiz' on the first edge to check for 
	//   the Delaunay property.                        
	(horiz).orient = GlobalMembersTriangle.plus1mod3[(horiz).orient];
	  }
  else
  {
	// Insert the vertex in a triangle, splitting it into three. 
	(botleft).tri = (horiz).tri;
	(botleft).orient = GlobalMembersTriangle.plus1mod3[(horiz).orient];
	(botright).tri = (horiz).tri;
	(botright).orient = GlobalMembersTriangle.minus1mod3[(horiz).orient];
	ptr = (botleft).tri[(botleft).orient];
	(botlcasing).orient = (int)((int)(ptr) & (int) 3l);
	(botlcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botlcasing).orient);
	;
	ptr = (botright).tri[(botright).orient];
	(botrcasing).orient = (int)((int)(ptr) & (int) 3l);
	(botrcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botrcasing).orient);
	;
	GlobalMembersTriangle.maketriangle(m, b, newbotleft);
	GlobalMembersTriangle.maketriangle(m, b, newbotright);

	// Set the vertices of changed and new triangles. 
	rightvertex = (GlobalMembersTriangle.REAL)(horiz).tri[GlobalMembersTriangle.plus1mod3[(horiz).orient] + 3];
	leftvertex = (GlobalMembersTriangle.REAL)(horiz).tri[GlobalMembersTriangle.minus1mod3[(horiz).orient] + 3];
	botvertex = (GlobalMembersTriangle.REAL)(horiz).tri[(horiz).orient + 3];
	(newbotleft).tri[GlobalMembersTriangle.plus1mod3[(newbotleft).orient] + 3] = (GlobalMembersTriangle.REAL) leftvertex;
	(newbotleft).tri[GlobalMembersTriangle.minus1mod3[(newbotleft).orient] + 3] = (GlobalMembersTriangle.REAL) botvertex;
	(newbotleft).tri[(newbotleft).orient + 3] = (GlobalMembersTriangle.REAL) newvertex;
	(newbotright).tri[GlobalMembersTriangle.plus1mod3[(newbotright).orient] + 3] = (GlobalMembersTriangle.REAL) botvertex;
	(newbotright).tri[GlobalMembersTriangle.minus1mod3[(newbotright).orient] + 3] = (GlobalMembersTriangle.REAL) rightvertex;
	(newbotright).tri[(newbotright).orient + 3] = (GlobalMembersTriangle.REAL) newvertex;
	(horiz).tri[(horiz).orient + 3] = (GlobalMembersTriangle.REAL) newvertex;
	for (i = 0; i < m.eextras; i++)
	{
	  // Set the element attributes of the new triangles. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  attrib = ((GlobalMembersTriangle.REAL)(horiz).tri)[m.elemattribindex + (i)];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ((GlobalMembersTriangle.REAL)(newbotleft).tri)[m.elemattribindex + (i)] = attrib;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ((GlobalMembersTriangle.REAL)(newbotright).tri)[m.elemattribindex + (i)] = attrib;
	}
	if (b.vararea != 0)
	{
	  // Set the area constraint of the new triangles. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  area = ((GlobalMembersTriangle.REAL)(horiz).tri)[m.areaboundindex];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ((GlobalMembersTriangle.REAL)(newbotleft).tri)[m.areaboundindex] = area;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ((GlobalMembersTriangle.REAL)(newbotright).tri)[m.areaboundindex] = area;
	}

	// There may be subsegments that need to be bonded 
	//   to the new triangles.                         
	if (m.checksegments != 0)
	{
	  sptr = (GlobalMembersTriangle.REAL)(botleft).tri[6 + (botleft).orient];
	  (botlsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (botlsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  if (botlsubseg.ss != m.dummysub)
	  {
		(botleft).tri[6 + (botleft).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
		(newbotleft).tri[6 + (newbotleft).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botlsubseg).ss | (int)(botlsubseg).ssorient);
		(botlsubseg).ss[6 + (botlsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(newbotleft).tri | (int)(newbotleft).orient);
	  }
	  sptr = (GlobalMembersTriangle.REAL)(botright).tri[6 + (botright).orient];
	  (botrsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (botrsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  if (botrsubseg.ss != m.dummysub)
	  {
		(botright).tri[6 + (botright).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
		(newbotright).tri[6 + (newbotright).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botrsubseg).ss | (int)(botrsubseg).ssorient);
		(botrsubseg).ss[6 + (botrsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(newbotright).tri | (int)(newbotright).orient);
	  }
	}

	// Bond the new triangles to the surrounding triangles. 
	(newbotleft).tri[(newbotleft).orient] = (GlobalMembersTriangle.REAL)((int)(botlcasing).tri | (int)(botlcasing).orient);
	(botlcasing).tri[(botlcasing).orient] = (GlobalMembersTriangle.REAL)((int)(newbotleft).tri | (int)(newbotleft).orient);
	(newbotright).tri[(newbotright).orient] = (GlobalMembersTriangle.REAL)((int)(botrcasing).tri | (int)(botrcasing).orient);
	(botrcasing).tri[(botrcasing).orient] = (GlobalMembersTriangle.REAL)((int)(newbotright).tri | (int)(newbotright).orient);
	(newbotleft).orient = GlobalMembersTriangle.plus1mod3[(newbotleft).orient];
	(newbotright).orient = GlobalMembersTriangle.minus1mod3[(newbotright).orient];
	(newbotleft).tri[(newbotleft).orient] = (GlobalMembersTriangle.REAL)((int)(newbotright).tri | (int)(newbotright).orient);
	(newbotright).tri[(newbotright).orient] = (GlobalMembersTriangle.REAL)((int)(newbotleft).tri | (int)(newbotleft).orient);
	(newbotleft).orient = GlobalMembersTriangle.plus1mod3[(newbotleft).orient];
	(botleft).tri[(botleft).orient] = (GlobalMembersTriangle.REAL)((int)(newbotleft).tri | (int)(newbotleft).orient);
	(newbotleft).tri[(newbotleft).orient] = (GlobalMembersTriangle.REAL)((int)(botleft).tri | (int)(botleft).orient);
	(newbotright).orient = GlobalMembersTriangle.minus1mod3[(newbotright).orient];
	(botright).tri[(botright).orient] = (GlobalMembersTriangle.REAL)((int)(newbotright).tri | (int)(newbotright).orient);
	(newbotright).tri[(newbotright).orient] = (GlobalMembersTriangle.REAL)((int)(botright).tri | (int)(botright).orient);

	if (m.checkquality != 0)
	{
	  GlobalMembersTriangle.poolrestart(m.flipstackers);
	  m.lastflip = (flipstacker) GlobalMembersTriangle.poolalloc(m.flipstackers);
	  m.lastflip.flippedtri = (GlobalMembersTriangle.REAL)((int)(horiz).tri | (int)(horiz).orient);
	  m.lastflip.prevflip = (flipstacker) null;
	}

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if SELF_CHECK
	if (GlobalMembersTriangle.counterclockwise(m, b, rightvertex, leftvertex, botvertex) < 0.0)
	{
	  System.out.print("Internal error in insertvertex():\n");
	  System.out.print("  Clockwise triangle prior to vertex insertion.\n");
	}
	if (GlobalMembersTriangle.counterclockwise(m, b, rightvertex, leftvertex, newvertex) < 0.0)
	{
	  System.out.print("Internal error in insertvertex():\n");
	  System.out.print("  Clockwise triangle after vertex insertion (top).\n");
	}
	if (GlobalMembersTriangle.counterclockwise(m, b, leftvertex, botvertex, newvertex) < 0.0)
	{
	  System.out.print("Internal error in insertvertex():\n");
	  System.out.print("  Clockwise triangle after vertex insertion (left).\n");
	}
	if (GlobalMembersTriangle.counterclockwise(m, b, botvertex, rightvertex, newvertex) < 0.0)
	{
	  System.out.print("Internal error in insertvertex():\n");
	  System.out.print("  Clockwise triangle after vertex insertion (right).\n");
	}
//#endif // SELF_CHECK
	if (b.verbose > 2)
	{
	  System.out.print("  Updating top ");
	  GlobalMembersTriangle.printtriangle(m, b, horiz);
	  System.out.print("  Creating left ");
	  GlobalMembersTriangle.printtriangle(m, b, newbotleft);
	  System.out.print("  Creating right ");
	  GlobalMembersTriangle.printtriangle(m, b, newbotright);
	}
  }

  // The insertion is successful by default, unless an encroached 
  //   subsegment is found.                                       
  success = insertvertexresult.SUCCESSFULVERTEX;
  // Circle around the newly inserted vertex, checking each edge opposite 
  //   it for the Delaunay property.  Non-Delaunay edges are flipped.     
  //   `horiz' is always the edge being checked.  `first' marks where to  
  //   stop circling.                                                     
  first = (GlobalMembersTriangle.REAL)(horiz).tri[GlobalMembersTriangle.plus1mod3[(horiz).orient] + 3];
  rightvertex = first;
  leftvertex = (GlobalMembersTriangle.REAL)(horiz).tri[GlobalMembersTriangle.minus1mod3[(horiz).orient] + 3];
  // Circle until finished. 
  while (1)
  {
	// By default, the edge will be flipped. 
	doflip = 1;

	if (m.checksegments != 0)
	{
	  // Check for a subsegment, which cannot be flipped. 
	  sptr = (GlobalMembersTriangle.REAL)(horiz).tri[6 + (horiz).orient];
	  (checksubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (checksubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  if (checksubseg.ss != m.dummysub)
	  {
		// The edge is a subsegment and cannot be flipped. 
		doflip = 0;
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
		if (segmentflaws != 0)
		{
		  // Does the new vertex encroach upon this subsegment? 
		  if (GlobalMembersTriangle.checkseg4encroach(m, b, checksubseg))
		  {
			success = insertvertexresult.ENCROACHINGVERTEX;
		  }
		}
//#endif // not CDT_ONLY
	  }
	}

	if (doflip != 0)
	{
	  // Check if the edge is a boundary edge. 
	  ptr = (horiz).tri[(horiz).orient];
	  (top).orient = (int)((int)(ptr) & (int) 3l);
	  (top).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(top).orient);
	  ;
	  if (top.tri == m.dummytri)
	  {
		// The edge is a boundary edge and cannot be flipped. 
		doflip = 0;
	  }
	  else
	  {
		// Find the vertex on the other side of the edge. 
		farvertex = (GlobalMembersTriangle.REAL)(top).tri[(top).orient + 3];
		// In the incremental Delaunay triangulation algorithm, any of      
		//   `leftvertex', `rightvertex', and `farvertex' could be vertices 
		//   of the triangular bounding box.  These vertices must be        
		//   treated as if they are infinitely distant, even though their   
		//   "coordinates" are not.                                         
		if ((leftvertex == m.infvertex1) || (leftvertex == m.infvertex2) || (leftvertex == m.infvertex3))
		{
		  // `leftvertex' is infinitely distant.  Check the convexity of  
		  //   the boundary of the triangulation.  'farvertex' might be   
		  //   infinite as well, but trust me, this same condition should 
		  //   be applied.                                                
		  doflip = GlobalMembersTriangle.counterclockwise(m, b, newvertex, rightvertex, farvertex) > 0.0;
		}
		else if ((rightvertex == m.infvertex1) || (rightvertex == m.infvertex2) || (rightvertex == m.infvertex3))
		{
		  // `rightvertex' is infinitely distant.  Check the convexity of 
		  //   the boundary of the triangulation.  'farvertex' might be   
		  //   infinite as well, but trust me, this same condition should 
		  //   be applied.                                                
		  doflip = GlobalMembersTriangle.counterclockwise(m, b, farvertex, leftvertex, newvertex) > 0.0;
		}
		else if ((farvertex == m.infvertex1) || (farvertex == m.infvertex2) || (farvertex == m.infvertex3))
		{
		  // `farvertex' is infinitely distant and cannot be inside 
		  //   the circumcircle of the triangle `horiz'.            
		  doflip = 0;
		}
		else
		{
		  // Test whether the edge is locally Delaunay. 
		  doflip = GlobalMembersTriangle.incircle(m, b, leftvertex, newvertex, rightvertex, farvertex) > 0.0;
		}
		if (doflip != 0)
		{
		  // We made it!  Flip the edge `horiz' by rotating its containing 
		  //   quadrilateral (the two triangles adjacent to `horiz').      
		  // Identify the casing of the quadrilateral. 
		  (topleft).tri = (top).tri;
		  (topleft).orient = GlobalMembersTriangle.minus1mod3[(top).orient];
		  ptr = (topleft).tri[(topleft).orient];
		  (toplcasing).orient = (int)((int)(ptr) & (int) 3l);
		  (toplcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(toplcasing).orient);
		  ;
		  (topright).tri = (top).tri;
		  (topright).orient = GlobalMembersTriangle.plus1mod3[(top).orient];
		  ptr = (topright).tri[(topright).orient];
		  (toprcasing).orient = (int)((int)(ptr) & (int) 3l);
		  (toprcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(toprcasing).orient);
		  ;
		  (botleft).tri = (horiz).tri;
		  (botleft).orient = GlobalMembersTriangle.plus1mod3[(horiz).orient];
		  ptr = (botleft).tri[(botleft).orient];
		  (botlcasing).orient = (int)((int)(ptr) & (int) 3l);
		  (botlcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botlcasing).orient);
		  ;
		  (botright).tri = (horiz).tri;
		  (botright).orient = GlobalMembersTriangle.minus1mod3[(horiz).orient];
		  ptr = (botright).tri[(botright).orient];
		  (botrcasing).orient = (int)((int)(ptr) & (int) 3l);
		  (botrcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botrcasing).orient);
		  ;
		  // Rotate the quadrilateral one-quarter turn counterclockwise. 
		  (topleft).tri[(topleft).orient] = (GlobalMembersTriangle.REAL)((int)(botlcasing).tri | (int)(botlcasing).orient);
		  (botlcasing).tri[(botlcasing).orient] = (GlobalMembersTriangle.REAL)((int)(topleft).tri | (int)(topleft).orient);
		  (botleft).tri[(botleft).orient] = (GlobalMembersTriangle.REAL)((int)(botrcasing).tri | (int)(botrcasing).orient);
		  (botrcasing).tri[(botrcasing).orient] = (GlobalMembersTriangle.REAL)((int)(botleft).tri | (int)(botleft).orient);
		  (botright).tri[(botright).orient] = (GlobalMembersTriangle.REAL)((int)(toprcasing).tri | (int)(toprcasing).orient);
		  (toprcasing).tri[(toprcasing).orient] = (GlobalMembersTriangle.REAL)((int)(botright).tri | (int)(botright).orient);
		  (topright).tri[(topright).orient] = (GlobalMembersTriangle.REAL)((int)(toplcasing).tri | (int)(toplcasing).orient);
		  (toplcasing).tri[(toplcasing).orient] = (GlobalMembersTriangle.REAL)((int)(topright).tri | (int)(topright).orient);
		  if (m.checksegments != 0)
		  {
			// Check for subsegments and rebond them to the quadrilateral. 
			sptr = (GlobalMembersTriangle.REAL)(topleft).tri[6 + (topleft).orient];
			(toplsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
			(toplsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
			sptr = (GlobalMembersTriangle.REAL)(botleft).tri[6 + (botleft).orient];
			(botlsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
			(botlsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
			sptr = (GlobalMembersTriangle.REAL)(botright).tri[6 + (botright).orient];
			(botrsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
			(botrsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
			sptr = (GlobalMembersTriangle.REAL)(topright).tri[6 + (topright).orient];
			(toprsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
			(toprsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
			if (toplsubseg.ss == m.dummysub)
			{
			  (topright).tri[6 + (topright).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
			}
			else
			{
			  (topright).tri[6 + (topright).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(toplsubseg).ss | (int)(toplsubseg).ssorient);
			  (toplsubseg).ss[6 + (toplsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(topright).tri | (int)(topright).orient);
			}
			if (botlsubseg.ss == m.dummysub)
			{
			  (topleft).tri[6 + (topleft).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
			}
			else
			{
			  (topleft).tri[6 + (topleft).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botlsubseg).ss | (int)(botlsubseg).ssorient);
			  (botlsubseg).ss[6 + (botlsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(topleft).tri | (int)(topleft).orient);
			}
			if (botrsubseg.ss == m.dummysub)
			{
			  (botleft).tri[6 + (botleft).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
			}
			else
			{
			  (botleft).tri[6 + (botleft).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botrsubseg).ss | (int)(botrsubseg).ssorient);
			  (botrsubseg).ss[6 + (botrsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botleft).tri | (int)(botleft).orient);
			}
			if (toprsubseg.ss == m.dummysub)
			{
			  (botright).tri[6 + (botright).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
			}
			else
			{
			  (botright).tri[6 + (botright).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(toprsubseg).ss | (int)(toprsubseg).ssorient);
			  (toprsubseg).ss[6 + (toprsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botright).tri | (int)(botright).orient);
			}
		  }
		  // New vertex assignments for the rotated quadrilateral. 
		  (horiz).tri[GlobalMembersTriangle.plus1mod3[(horiz).orient] + 3] = (GlobalMembersTriangle.REAL) farvertex;
		  (horiz).tri[GlobalMembersTriangle.minus1mod3[(horiz).orient] + 3] = (GlobalMembersTriangle.REAL) newvertex;
		  (horiz).tri[(horiz).orient + 3] = (GlobalMembersTriangle.REAL) rightvertex;
		  (top).tri[GlobalMembersTriangle.plus1mod3[(top).orient] + 3] = (GlobalMembersTriangle.REAL) newvertex;
		  (top).tri[GlobalMembersTriangle.minus1mod3[(top).orient] + 3] = (GlobalMembersTriangle.REAL) farvertex;
		  (top).tri[(top).orient + 3] = (GlobalMembersTriangle.REAL) leftvertex;
		  for (i = 0; i < m.eextras; i++)
		  {
			// Take the average of the two triangles' attributes. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
			attrib = 0.5 * (((GlobalMembersTriangle.REAL)(top).tri)[m.elemattribindex + (i)] + ((GlobalMembersTriangle.REAL)(horiz).tri)[m.elemattribindex + (i)]);
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
			((GlobalMembersTriangle.REAL)(top).tri)[m.elemattribindex + (i)] = attrib;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
			((GlobalMembersTriangle.REAL)(horiz).tri)[m.elemattribindex + (i)] = attrib;
		  }
		  if (b.vararea != 0)
		  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
			if ((((GlobalMembersTriangle.REAL)(top).tri)[m.areaboundindex] <= 0.0) || (((GlobalMembersTriangle.REAL)(horiz).tri)[m.areaboundindex] <= 0.0))
			{
			  area = -1.0;
			}
			else
			{
			  // Take the average of the two triangles' area constraints.    
			  //   This prevents small area constraints from migrating a     
			  //   long, long way from their original location due to flips. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
			  area = 0.5 * (((GlobalMembersTriangle.REAL)(top).tri)[m.areaboundindex] + ((GlobalMembersTriangle.REAL)(horiz).tri)[m.areaboundindex]);
			}
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
			((GlobalMembersTriangle.REAL)(top).tri)[m.areaboundindex] = area;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
			((GlobalMembersTriangle.REAL)(horiz).tri)[m.areaboundindex] = area;
		  }

		  if (m.checkquality != 0)
		  {
			newflip = (flipstacker) GlobalMembersTriangle.poolalloc(m.flipstackers);
			newflip.flippedtri = (GlobalMembersTriangle.REAL)((int)(horiz).tri | (int)(horiz).orient);
			newflip.prevflip = m.lastflip;
			m.lastflip = newflip;
		  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if SELF_CHECK
		  if (newvertex != (GlobalMembersTriangle.REAL) null)
		  {
			if (GlobalMembersTriangle.counterclockwise(m, b, leftvertex, newvertex, rightvertex) < 0.0)
			{
			  System.out.print("Internal error in insertvertex():\n");
			  System.out.print("  Clockwise triangle prior to edge flip (bottom).\n");
			}
			// The following test has been removed because constrainededge() 
			//   sometimes generates inverted triangles that insertvertex()  
			//   removes.                                                    
//
//            if (counterclockwise(m, b, rightvertex, farvertex, leftvertex) <
//                0.0) {
//              printf("Internal error in insertvertex():\n");
//              printf("  Clockwise triangle prior to edge flip (top).\n");
//            }
//
			if (GlobalMembersTriangle.counterclockwise(m, b, farvertex, leftvertex, newvertex) < 0.0)
			{
			  System.out.print("Internal error in insertvertex():\n");
			  System.out.print("  Clockwise triangle after edge flip (left).\n");
			}
			if (GlobalMembersTriangle.counterclockwise(m, b, newvertex, rightvertex, farvertex) < 0.0)
			{
			  System.out.print("Internal error in insertvertex():\n");
			  System.out.print("  Clockwise triangle after edge flip (right).\n");
			}
		  }
//#endif // SELF_CHECK
		  if (b.verbose > 2)
		  {
			System.out.print("  Edge flip results in left ");
			(topleft).orient = GlobalMembersTriangle.plus1mod3[(topleft).orient];
			GlobalMembersTriangle.printtriangle(m, b, topleft);
			System.out.print("  and right ");
			GlobalMembersTriangle.printtriangle(m, b, horiz);
		  }
		  // On the next iterations, consider the two edges that were  
		  //   exposed (this is, are now visible to the newly inserted 
		  //   vertex) by the edge flip.                               
		  (horiz).orient = GlobalMembersTriangle.minus1mod3[(horiz).orient];
		  leftvertex = farvertex;
		}
	  }
	}
	if (doflip == 0)
	{
	  // The handle `horiz' is accepted as locally Delaunay. 
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
	  if (triflaws != 0)
	  {
		// Check the triangle `horiz' for quality. 
		GlobalMembersTriangle.testtriangle(m, b, horiz);
	  }
//#endif // not CDT_ONLY
	  // Look for the next edge around the newly inserted vertex. 
	  (horiz).orient = GlobalMembersTriangle.plus1mod3[(horiz).orient];
	  ptr = (horiz).tri[(horiz).orient];
	  (testtri).orient = (int)((int)(ptr) & (int) 3l);
	  (testtri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(testtri).orient);
	  ;
	  // Check for finishing a complete revolution about the new vertex, or 
	  //   falling outside  of the triangulation.  The latter will happen   
	  //   when a vertex is inserted at a boundary.                         
	  if ((leftvertex == first) || (testtri.tri == m.dummytri))
	  {
		// We're done.  Return a triangle whose origin is the new vertex. 
		searchtri.tri = (horiz).tri;
		searchtri.orient = GlobalMembersTriangle.plus1mod3[(horiz).orient];
		(m.recenttri).tri = (horiz).tri;
		(m.recenttri).orient = GlobalMembersTriangle.plus1mod3[(horiz).orient];
		return success;
	  }
	  // Finish finding the next edge around the newly inserted vertex. 
	  (horiz).tri = (testtri).tri;
	  (horiz).orient = GlobalMembersTriangle.plus1mod3[(testtri).orient];
	  rightvertex = leftvertex;
	  leftvertex = (GlobalMembersTriangle.REAL)(horiz).tri[GlobalMembersTriangle.minus1mod3[(horiz).orient] + 3];
	}
  }
}

//***************************************************************************
//                                                                           
//  triangulatepolygon()   Find the Delaunay triangulation of a polygon that 
//                         has a certain "nice" shape.  This includes the    
//                         polygons that result from deletion of a vertex or 
//                         insertion of a segment.                           
//                                                                           
//  This is a conceptually difficult routine.  The starting assumption is    
//  that we have a polygon with n sides.  n - 1 of these sides are currently 
//  represented as edges in the mesh.  One side, called the "base", need not 
//  be.                                                                      
//                                                                           
//  Inside the polygon is a structure I call a "fan", consisting of n - 1    
//  triangles that share a common origin.  For each of these triangles, the  
//  edge opposite the origin is one of the sides of the polygon.  The        
//  primary edge of each triangle is the edge directed from the origin to    
//  the destination; note that this is not the same edge that is a side of   
//  the polygon.  `firstedge' is the primary edge of the first triangle.     
//  From there, the triangles follow in counterclockwise order about the     
//  polygon, until `lastedge', the primary edge of the last triangle.        
//  `firstedge' and `lastedge' are probably connected to other triangles     
//  beyond the extremes of the fan, but their identity is not important, as  
//  long as the fan remains connected to them.                               
//                                                                           
//  Imagine the polygon oriented so that its base is at the bottom.  This    
//  puts `firstedge' on the far right, and `lastedge' on the far left.       
//  The right vertex of the base is the destination of `firstedge', and the  
//  left vertex of the base is the apex of `lastedge'.                       
//                                                                           
//  The challenge now is to find the right sequence of edge flips to         
//  transform the fan into a Delaunay triangulation of the polygon.  Each    
//  edge flip effectively removes one triangle from the fan, committing it   
//  to the polygon.  The resulting polygon has one fewer edge.  If `doflip'  
//  is set, the final flip will be performed, resulting in a fan of one      
//  (useless?) triangle.  If `doflip' is not set, the final flip is not      
//  performed, resulting in a fan of two triangles, and an unfinished        
//  triangular polygon that is not yet filled out with a single triangle.    
//  On completion of the routine, `lastedge' is the last remaining triangle, 
//  or the leftmost of the last two.                                         
//                                                                           
//  Although the flips are performed in the order described above, the       
//  decisions about what flips to perform are made in precisely the reverse  
//  order.  The recursive triangulatepolygon() procedure makes a decision,   
//  uses up to two recursive calls to triangulate the "subproblems"          
//  (polygons with fewer edges), and then performs an edge flip.             
//                                                                           
//  The "decision" it makes is which vertex of the polygon should be         
//  connected to the base.  This decision is made by testing every possible  
//  vertex.  Once the best vertex is found, the two edges that connect this  
//  vertex to the base become the bases for two smaller polygons.  These     
//  are triangulated recursively.  Unfortunately, this approach can take     
//  O(n^2) time not only in the worst case, but in many common cases.  It's  
//  rarely a big deal for vertex deletion, where n is rarely larger than     
//  ten, but it could be a big deal for segment insertion, especially if     
//  there's a lot of long segments that each cut many triangles.  I ought to 
//  code a faster algorithm some day.                                        
//                                                                           
//  The `edgecount' parameter is the number of sides of the polygon,         
//  including its base.  `triflaws' is a flag that determines whether the    
//  new triangles should be tested for quality, and enqueued if they are     
//  bad.                                                                     
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.triangulatepolygon(struct mesh m, struct behavior b, struct otri *firstedge, struct otri *lastedge, int edgecount, int doflip, int triflaws)
//#else
void GlobalMembersTriangle.triangulatepolygon(m, b, firstedge, lastedge, edgecount, doflip, triflaws)
mesh m;
behavior b;
otri firstedge;
otri lastedge;
int edgecount;
int doflip;
int triflaws;
//#endif // not ANSI_DECLARATORS

{
  otri testtri = new otri();
  otri besttri = new otri();
  otri tempedge = new otri();
  GlobalMembersTriangle.REAL leftbasevertex;
  GlobalMembersTriangle.REAL rightbasevertex;
  GlobalMembersTriangle.REAL testvertex;
  GlobalMembersTriangle.REAL bestvertex;
  int bestnumber;
  int i;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym(), onext(), and oprev().

  // Identify the base vertices. 
  leftbasevertex = (GlobalMembersTriangle.REAL) lastedge.tri[lastedge.orient + 3];
  rightbasevertex = (GlobalMembersTriangle.REAL) firstedge.tri[GlobalMembersTriangle.minus1mod3[firstedge.orient] + 3];
  if (b.verbose > 2)
  {
	System.out.print("  Triangulating interior polygon at edge\n");
	System.out.printf("    (%.12g, %.12g) (%.12g, %.12g)\n", leftbasevertex[0], leftbasevertex[1], rightbasevertex[0], rightbasevertex[1]);
  }
  // Find the best vertex to connect the base to. 
  (besttri).tri = firstedge.tri;
  (besttri).orient = GlobalMembersTriangle.minus1mod3[firstedge.orient];
  ptr = (besttri).tri[(besttri).orient];
  (besttri).orient = (int)((int)(ptr) & (int) 3l);
  (besttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(besttri).orient);
  ;
  ;
  bestvertex = (GlobalMembersTriangle.REAL)(besttri).tri[GlobalMembersTriangle.minus1mod3[(besttri).orient] + 3];
  (testtri).tri = (besttri).tri;
  (testtri).orient = (besttri).orient;
  bestnumber = 1;
  for (i = 2; i <= edgecount - 2; i++)
  {
	(testtri).orient = GlobalMembersTriangle.minus1mod3[(testtri).orient];
	ptr = (testtri).tri[(testtri).orient];
	(testtri).orient = (int)((int)(ptr) & (int) 3l);
	(testtri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(testtri).orient);
	;
	;
	testvertex = (GlobalMembersTriangle.REAL)(testtri).tri[GlobalMembersTriangle.minus1mod3[(testtri).orient] + 3];
	// Is this a better vertex? 
	if (GlobalMembersTriangle.incircle(m, b, leftbasevertex, rightbasevertex, bestvertex, testvertex) > 0.0)
	{
	  (besttri).tri = (testtri).tri;
	  (besttri).orient = (testtri).orient;
	  bestvertex = testvertex;
	  bestnumber = i;
	}
  }
  if (b.verbose > 2)
  {
	System.out.printf("    Connecting edge to (%.12g, %.12g)\n", bestvertex[0], bestvertex[1]);
  }
  if (bestnumber > 1)
  {
	// Recursively triangulate the smaller polygon on the right. 
	ptr = (besttri).tri[(besttri).orient];
	(tempedge).orient = (int)((int)(ptr) & (int) 3l);
	(tempedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(tempedge).orient);
	;
	(tempedge).orient = GlobalMembersTriangle.plus1mod3[(tempedge).orient];
	;
	GlobalMembersTriangle.triangulatepolygon(m, b, firstedge, tempedge, bestnumber + 1, 1, triflaws);
  }
  if (bestnumber < edgecount - 2)
  {
	// Recursively triangulate the smaller polygon on the left. 
	ptr = (besttri).tri[(besttri).orient];
	(tempedge).orient = (int)((int)(ptr) & (int) 3l);
	(tempedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(tempedge).orient);
	;
	GlobalMembersTriangle.triangulatepolygon(m, b, besttri, lastedge, edgecount - bestnumber, 1, triflaws);
	// Find `besttri' again; it may have been lost to edge flips. 
	ptr = (tempedge).tri[(tempedge).orient];
	(besttri).orient = (int)((int)(ptr) & (int) 3l);
	(besttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(besttri).orient);
	;
  }
  if (doflip != 0)
  {
	// Do one final edge flip. 
	GlobalMembersTriangle.flip(m, b, besttri);
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
	if (triflaws != 0)
	{
	  // Check the quality of the newly committed triangle. 
	  ptr = (besttri).tri[(besttri).orient];
	  (testtri).orient = (int)((int)(ptr) & (int) 3l);
	  (testtri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(testtri).orient);
	  ;
	  GlobalMembersTriangle.testtriangle(m, b, testtri);
	}
//#endif // not CDT_ONLY
  }
  // Return the base triangle. 
  lastedge.tri = (besttri).tri;
  lastedge.orient = (besttri).orient;
}

//***************************************************************************
//                                                                           
//  deletevertex()   Delete a vertex from a Delaunay triangulation, ensuring 
//                   that the triangulation remains Delaunay.                
//                                                                           
//  The origin of `deltri' is deleted.  The union of the triangles adjacent  
//  to this vertex is a polygon, for which the Delaunay triangulation is     
//  found.  Two triangles are removed from the mesh.                         
//                                                                           
//  Only interior vertices that do not lie on segments or boundaries may be  
//  deleted.                                                                 
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.deletevertex(struct mesh m, struct behavior b, struct otri *deltri)
//#else
void GlobalMembersTriangle.deletevertex(m, b, deltri)
mesh m;
behavior b;
otri deltri;
//#endif // not ANSI_DECLARATORS

{
  otri countingtri = new otri();
  otri firstedge = new otri();
  otri lastedge = new otri();
  otri deltriright = new otri();
  otri lefttri = new otri();
  otri righttri = new otri();
  otri leftcasing = new otri();
  otri rightcasing = new otri();
  osub leftsubseg = new osub();
  osub rightsubseg = new osub();
  GlobalMembersTriangle.REAL delvertex;
  GlobalMembersTriangle.REAL neworg;
  int edgecount;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym(), onext(), and oprev().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  delvertex = (GlobalMembersTriangle.REAL) deltri.tri[GlobalMembersTriangle.plus1mod3[deltri.orient] + 3];
  if (b.verbose > 1)
  {
	System.out.printf("  Deleting (%.12g, %.12g).\n", delvertex[0], delvertex[1]);
  }
  GlobalMembersTriangle.vertexdealloc(m, delvertex);

  // Count the degree of the vertex being deleted. 
  (countingtri).tri = deltri.tri;
  (countingtri).orient = GlobalMembersTriangle.minus1mod3[deltri.orient];
  ptr = (countingtri).tri[(countingtri).orient];
  (countingtri).orient = (int)((int)(ptr) & (int) 3l);
  (countingtri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(countingtri).orient);
  ;
  ;
  edgecount = 1;
  while (!((deltri.tri == (countingtri).tri) && (deltri.orient == (countingtri).orient)))
  {
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if SELF_CHECK
	if (countingtri.tri == m.dummytri)
	{
	  System.out.print("Internal error in deletevertex():\n");
	  System.out.print("  Attempt to delete boundary vertex.\n");
	  GlobalMembersTriangle.internalerror();
	}
//#endif // SELF_CHECK
	edgecount++;
	(countingtri).orient = GlobalMembersTriangle.minus1mod3[(countingtri).orient];
	ptr = (countingtri).tri[(countingtri).orient];
	(countingtri).orient = (int)((int)(ptr) & (int) 3l);
	(countingtri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(countingtri).orient);
	;
	;
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if SELF_CHECK
  if (edgecount < 3)
  {
	System.out.printf("Internal error in deletevertex():\n  Vertex has degree %d.\n", edgecount);
	GlobalMembersTriangle.internalerror();
  }
//#endif // SELF_CHECK
  if (edgecount > 3)
  {
	// Triangulate the polygon defined by the union of all triangles 
	//   adjacent to the vertex being deleted.  Check the quality of 
	//   the resulting triangles.                                    
	(firstedge).tri = deltri.tri;
	(firstedge).orient = GlobalMembersTriangle.minus1mod3[deltri.orient];
	ptr = (firstedge).tri[(firstedge).orient];
	(firstedge).orient = (int)((int)(ptr) & (int) 3l);
	(firstedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(firstedge).orient);
	;
	;
	ptr = deltri.tri[deltri.orient];
	(lastedge).orient = (int)((int)(ptr) & (int) 3l);
	(lastedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(lastedge).orient);
	;
	(lastedge).orient = GlobalMembersTriangle.plus1mod3[(lastedge).orient];
	;
	GlobalMembersTriangle.triangulatepolygon(m, b, firstedge, lastedge, edgecount, 0, !b.nobisect);
  }
  // Splice out two triangles. 
  (deltriright).tri = deltri.tri;
  (deltriright).orient = GlobalMembersTriangle.minus1mod3[deltri.orient];
  ptr = deltri.tri[deltri.orient];
  (lefttri).orient = (int)((int)(ptr) & (int) 3l);
  (lefttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(lefttri).orient);
  ;
  (lefttri).orient = GlobalMembersTriangle.minus1mod3[(lefttri).orient];
  ;
  ptr = (lefttri).tri[(lefttri).orient];
  (leftcasing).orient = (int)((int)(ptr) & (int) 3l);
  (leftcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(leftcasing).orient);
  ;
  ptr = (deltriright).tri[(deltriright).orient];
  (righttri).orient = (int)((int)(ptr) & (int) 3l);
  (righttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(righttri).orient);
  ;
  (righttri).orient = GlobalMembersTriangle.plus1mod3[(righttri).orient];
  ;
  ptr = (righttri).tri[(righttri).orient];
  (rightcasing).orient = (int)((int)(ptr) & (int) 3l);
  (rightcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(rightcasing).orient);
  ;
  deltri.tri[deltri.orient] = (GlobalMembersTriangle.REAL)((int)(leftcasing).tri | (int)(leftcasing).orient);
  (leftcasing).tri[(leftcasing).orient] = (GlobalMembersTriangle.REAL)((int) deltri.tri | (int) deltri.orient);
  (deltriright).tri[(deltriright).orient] = (GlobalMembersTriangle.REAL)((int)(rightcasing).tri | (int)(rightcasing).orient);
  (rightcasing).tri[(rightcasing).orient] = (GlobalMembersTriangle.REAL)((int)(deltriright).tri | (int)(deltriright).orient);
  sptr = (GlobalMembersTriangle.REAL)(lefttri).tri[6 + (lefttri).orient];
  (leftsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
  (leftsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
  if (leftsubseg.ss != m.dummysub)
  {
	deltri.tri[6 + deltri.orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(leftsubseg).ss | (int)(leftsubseg).ssorient);
	(leftsubseg).ss[6 + (leftsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int) deltri.tri | (int) deltri.orient);
  }
  sptr = (GlobalMembersTriangle.REAL)(righttri).tri[6 + (righttri).orient];
  (rightsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
  (rightsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
  if (rightsubseg.ss != m.dummysub)
  {
	(deltriright).tri[6 + (deltriright).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(rightsubseg).ss | (int)(rightsubseg).ssorient);
	(rightsubseg).ss[6 + (rightsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(deltriright).tri | (int)(deltriright).orient);
  }

  // Set the new origin of `deltri' and check its quality. 
  neworg = (GlobalMembersTriangle.REAL)(lefttri).tri[GlobalMembersTriangle.plus1mod3[(lefttri).orient] + 3];
  deltri.tri[GlobalMembersTriangle.plus1mod3[deltri.orient] + 3] = (GlobalMembersTriangle.REAL) neworg;
  if (b.nobisect == 0)
  {
	GlobalMembersTriangle.testtriangle(m, b, deltri);
  }

  // Delete the two spliced-out triangles. 
  GlobalMembersTriangle.triangledealloc(m, lefttri.tri);
  GlobalMembersTriangle.triangledealloc(m, righttri.tri);
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  undovertex()   Undo the most recent vertex insertion.                    
//                                                                           
//  Walks through the list of transformations (flips and a vertex insertion) 
//  in the reverse of the order in which they were done, and undoes them.    
//  The inserted vertex is removed from the triangulation and deallocated.   
//  Two triangles (possibly just one) are also deallocated.                  
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.undovertex(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.undovertex(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri fliptri = new otri();
  otri botleft = new otri();
  otri botright = new otri();
  otri topright = new otri();
  otri botlcasing = new otri();
  otri botrcasing = new otri();
  otri toprcasing = new otri();
  otri gluetri = new otri();
  osub botlsubseg = new osub();
  osub botrsubseg = new osub();
  osub toprsubseg = new osub();
  GlobalMembersTriangle.REAL botvertex;
  GlobalMembersTriangle.REAL rightvertex;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  // Walk through the list of transformations (flips and a vertex insertion) 
  //   in the reverse of the order in which they were done, and undo them.   
  while (m.lastflip != (flipstacker) null)
  {
	// Find a triangle involved in the last unreversed transformation. 
	(fliptri).orient = (int)((int)(m.lastflip.flippedtri) & (int) 3l);
	(fliptri).tri = (GlobalMembersTriangle.REAL ** *)((int)(m.lastflip.flippedtri) ^ (int)(fliptri).orient);

	// We are reversing one of three transformations:  a trisection of one 
	//   triangle into three (by inserting a vertex in the triangle), a    
	//   bisection of two triangles into four (by inserting a vertex in an 
	//   edge), or an edge flip.                                           
	if (m.lastflip.prevflip == (flipstacker) null)
	{
	  // Restore a triangle that was split into three triangles, 
	  //   so it is again one triangle.                          
	  (botleft).tri = (fliptri).tri;
	  (botleft).orient = GlobalMembersTriangle.plus1mod3[(fliptri).orient];
	  ptr = (botleft).tri[(botleft).orient];
	  (botleft).orient = (int)((int)(ptr) & (int) 3l);
	  (botleft).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botleft).orient);
	  ;
	  ;
	  (botleft).orient = GlobalMembersTriangle.plus1mod3[(botleft).orient];
	  (botright).tri = (fliptri).tri;
	  (botright).orient = GlobalMembersTriangle.minus1mod3[(fliptri).orient];
	  ptr = (botright).tri[(botright).orient];
	  (botright).orient = (int)((int)(ptr) & (int) 3l);
	  (botright).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botright).orient);
	  ;
	  ;
	  (botright).orient = GlobalMembersTriangle.minus1mod3[(botright).orient];
	  ptr = (botleft).tri[(botleft).orient];
	  (botlcasing).orient = (int)((int)(ptr) & (int) 3l);
	  (botlcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botlcasing).orient);
	  ;
	  ptr = (botright).tri[(botright).orient];
	  (botrcasing).orient = (int)((int)(ptr) & (int) 3l);
	  (botrcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botrcasing).orient);
	  ;
	  botvertex = (GlobalMembersTriangle.REAL)(botleft).tri[GlobalMembersTriangle.minus1mod3[(botleft).orient] + 3];

	  (fliptri).tri[(fliptri).orient + 3] = (GlobalMembersTriangle.REAL) botvertex;
	  (fliptri).orient = GlobalMembersTriangle.plus1mod3[(fliptri).orient];
	  (fliptri).tri[(fliptri).orient] = (GlobalMembersTriangle.REAL)((int)(botlcasing).tri | (int)(botlcasing).orient);
	  (botlcasing).tri[(botlcasing).orient] = (GlobalMembersTriangle.REAL)((int)(fliptri).tri | (int)(fliptri).orient);
	  sptr = (GlobalMembersTriangle.REAL)(botleft).tri[6 + (botleft).orient];
	  (botlsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (botlsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  (fliptri).tri[6 + (fliptri).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botlsubseg).ss | (int)(botlsubseg).ssorient);
	  (botlsubseg).ss[6 + (botlsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(fliptri).tri | (int)(fliptri).orient);
	  (fliptri).orient = GlobalMembersTriangle.plus1mod3[(fliptri).orient];
	  (fliptri).tri[(fliptri).orient] = (GlobalMembersTriangle.REAL)((int)(botrcasing).tri | (int)(botrcasing).orient);
	  (botrcasing).tri[(botrcasing).orient] = (GlobalMembersTriangle.REAL)((int)(fliptri).tri | (int)(fliptri).orient);
	  sptr = (GlobalMembersTriangle.REAL)(botright).tri[6 + (botright).orient];
	  (botrsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (botrsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  (fliptri).tri[6 + (fliptri).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botrsubseg).ss | (int)(botrsubseg).ssorient);
	  (botrsubseg).ss[6 + (botrsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(fliptri).tri | (int)(fliptri).orient);

	  // Delete the two spliced-out triangles. 
	  GlobalMembersTriangle.triangledealloc(m, botleft.tri);
	  GlobalMembersTriangle.triangledealloc(m, botright.tri);
	}
	else if (m.lastflip.prevflip == (flipstacker) GlobalMembersTriangle.insertvertex)
	{
	  // Restore two triangles that were split into four triangles, 
	  //   so they are again two triangles.                         
	  (gluetri).tri = (fliptri).tri;
	  (gluetri).orient = GlobalMembersTriangle.minus1mod3[(fliptri).orient];
	  ptr = (gluetri).tri[(gluetri).orient];
	  (botright).orient = (int)((int)(ptr) & (int) 3l);
	  (botright).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botright).orient);
	  ;
	  (botright).orient = GlobalMembersTriangle.plus1mod3[(botright).orient];
	  ptr = (botright).tri[(botright).orient];
	  (botrcasing).orient = (int)((int)(ptr) & (int) 3l);
	  (botrcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(botrcasing).orient);
	  ;
	  rightvertex = (GlobalMembersTriangle.REAL)(botright).tri[GlobalMembersTriangle.minus1mod3[(botright).orient] + 3];

	  (fliptri).tri[GlobalMembersTriangle.plus1mod3[(fliptri).orient] + 3] = (GlobalMembersTriangle.REAL) rightvertex;
	  (gluetri).tri[(gluetri).orient] = (GlobalMembersTriangle.REAL)((int)(botrcasing).tri | (int)(botrcasing).orient);
	  (botrcasing).tri[(botrcasing).orient] = (GlobalMembersTriangle.REAL)((int)(gluetri).tri | (int)(gluetri).orient);
	  sptr = (GlobalMembersTriangle.REAL)(botright).tri[6 + (botright).orient];
	  (botrsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (botrsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  (gluetri).tri[6 + (gluetri).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(botrsubseg).ss | (int)(botrsubseg).ssorient);
	  (botrsubseg).ss[6 + (botrsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(gluetri).tri | (int)(gluetri).orient);

	  // Delete the spliced-out triangle. 
	  GlobalMembersTriangle.triangledealloc(m, botright.tri);

	  ptr = (fliptri).tri[(fliptri).orient];
	  (gluetri).orient = (int)((int)(ptr) & (int) 3l);
	  (gluetri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(gluetri).orient);
	  ;
	  if (gluetri.tri != m.dummytri)
	  {
		(gluetri).orient = GlobalMembersTriangle.plus1mod3[(gluetri).orient];
		ptr = (gluetri).tri[(gluetri).orient];
		(topright).orient = (int)((int)(ptr) & (int) 3l);
		(topright).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(topright).orient);
		;
		(topright).orient = GlobalMembersTriangle.minus1mod3[(topright).orient];
		;
		ptr = (topright).tri[(topright).orient];
		(toprcasing).orient = (int)((int)(ptr) & (int) 3l);
		(toprcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(toprcasing).orient);
		;

		(gluetri).tri[GlobalMembersTriangle.plus1mod3[(gluetri).orient] + 3] = (GlobalMembersTriangle.REAL) rightvertex;
		(gluetri).tri[(gluetri).orient] = (GlobalMembersTriangle.REAL)((int)(toprcasing).tri | (int)(toprcasing).orient);
		(toprcasing).tri[(toprcasing).orient] = (GlobalMembersTriangle.REAL)((int)(gluetri).tri | (int)(gluetri).orient);
		sptr = (GlobalMembersTriangle.REAL)(topright).tri[6 + (topright).orient];
		(toprsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
		(toprsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		(gluetri).tri[6 + (gluetri).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(toprsubseg).ss | (int)(toprsubseg).ssorient);
		(toprsubseg).ss[6 + (toprsubseg).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(gluetri).tri | (int)(gluetri).orient);

		// Delete the spliced-out triangle. 
		GlobalMembersTriangle.triangledealloc(m, topright.tri);
	  }

	  // This is the end of the list, sneakily encoded. 
	  m.lastflip.prevflip = (flipstacker) null;
	  }
	else
	{
	  // Undo an edge flip. 
	  GlobalMembersTriangle.unflip(m, b, fliptri);
	}

	// Go on and process the next transformation. 
	m.lastflip = m.lastflip.prevflip;
  }
}

//#endif // not CDT_ONLY

//*                                                                         *
//*                                                                         *
//******** Mesh transformation routines end here                     ********

//******** Divide-and-conquer Delaunay triangulation begins here     ********
//*                                                                         *
//*                                                                         *

//***************************************************************************
//                                                                           
//  The divide-and-conquer bounding box                                      
//                                                                           
//  I originally implemented the divide-and-conquer and incremental Delaunay 
//  triangulations using the edge-based data structure presented by Guibas   
//  and Stolfi.  Switching to a triangle-based data structure doubled the    
//  speed.  However, I had to think of a few extra tricks to maintain the    
//  elegance of the original algorithms.                                     
//                                                                           
//  The "bounding box" used by my variant of the divide-and-conquer          
//  algorithm uses one triangle for each edge of the convex hull of the      
//  triangulation.  These bounding triangles all share a common apical       
//  vertex, which is represented by NULL and which represents nothing.       
//  The bounding triangles are linked in a circular fan about this NULL      
//  vertex, and the edges on the convex hull of the triangulation appear     
//  opposite the NULL vertex.  You might find it easiest to imagine that     
//  the NULL vertex is a point in 3D space behind the center of the          
//  triangulation, and that the bounding triangles form a sort of cone.      
//                                                                           
//  This bounding box makes it easy to represent degenerate cases.  For      
//  instance, the triangulation of two vertices is a single edge.  This edge 
//  is represented by two bounding box triangles, one on each "side" of the  
//  edge.  These triangles are also linked together in a fan about the NULL  
//  vertex.                                                                  
//                                                                           
//  The bounding box also makes it easy to traverse the convex hull, as the  
//  divide-and-conquer algorithm needs to do.                                
//                                                                           
//***************************************************************************

//***************************************************************************
//                                                                           
//  vertexsort()   Sort an array of vertices by x-coordinate, using the      
//                 y-coordinate as a secondary key.                          
//                                                                           
//  Uses quicksort.  Randomized O(n log n) time.  No, I did not make any of  
//  the usual quicksort mistakes.                                            
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.vertexsort(GlobalMembersTriangle.REAL * *sortarray, int arraysize)
//#else
void GlobalMembersTriangle.vertexsort(sortarray, arraysize)
GlobalMembersTriangle.REAL * *sortarray;
int arraysize;
//#endif // not ANSI_DECLARATORS

{
  int left;
  int right;
  int pivot;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL pivotx;
  GlobalMembersTriangle.REAL pivoty;
  GlobalMembersTriangle.REAL temp;

  if (arraysize == 2)
  {
	// Recursive base case. 
	if ((sortarray[0][0] > sortarray[1][0]) || ((sortarray[0][0] == sortarray[1][0]) && (sortarray[0][1] > sortarray[1][1])))
	{
	  temp = sortarray[1];
	  sortarray[1] = sortarray[0];
	  sortarray[0] = temp;
	}
	return;
  }
  // Choose a random pivot to split the array. 
  pivot = (int) GlobalMembersTriangle.randomnation((int) arraysize);
  pivotx = sortarray[pivot][0];
  pivoty = sortarray[pivot][1];
  // Split the array. 
  left = -1;
  right = arraysize;
  while (left < right)
  {
	// Search for a vertex whose x-coordinate is too large for the left. 
	do
	{
	  left++;
	} while ((left <= right) && ((sortarray[left][0] < pivotx) || ((sortarray[left][0] == pivotx) && (sortarray[left][1] < pivoty))));
	// Search for a vertex whose x-coordinate is too small for the right. 
	do
	{
	  right--;
	} while ((left <= right) && ((sortarray[right][0] > pivotx) || ((sortarray[right][0] == pivotx) && (sortarray[right][1] > pivoty))));
	if (left < right)
	{
	  // Swap the left and right vertices. 
	  temp = sortarray[left];
	  sortarray[left] = sortarray[right];
	  sortarray[right] = temp;
	}
  }
  if (left > 1)
  {
	// Recursively sort the left subset. 
	GlobalMembersTriangle.vertexsort(sortarray, left);
  }
  if (right < arraysize - 2)
  {
	// Recursively sort the right subset. 
	GlobalMembersTriangle.vertexsort(sortarray[right + 1], arraysize - right - 1);
  }
}

//***************************************************************************
//                                                                           
//  vertexmedian()   An order statistic algorithm, almost.  Shuffles an      
//                   array of vertices so that the first `median' vertices   
//                   occur lexicographically before the remaining vertices.  
//                                                                           
//  Uses the x-coordinate as the primary key if axis == 0; the y-coordinate  
//  if axis == 1.  Very similar to the vertexsort() procedure, but runs in   
//  randomized linear time.                                                  
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.vertexmedian(GlobalMembersTriangle.REAL * *sortarray, int arraysize, int median, int axis)
//#else
void GlobalMembersTriangle.vertexmedian(sortarray, arraysize, median, axis)
GlobalMembersTriangle.REAL * *sortarray;
int arraysize;
int median;
int axis;
//#endif // not ANSI_DECLARATORS

{
  int left;
  int right;
  int pivot;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL pivot1;
  GlobalMembersTriangle.REAL pivot2;
  GlobalMembersTriangle.REAL temp;

  if (arraysize == 2)
  {
	// Recursive base case. 
	if ((sortarray[0][axis] > sortarray[1][axis]) || ((sortarray[0][axis] == sortarray[1][axis]) && (sortarray[0][1 - axis] > sortarray[1][1 - axis])))
	{
	  temp = sortarray[1];
	  sortarray[1] = sortarray[0];
	  sortarray[0] = temp;
	}
	return;
  }
  // Choose a random pivot to split the array. 
  pivot = (int) GlobalMembersTriangle.randomnation((int) arraysize);
  pivot1 = sortarray[pivot][axis];
  pivot2 = sortarray[pivot][1 - axis];
  // Split the array. 
  left = -1;
  right = arraysize;
  while (left < right)
  {
	// Search for a vertex whose x-coordinate is too large for the left. 
	do
	{
	  left++;
	} while ((left <= right) && ((sortarray[left][axis] < pivot1) || ((sortarray[left][axis] == pivot1) && (sortarray[left][1 - axis] < pivot2))));
	// Search for a vertex whose x-coordinate is too small for the right. 
	do
	{
	  right--;
	} while ((left <= right) && ((sortarray[right][axis] > pivot1) || ((sortarray[right][axis] == pivot1) && (sortarray[right][1 - axis] > pivot2))));
	if (left < right)
	{
	  // Swap the left and right vertices. 
	  temp = sortarray[left];
	  sortarray[left] = sortarray[right];
	  sortarray[right] = temp;
	}
  }
  // Unlike in vertexsort(), at most one of the following 
  //   conditionals is true.                             
  if (left > median)
  {
	// Recursively shuffle the left subset. 
	GlobalMembersTriangle.vertexmedian(sortarray, left, median, axis);
  }
  if (right < median - 1)
  {
	// Recursively shuffle the right subset. 
	GlobalMembersTriangle.vertexmedian(sortarray[right + 1], arraysize - right - 1, median - right - 1, axis);
  }
}

//***************************************************************************
//                                                                           
//  alternateaxes()   Sorts the vertices as appropriate for the divide-and-  
//                    conquer algorithm with alternating cuts.               
//                                                                           
//  Partitions by x-coordinate if axis == 0; by y-coordinate if axis == 1.   
//  For the base case, subsets containing only two or three vertices are     
//  always sorted by x-coordinate.                                           
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.alternateaxes(GlobalMembersTriangle.REAL * *sortarray, int arraysize, int axis)
//#else
void GlobalMembersTriangle.alternateaxes(sortarray, arraysize, axis)
GlobalMembersTriangle.REAL * *sortarray;
int arraysize;
int axis;
//#endif // not ANSI_DECLARATORS

{
  int divider;

  divider = arraysize >> 1;
  if (arraysize <= 3)
  {
	// Recursive base case:  subsets of two or three vertices will be    
	//   handled specially, and should always be sorted by x-coordinate. 
	axis = 0;
  }
  // Partition with a horizontal or vertical cut. 
  GlobalMembersTriangle.vertexmedian(sortarray, arraysize, divider, axis);
  // Recursively partition the subsets with a cross cut. 
  if (arraysize - divider >= 2)
  {
	if (divider >= 2)
	{
	  GlobalMembersTriangle.alternateaxes(sortarray, divider, 1 - axis);
	}
	GlobalMembersTriangle.alternateaxes(sortarray[divider], arraysize - divider, 1 - axis);
  }
}

//***************************************************************************
//                                                                           
//  mergehulls()   Merge two adjacent Delaunay triangulations into a         
//                 single Delaunay triangulation.                            
//                                                                           
//  This is similar to the algorithm given by Guibas and Stolfi, but uses    
//  a triangle-based, rather than edge-based, data structure.                
//                                                                           
//  The algorithm walks up the gap between the two triangulations, knitting  
//  them together.  As they are merged, some of their bounding triangles     
//  are converted into real triangles of the triangulation.  The procedure   
//  pulls each hull's bounding triangles apart, then knits them together     
//  like the teeth of two gears.  The Delaunay property determines, at each  
//  step, whether the next "tooth" is a bounding triangle of the left hull   
//  or the right.  When a bounding triangle becomes real, its apex is        
//  changed from NULL to a real vertex.                                      
//                                                                           
//  Only two new triangles need to be allocated.  These become new bounding  
//  triangles at the top and bottom of the seam.  They are used to connect   
//  the remaining bounding triangles (those that have not been converted     
//  into real triangles) into a single fan.                                  
//                                                                           
//  On entry, `farleft' and `innerleft' are bounding triangles of the left   
//  triangulation.  The origin of `farleft' is the leftmost vertex, and      
//  the destination of `innerleft' is the rightmost vertex of the            
//  triangulation.  Similarly, `innerright' and `farright' are bounding      
//  triangles of the right triangulation.  The origin of `innerright' and    
//  destination of `farright' are the leftmost and rightmost vertices.       
//                                                                           
//  On completion, the origin of `farleft' is the leftmost vertex of the     
//  merged triangulation, and the destination of `farright' is the rightmost 
//  vertex.                                                                  
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.mergehulls(struct mesh m, struct behavior b, struct otri *farleft, struct otri *innerleft, struct otri *innerright, struct otri *farright, int axis)
//#else
void GlobalMembersTriangle.mergehulls(m, b, farleft, innerleft, innerright, farright, axis)
mesh m;
behavior b;
otri farleft;
otri innerleft;
otri innerright;
otri farright;
int axis;
//#endif // not ANSI_DECLARATORS

{
  otri leftcand = new otri();
  otri rightcand = new otri();
  otri baseedge = new otri();
  otri nextedge = new otri();
  otri sidecasing = new otri();
  otri topcasing = new otri();
  otri outercasing = new otri();
  otri checkedge = new otri();
  GlobalMembersTriangle.REAL innerleftdest;
  GlobalMembersTriangle.REAL innerrightorg;
  GlobalMembersTriangle.REAL innerleftapex;
  GlobalMembersTriangle.REAL innerrightapex;
  GlobalMembersTriangle.REAL farleftpt;
  GlobalMembersTriangle.REAL farrightpt;
  GlobalMembersTriangle.REAL farleftapex;
  GlobalMembersTriangle.REAL farrightapex;
  GlobalMembersTriangle.REAL lowerleft;
  GlobalMembersTriangle.REAL lowerright;
  GlobalMembersTriangle.REAL upperleft;
  GlobalMembersTriangle.REAL upperright;
  GlobalMembersTriangle.REAL nextapex;
  GlobalMembersTriangle.REAL checkvertex;
  int changemade;
  int badedge;
  int leftfinished;
  int rightfinished;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().

  innerleftdest = (GlobalMembersTriangle.REAL) innerleft.tri[GlobalMembersTriangle.minus1mod3[innerleft.orient] + 3];
  innerleftapex = (GlobalMembersTriangle.REAL) innerleft.tri[innerleft.orient + 3];
  innerrightorg = (GlobalMembersTriangle.REAL) innerright.tri[GlobalMembersTriangle.plus1mod3[innerright.orient] + 3];
  innerrightapex = (GlobalMembersTriangle.REAL) innerright.tri[innerright.orient + 3];
  // Special treatment for horizontal cuts. 
  if (b.dwyer != 0 && (axis == 1))
  {
	farleftpt = (GlobalMembersTriangle.REAL) farleft.tri[GlobalMembersTriangle.plus1mod3[farleft.orient] + 3];
	farleftapex = (GlobalMembersTriangle.REAL) farleft.tri[farleft.orient + 3];
	farrightpt = (GlobalMembersTriangle.REAL) farright.tri[GlobalMembersTriangle.minus1mod3[farright.orient] + 3];
	farrightapex = (GlobalMembersTriangle.REAL) farright.tri[farright.orient + 3];
	// The pointers to the extremal vertices are shifted to point to the 
	//   topmost and bottommost vertex of each hull, rather than the     
	//   leftmost and rightmost vertices.                                
	while (farleftapex[1] < farleftpt[1])
	{
	  farleft.orient = GlobalMembersTriangle.plus1mod3[farleft.orient];
	  ptr = farleft.tri[farleft.orient];
	  farleft.orient = (int)((int)(ptr) & (int) 3l);
	  farleft.tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int) farleft.orient);
	  ;
	  farleftpt = farleftapex;
	  farleftapex = (GlobalMembersTriangle.REAL) farleft.tri[farleft.orient + 3];
	}
	ptr = innerleft.tri[innerleft.orient];
	(checkedge).orient = (int)((int)(ptr) & (int) 3l);
	(checkedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(checkedge).orient);
	;
	checkvertex = (GlobalMembersTriangle.REAL)(checkedge).tri[(checkedge).orient + 3];
	while (checkvertex[1] > innerleftdest[1])
	{
	  innerleft.tri = (checkedge).tri;
	  innerleft.orient = GlobalMembersTriangle.plus1mod3[(checkedge).orient];
	  innerleftapex = innerleftdest;
	  innerleftdest = checkvertex;
	  ptr = innerleft.tri[innerleft.orient];
	  (checkedge).orient = (int)((int)(ptr) & (int) 3l);
	  (checkedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(checkedge).orient);
	  ;
	  checkvertex = (GlobalMembersTriangle.REAL)(checkedge).tri[(checkedge).orient + 3];
	}
	while (innerrightapex[1] < innerrightorg[1])
	{
	  innerright.orient = GlobalMembersTriangle.plus1mod3[innerright.orient];
	  ptr = innerright.tri[innerright.orient];
	  innerright.orient = (int)((int)(ptr) & (int) 3l);
	  innerright.tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int) innerright.orient);
	  ;
	  innerrightorg = innerrightapex;
	  innerrightapex = (GlobalMembersTriangle.REAL) innerright.tri[innerright.orient + 3];
	}
	ptr = farright.tri[farright.orient];
	(checkedge).orient = (int)((int)(ptr) & (int) 3l);
	(checkedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(checkedge).orient);
	;
	checkvertex = (GlobalMembersTriangle.REAL)(checkedge).tri[(checkedge).orient + 3];
	while (checkvertex[1] > farrightpt[1])
	{
	  farright.tri = (checkedge).tri;
	  farright.orient = GlobalMembersTriangle.plus1mod3[(checkedge).orient];
	  farrightapex = farrightpt;
	  farrightpt = checkvertex;
	  ptr = farright.tri[farright.orient];
	  (checkedge).orient = (int)((int)(ptr) & (int) 3l);
	  (checkedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(checkedge).orient);
	  ;
	  checkvertex = (GlobalMembersTriangle.REAL)(checkedge).tri[(checkedge).orient + 3];
	}
  }
  // Find a line tangent to and below both hulls. 
  do
  {
	changemade = 0;
	// Make innerleftdest the "bottommost" vertex of the left hull. 
	if (GlobalMembersTriangle.counterclockwise(m, b, innerleftdest, innerleftapex, innerrightorg) > 0.0)
	{
	  innerleft.orient = GlobalMembersTriangle.minus1mod3[innerleft.orient];
	  ptr = innerleft.tri[innerleft.orient];
	  innerleft.orient = (int)((int)(ptr) & (int) 3l);
	  innerleft.tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int) innerleft.orient);
	  ;
	  innerleftdest = innerleftapex;
	  innerleftapex = (GlobalMembersTriangle.REAL) innerleft.tri[innerleft.orient + 3];
	  changemade = 1;
	}
	// Make innerrightorg the "bottommost" vertex of the right hull. 
	if (GlobalMembersTriangle.counterclockwise(m, b, innerrightapex, innerrightorg, innerleftdest) > 0.0)
	{
	  innerright.orient = GlobalMembersTriangle.plus1mod3[innerright.orient];
	  ptr = innerright.tri[innerright.orient];
	  innerright.orient = (int)((int)(ptr) & (int) 3l);
	  innerright.tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int) innerright.orient);
	  ;
	  innerrightorg = innerrightapex;
	  innerrightapex = (GlobalMembersTriangle.REAL) innerright.tri[innerright.orient + 3];
	  changemade = 1;
	}
  } while (changemade);
  // Find the two candidates to be the next "gear tooth." 
  ptr = innerleft.tri[innerleft.orient];
  (leftcand).orient = (int)((int)(ptr) & (int) 3l);
  (leftcand).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(leftcand).orient);
  ;
  ptr = innerright.tri[innerright.orient];
  (rightcand).orient = (int)((int)(ptr) & (int) 3l);
  (rightcand).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(rightcand).orient);
  ;
  // Create the bottom new bounding triangle. 
  GlobalMembersTriangle.maketriangle(m, b, baseedge);
  // Connect it to the bounding boxes of the left and right triangulations. 
  (baseedge).tri[(baseedge).orient] = (GlobalMembersTriangle.REAL)((int) innerleft.tri | (int) innerleft.orient);
  innerleft.tri[innerleft.orient] = (GlobalMembersTriangle.REAL)((int)(baseedge).tri | (int)(baseedge).orient);
  (baseedge).orient = GlobalMembersTriangle.plus1mod3[(baseedge).orient];
  (baseedge).tri[(baseedge).orient] = (GlobalMembersTriangle.REAL)((int) innerright.tri | (int) innerright.orient);
  innerright.tri[innerright.orient] = (GlobalMembersTriangle.REAL)((int)(baseedge).tri | (int)(baseedge).orient);
  (baseedge).orient = GlobalMembersTriangle.plus1mod3[(baseedge).orient];
  (baseedge).tri[GlobalMembersTriangle.plus1mod3[(baseedge).orient] + 3] = (GlobalMembersTriangle.REAL) innerrightorg;
  (baseedge).tri[GlobalMembersTriangle.minus1mod3[(baseedge).orient] + 3] = (GlobalMembersTriangle.REAL) innerleftdest;
  // Apex is intentionally left NULL. 
  if (b.verbose > 2)
  {
	System.out.print("  Creating base bounding ");
	GlobalMembersTriangle.printtriangle(m, b, baseedge);
  }
  // Fix the extreme triangles if necessary. 
  farleftpt = (GlobalMembersTriangle.REAL) farleft.tri[GlobalMembersTriangle.plus1mod3[farleft.orient] + 3];
  if (innerleftdest == farleftpt)
  {
	farleft.tri = (baseedge).tri;
	farleft.orient = GlobalMembersTriangle.plus1mod3[(baseedge).orient];
  }
  farrightpt = (GlobalMembersTriangle.REAL) farright.tri[GlobalMembersTriangle.minus1mod3[farright.orient] + 3];
  if (innerrightorg == farrightpt)
  {
	farright.tri = (baseedge).tri;
	farright.orient = GlobalMembersTriangle.minus1mod3[(baseedge).orient];
  }
  // The vertices of the current knitting edge. 
  lowerleft = innerleftdest;
  lowerright = innerrightorg;
  // The candidate vertices for knitting. 
  upperleft = (GlobalMembersTriangle.REAL)(leftcand).tri[(leftcand).orient + 3];
  upperright = (GlobalMembersTriangle.REAL)(rightcand).tri[(rightcand).orient + 3];
  // Walk up the gap between the two triangulations, knitting them together. 
  while (1)
  {
	// Have we reached the top?  (This isn't quite the right question,       
	//   because even though the left triangulation might seem finished now, 
	//   moving up on the right triangulation might reveal a new vertex of   
	//   the left triangulation.  And vice-versa.)                           
	leftfinished = GlobalMembersTriangle.counterclockwise(m, b, upperleft, lowerleft, lowerright) <= 0.0;
	rightfinished = GlobalMembersTriangle.counterclockwise(m, b, upperright, lowerleft, lowerright) <= 0.0;
	if (leftfinished != 0 && rightfinished != 0)
	{
	  // Create the top new bounding triangle. 
	  GlobalMembersTriangle.maketriangle(m, b, nextedge);
	  (nextedge).tri[GlobalMembersTriangle.plus1mod3[(nextedge).orient] + 3] = (GlobalMembersTriangle.REAL) lowerleft;
	  (nextedge).tri[GlobalMembersTriangle.minus1mod3[(nextedge).orient] + 3] = (GlobalMembersTriangle.REAL) lowerright;
	  // Apex is intentionally left NULL. 
	  // Connect it to the bounding boxes of the two triangulations. 
	  (nextedge).tri[(nextedge).orient] = (GlobalMembersTriangle.REAL)((int)(baseedge).tri | (int)(baseedge).orient);
	  (baseedge).tri[(baseedge).orient] = (GlobalMembersTriangle.REAL)((int)(nextedge).tri | (int)(nextedge).orient);
	  (nextedge).orient = GlobalMembersTriangle.plus1mod3[(nextedge).orient];
	  (nextedge).tri[(nextedge).orient] = (GlobalMembersTriangle.REAL)((int)(rightcand).tri | (int)(rightcand).orient);
	  (rightcand).tri[(rightcand).orient] = (GlobalMembersTriangle.REAL)((int)(nextedge).tri | (int)(nextedge).orient);
	  (nextedge).orient = GlobalMembersTriangle.plus1mod3[(nextedge).orient];
	  (nextedge).tri[(nextedge).orient] = (GlobalMembersTriangle.REAL)((int)(leftcand).tri | (int)(leftcand).orient);
	  (leftcand).tri[(leftcand).orient] = (GlobalMembersTriangle.REAL)((int)(nextedge).tri | (int)(nextedge).orient);
	  if (b.verbose > 2)
	  {
		System.out.print("  Creating top bounding ");
		GlobalMembersTriangle.printtriangle(m, b, nextedge);
	  }
	  // Special treatment for horizontal cuts. 
	  if (b.dwyer != 0 && (axis == 1))
	  {
		farleftpt = (GlobalMembersTriangle.REAL) farleft.tri[GlobalMembersTriangle.plus1mod3[farleft.orient] + 3];
		farleftapex = (GlobalMembersTriangle.REAL) farleft.tri[farleft.orient + 3];
		farrightpt = (GlobalMembersTriangle.REAL) farright.tri[GlobalMembersTriangle.minus1mod3[farright.orient] + 3];
		farrightapex = (GlobalMembersTriangle.REAL) farright.tri[farright.orient + 3];
		ptr = farleft.tri[farleft.orient];
		(checkedge).orient = (int)((int)(ptr) & (int) 3l);
		(checkedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(checkedge).orient);
		;
		checkvertex = (GlobalMembersTriangle.REAL)(checkedge).tri[(checkedge).orient + 3];
		// The pointers to the extremal vertices are restored to the  
		//   leftmost and rightmost vertices (rather than topmost and 
		//   bottommost).                                             
		while (checkvertex[0] < farleftpt[0])
		{
		  farleft.tri = (checkedge).tri;
		  farleft.orient = GlobalMembersTriangle.minus1mod3[(checkedge).orient];
		  farleftapex = farleftpt;
		  farleftpt = checkvertex;
		  ptr = farleft.tri[farleft.orient];
		  (checkedge).orient = (int)((int)(ptr) & (int) 3l);
		  (checkedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(checkedge).orient);
		  ;
		  checkvertex = (GlobalMembersTriangle.REAL)(checkedge).tri[(checkedge).orient + 3];
		}
		while (farrightapex[0] > farrightpt[0])
		{
		  farright.orient = GlobalMembersTriangle.minus1mod3[farright.orient];
		  ptr = farright.tri[farright.orient];
		  farright.orient = (int)((int)(ptr) & (int) 3l);
		  farright.tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int) farright.orient);
		  ;
		  farrightpt = farrightapex;
		  farrightapex = (GlobalMembersTriangle.REAL) farright.tri[farright.orient + 3];
		}
	  }
	  return;
	}
	// Consider eliminating edges from the left triangulation. 
	if (leftfinished == 0)
	{
	  // What vertex would be exposed if an edge were deleted? 
	  (nextedge).tri = (leftcand).tri;
	  (nextedge).orient = GlobalMembersTriangle.minus1mod3[(leftcand).orient];
	  ptr = (nextedge).tri[(nextedge).orient];
	  (nextedge).orient = (int)((int)(ptr) & (int) 3l);
	  (nextedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(nextedge).orient);
	  ;
	  nextapex = (GlobalMembersTriangle.REAL)(nextedge).tri[(nextedge).orient + 3];
	  // If nextapex is NULL, then no vertex would be exposed; the 
	  //   triangulation would have been eaten right through.      
	  if (nextapex != (GlobalMembersTriangle.REAL) null)
	  {
		// Check whether the edge is Delaunay. 
		badedge = GlobalMembersTriangle.incircle(m, b, lowerleft, lowerright, upperleft, nextapex) > 0.0;
		while (badedge != 0)
		{
		  // Eliminate the edge with an edge flip.  As a result, the    
		  //   left triangulation will have one more boundary triangle. 
		  (nextedge).orient = GlobalMembersTriangle.plus1mod3[(nextedge).orient];
		  ptr = (nextedge).tri[(nextedge).orient];
		  (topcasing).orient = (int)((int)(ptr) & (int) 3l);
		  (topcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(topcasing).orient);
		  ;
		  (nextedge).orient = GlobalMembersTriangle.plus1mod3[(nextedge).orient];
		  ptr = (nextedge).tri[(nextedge).orient];
		  (sidecasing).orient = (int)((int)(ptr) & (int) 3l);
		  (sidecasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(sidecasing).orient);
		  ;
		  (nextedge).tri[(nextedge).orient] = (GlobalMembersTriangle.REAL)((int)(topcasing).tri | (int)(topcasing).orient);
		  (topcasing).tri[(topcasing).orient] = (GlobalMembersTriangle.REAL)((int)(nextedge).tri | (int)(nextedge).orient);
		  (leftcand).tri[(leftcand).orient] = (GlobalMembersTriangle.REAL)((int)(sidecasing).tri | (int)(sidecasing).orient);
		  (sidecasing).tri[(sidecasing).orient] = (GlobalMembersTriangle.REAL)((int)(leftcand).tri | (int)(leftcand).orient);
		  (leftcand).orient = GlobalMembersTriangle.plus1mod3[(leftcand).orient];
		  ptr = (leftcand).tri[(leftcand).orient];
		  (outercasing).orient = (int)((int)(ptr) & (int) 3l);
		  (outercasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(outercasing).orient);
		  ;
		  (nextedge).orient = GlobalMembersTriangle.minus1mod3[(nextedge).orient];
		  (nextedge).tri[(nextedge).orient] = (GlobalMembersTriangle.REAL)((int)(outercasing).tri | (int)(outercasing).orient);
		  (outercasing).tri[(outercasing).orient] = (GlobalMembersTriangle.REAL)((int)(nextedge).tri | (int)(nextedge).orient);
		  // Correct the vertices to reflect the edge flip. 
		  (leftcand).tri[GlobalMembersTriangle.plus1mod3[(leftcand).orient] + 3] = (GlobalMembersTriangle.REAL) lowerleft;
		  (leftcand).tri[GlobalMembersTriangle.minus1mod3[(leftcand).orient] + 3] = (GlobalMembersTriangle.REAL) null;
		  (leftcand).tri[(leftcand).orient + 3] = (GlobalMembersTriangle.REAL) nextapex;
		  (nextedge).tri[GlobalMembersTriangle.plus1mod3[(nextedge).orient] + 3] = (GlobalMembersTriangle.REAL) null;
		  (nextedge).tri[GlobalMembersTriangle.minus1mod3[(nextedge).orient] + 3] = (GlobalMembersTriangle.REAL) upperleft;
		  (nextedge).tri[(nextedge).orient + 3] = (GlobalMembersTriangle.REAL) nextapex;
		  // Consider the newly exposed vertex. 
		  upperleft = nextapex;
		  // What vertex would be exposed if another edge were deleted? 
		  (nextedge).tri = (sidecasing).tri;
		  (nextedge).orient = (sidecasing).orient;
		  nextapex = (GlobalMembersTriangle.REAL)(nextedge).tri[(nextedge).orient + 3];
		  if (nextapex != (GlobalMembersTriangle.REAL) null)
		  {
			// Check whether the edge is Delaunay. 
			badedge = GlobalMembersTriangle.incircle(m, b, lowerleft, lowerright, upperleft, nextapex) > 0.0;
		  }
		  else
		  {
			// Avoid eating right through the triangulation. 
			badedge = 0;
		  }
		}
	  }
	}
	// Consider eliminating edges from the right triangulation. 
	if (rightfinished == 0)
	{
	  // What vertex would be exposed if an edge were deleted? 
	  (nextedge).tri = (rightcand).tri;
	  (nextedge).orient = GlobalMembersTriangle.plus1mod3[(rightcand).orient];
	  ptr = (nextedge).tri[(nextedge).orient];
	  (nextedge).orient = (int)((int)(ptr) & (int) 3l);
	  (nextedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(nextedge).orient);
	  ;
	  nextapex = (GlobalMembersTriangle.REAL)(nextedge).tri[(nextedge).orient + 3];
	  // If nextapex is NULL, then no vertex would be exposed; the 
	  //   triangulation would have been eaten right through.      
	  if (nextapex != (GlobalMembersTriangle.REAL) null)
	  {
		// Check whether the edge is Delaunay. 
		badedge = GlobalMembersTriangle.incircle(m, b, lowerleft, lowerright, upperright, nextapex) > 0.0;
		while (badedge != 0)
		{
		  // Eliminate the edge with an edge flip.  As a result, the     
		  //   right triangulation will have one more boundary triangle. 
		  (nextedge).orient = GlobalMembersTriangle.minus1mod3[(nextedge).orient];
		  ptr = (nextedge).tri[(nextedge).orient];
		  (topcasing).orient = (int)((int)(ptr) & (int) 3l);
		  (topcasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(topcasing).orient);
		  ;
		  (nextedge).orient = GlobalMembersTriangle.minus1mod3[(nextedge).orient];
		  ptr = (nextedge).tri[(nextedge).orient];
		  (sidecasing).orient = (int)((int)(ptr) & (int) 3l);
		  (sidecasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(sidecasing).orient);
		  ;
		  (nextedge).tri[(nextedge).orient] = (GlobalMembersTriangle.REAL)((int)(topcasing).tri | (int)(topcasing).orient);
		  (topcasing).tri[(topcasing).orient] = (GlobalMembersTriangle.REAL)((int)(nextedge).tri | (int)(nextedge).orient);
		  (rightcand).tri[(rightcand).orient] = (GlobalMembersTriangle.REAL)((int)(sidecasing).tri | (int)(sidecasing).orient);
		  (sidecasing).tri[(sidecasing).orient] = (GlobalMembersTriangle.REAL)((int)(rightcand).tri | (int)(rightcand).orient);
		  (rightcand).orient = GlobalMembersTriangle.minus1mod3[(rightcand).orient];
		  ptr = (rightcand).tri[(rightcand).orient];
		  (outercasing).orient = (int)((int)(ptr) & (int) 3l);
		  (outercasing).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(outercasing).orient);
		  ;
		  (nextedge).orient = GlobalMembersTriangle.plus1mod3[(nextedge).orient];
		  (nextedge).tri[(nextedge).orient] = (GlobalMembersTriangle.REAL)((int)(outercasing).tri | (int)(outercasing).orient);
		  (outercasing).tri[(outercasing).orient] = (GlobalMembersTriangle.REAL)((int)(nextedge).tri | (int)(nextedge).orient);
		  // Correct the vertices to reflect the edge flip. 
		  (rightcand).tri[GlobalMembersTriangle.plus1mod3[(rightcand).orient] + 3] = (GlobalMembersTriangle.REAL) null;
		  (rightcand).tri[GlobalMembersTriangle.minus1mod3[(rightcand).orient] + 3] = (GlobalMembersTriangle.REAL) lowerright;
		  (rightcand).tri[(rightcand).orient + 3] = (GlobalMembersTriangle.REAL) nextapex;
		  (nextedge).tri[GlobalMembersTriangle.plus1mod3[(nextedge).orient] + 3] = (GlobalMembersTriangle.REAL) upperright;
		  (nextedge).tri[GlobalMembersTriangle.minus1mod3[(nextedge).orient] + 3] = (GlobalMembersTriangle.REAL) null;
		  (nextedge).tri[(nextedge).orient + 3] = (GlobalMembersTriangle.REAL) nextapex;
		  // Consider the newly exposed vertex. 
		  upperright = nextapex;
		  // What vertex would be exposed if another edge were deleted? 
		  (nextedge).tri = (sidecasing).tri;
		  (nextedge).orient = (sidecasing).orient;
		  nextapex = (GlobalMembersTriangle.REAL)(nextedge).tri[(nextedge).orient + 3];
		  if (nextapex != (GlobalMembersTriangle.REAL) null)
		  {
			// Check whether the edge is Delaunay. 
			badedge = GlobalMembersTriangle.incircle(m, b, lowerleft, lowerright, upperright, nextapex) > 0.0;
		  }
		  else
		  {
			// Avoid eating right through the triangulation. 
			badedge = 0;
		  }
		}
	  }
	}
	if (leftfinished != 0 || (rightfinished == 0 && (GlobalMembersTriangle.incircle(m, b, upperleft, lowerleft, lowerright, upperright) > 0.0)))
	{
	  // Knit the triangulations, adding an edge from `lowerleft' 
	  //   to `upperright'.                                       
	  (baseedge).tri[(baseedge).orient] = (GlobalMembersTriangle.REAL)((int)(rightcand).tri | (int)(rightcand).orient);
	  (rightcand).tri[(rightcand).orient] = (GlobalMembersTriangle.REAL)((int)(baseedge).tri | (int)(baseedge).orient);
	  (baseedge).tri = (rightcand).tri;
	  (baseedge).orient = GlobalMembersTriangle.minus1mod3[(rightcand).orient];
	  (baseedge).tri[GlobalMembersTriangle.minus1mod3[(baseedge).orient] + 3] = (GlobalMembersTriangle.REAL) lowerleft;
	  lowerright = upperright;
	  ptr = (baseedge).tri[(baseedge).orient];
	  (rightcand).orient = (int)((int)(ptr) & (int) 3l);
	  (rightcand).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(rightcand).orient);
	  ;
	  upperright = (GlobalMembersTriangle.REAL)(rightcand).tri[(rightcand).orient + 3];
	}
	else
	{
	  // Knit the triangulations, adding an edge from `upperleft' 
	  //   to `lowerright'.                                       
	  (baseedge).tri[(baseedge).orient] = (GlobalMembersTriangle.REAL)((int)(leftcand).tri | (int)(leftcand).orient);
	  (leftcand).tri[(leftcand).orient] = (GlobalMembersTriangle.REAL)((int)(baseedge).tri | (int)(baseedge).orient);
	  (baseedge).tri = (leftcand).tri;
	  (baseedge).orient = GlobalMembersTriangle.plus1mod3[(leftcand).orient];
	  (baseedge).tri[GlobalMembersTriangle.plus1mod3[(baseedge).orient] + 3] = (GlobalMembersTriangle.REAL) lowerright;
	  lowerleft = upperleft;
	  ptr = (baseedge).tri[(baseedge).orient];
	  (leftcand).orient = (int)((int)(ptr) & (int) 3l);
	  (leftcand).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(leftcand).orient);
	  ;
	  upperleft = (GlobalMembersTriangle.REAL)(leftcand).tri[(leftcand).orient + 3];
	}
	if (b.verbose > 2)
	{
	  System.out.print("  Connecting ");
	  GlobalMembersTriangle.printtriangle(m, b, baseedge);
	}
  }
}

//***************************************************************************
//                                                                           
//  divconqrecurse()   Recursively form a Delaunay triangulation by the      
//                     divide-and-conquer method.                            
//                                                                           
//  Recursively breaks down the problem into smaller pieces, which are       
//  knitted together by mergehulls().  The base cases (problems of two or    
//  three vertices) are handled specially here.                              
//                                                                           
//  On completion, `farleft' and `farright' are bounding triangles such that 
//  the origin of `farleft' is the leftmost vertex (breaking ties by         
//  choosing the highest leftmost vertex), and the destination of            
//  `farright' is the rightmost vertex (breaking ties by choosing the        
//  lowest rightmost vertex).                                                
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.divconqrecurse(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL * *sortarray, int vertices, int axis, struct otri farleft, struct otri farright)
//#else
void GlobalMembersTriangle.divconqrecurse(m, b, sortarray, vertices, axis, farleft, farright)
mesh m;
behavior b;
GlobalMembersTriangle.REAL * *sortarray;
int vertices;
int axis;
otri farleft;
otri farright;
//#endif // not ANSI_DECLARATORS

{
  otri midtri = new otri();
  otri tri1 = new otri();
  otri tri2 = new otri();
  otri tri3 = new otri();
  otri innerleft = new otri();
  otri innerright = new otri();
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL area;
  int divider;

  if (b.verbose > 2)
  {
	System.out.printf("  Triangulating %d vertices.\n", vertices);
  }
  if (vertices == 2)
  {
	// The triangulation of two vertices is an edge.  An edge is 
	//   represented by two bounding triangles.                  
	GlobalMembersTriangle.maketriangle(m, b, farleft);
	farleft.tri[GlobalMembersTriangle.plus1mod3[farleft.orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[0];
	farleft.tri[GlobalMembersTriangle.minus1mod3[farleft.orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
	// The apex is intentionally left NULL. 
	GlobalMembersTriangle.maketriangle(m, b, farright);
	farright.tri[GlobalMembersTriangle.plus1mod3[farright.orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
	farright.tri[GlobalMembersTriangle.minus1mod3[farright.orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[0];
	// The apex is intentionally left NULL. 
	farleft.tri[farleft.orient] = (GlobalMembersTriangle.REAL)((int) farright.tri | (int) farright.orient);
	farright.tri[farright.orient] = (GlobalMembersTriangle.REAL)((int) farleft.tri | (int) farleft.orient);
	farleft.orient = GlobalMembersTriangle.minus1mod3[farleft.orient];
	farright.orient = GlobalMembersTriangle.plus1mod3[farright.orient];
	farleft.tri[farleft.orient] = (GlobalMembersTriangle.REAL)((int) farright.tri | (int) farright.orient);
	farright.tri[farright.orient] = (GlobalMembersTriangle.REAL)((int) farleft.tri | (int) farleft.orient);
	farleft.orient = GlobalMembersTriangle.minus1mod3[farleft.orient];
	farright.orient = GlobalMembersTriangle.plus1mod3[farright.orient];
	farleft.tri[farleft.orient] = (GlobalMembersTriangle.REAL)((int) farright.tri | (int) farright.orient);
	farright.tri[farright.orient] = (GlobalMembersTriangle.REAL)((int) farleft.tri | (int) farleft.orient);
	if (b.verbose > 2)
	{
	  System.out.print("  Creating ");
	  GlobalMembersTriangle.printtriangle(m, b, farleft);
	  System.out.print("  Creating ");
	  GlobalMembersTriangle.printtriangle(m, b, farright);
	}
	// Ensure that the origin of `farleft' is sortarray[0]. 
	farleft.tri = farright.tri;
	farleft.orient = GlobalMembersTriangle.minus1mod3[farright.orient];
	return;
	}
  else if (vertices == 3)
  {
	// The triangulation of three vertices is either a triangle (with 
	//   three bounding triangles) or two edges (with four bounding   
	//   triangles).  In either case, four triangles are created.     
	GlobalMembersTriangle.maketriangle(m, b, midtri);
	GlobalMembersTriangle.maketriangle(m, b, tri1);
	GlobalMembersTriangle.maketriangle(m, b, tri2);
	GlobalMembersTriangle.maketriangle(m, b, tri3);
	area = GlobalMembersTriangle.counterclockwise(m, b, sortarray[0], sortarray[1], sortarray[2]);
	if (area == 0.0)
	{
	  // Three collinear vertices; the triangulation is two edges. 
	  (midtri).tri[GlobalMembersTriangle.plus1mod3[(midtri).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[0];
	  (midtri).tri[GlobalMembersTriangle.minus1mod3[(midtri).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
	  (tri1).tri[GlobalMembersTriangle.plus1mod3[(tri1).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
	  (tri1).tri[GlobalMembersTriangle.minus1mod3[(tri1).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[0];
	  (tri2).tri[GlobalMembersTriangle.plus1mod3[(tri2).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[2];
	  (tri2).tri[GlobalMembersTriangle.minus1mod3[(tri2).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
	  (tri3).tri[GlobalMembersTriangle.plus1mod3[(tri3).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
	  (tri3).tri[GlobalMembersTriangle.minus1mod3[(tri3).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[2];
	  // All apices are intentionally left NULL. 
	  (midtri).tri[(midtri).orient] = (GlobalMembersTriangle.REAL)((int)(tri1).tri | (int)(tri1).orient);
	  (tri1).tri[(tri1).orient] = (GlobalMembersTriangle.REAL)((int)(midtri).tri | (int)(midtri).orient);
	  (tri2).tri[(tri2).orient] = (GlobalMembersTriangle.REAL)((int)(tri3).tri | (int)(tri3).orient);
	  (tri3).tri[(tri3).orient] = (GlobalMembersTriangle.REAL)((int)(tri2).tri | (int)(tri2).orient);
	  (midtri).orient = GlobalMembersTriangle.plus1mod3[(midtri).orient];
	  (tri1).orient = GlobalMembersTriangle.minus1mod3[(tri1).orient];
	  (tri2).orient = GlobalMembersTriangle.plus1mod3[(tri2).orient];
	  (tri3).orient = GlobalMembersTriangle.minus1mod3[(tri3).orient];
	  (midtri).tri[(midtri).orient] = (GlobalMembersTriangle.REAL)((int)(tri3).tri | (int)(tri3).orient);
	  (tri3).tri[(tri3).orient] = (GlobalMembersTriangle.REAL)((int)(midtri).tri | (int)(midtri).orient);
	  (tri1).tri[(tri1).orient] = (GlobalMembersTriangle.REAL)((int)(tri2).tri | (int)(tri2).orient);
	  (tri2).tri[(tri2).orient] = (GlobalMembersTriangle.REAL)((int)(tri1).tri | (int)(tri1).orient);
	  (midtri).orient = GlobalMembersTriangle.plus1mod3[(midtri).orient];
	  (tri1).orient = GlobalMembersTriangle.minus1mod3[(tri1).orient];
	  (tri2).orient = GlobalMembersTriangle.plus1mod3[(tri2).orient];
	  (tri3).orient = GlobalMembersTriangle.minus1mod3[(tri3).orient];
	  (midtri).tri[(midtri).orient] = (GlobalMembersTriangle.REAL)((int)(tri1).tri | (int)(tri1).orient);
	  (tri1).tri[(tri1).orient] = (GlobalMembersTriangle.REAL)((int)(midtri).tri | (int)(midtri).orient);
	  (tri2).tri[(tri2).orient] = (GlobalMembersTriangle.REAL)((int)(tri3).tri | (int)(tri3).orient);
	  (tri3).tri[(tri3).orient] = (GlobalMembersTriangle.REAL)((int)(tri2).tri | (int)(tri2).orient);
	  // Ensure that the origin of `farleft' is sortarray[0]. 
	  farleft.tri = (tri1).tri;
	  farleft.orient = (tri1).orient;
	  // Ensure that the destination of `farright' is sortarray[2]. 
	  farright.tri = (tri2).tri;
	  farright.orient = (tri2).orient;
	}
	else
	{
	  // The three vertices are not collinear; the triangulation is one 
	  //   triangle, namely `midtri'.                                   
	  (midtri).tri[GlobalMembersTriangle.plus1mod3[(midtri).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[0];
	  (tri1).tri[GlobalMembersTriangle.minus1mod3[(tri1).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[0];
	  (tri3).tri[GlobalMembersTriangle.plus1mod3[(tri3).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[0];
	  // Apices of tri1, tri2, and tri3 are left NULL. 
	  if (area > 0.0)
	  {
		// The vertices are in counterclockwise order. 
		(midtri).tri[GlobalMembersTriangle.minus1mod3[(midtri).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
		(tri1).tri[GlobalMembersTriangle.plus1mod3[(tri1).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
		(tri2).tri[GlobalMembersTriangle.minus1mod3[(tri2).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
		(midtri).tri[(midtri).orient + 3] = (GlobalMembersTriangle.REAL) sortarray[2];
		(tri2).tri[GlobalMembersTriangle.plus1mod3[(tri2).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[2];
		(tri3).tri[GlobalMembersTriangle.minus1mod3[(tri3).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[2];
	  }
	  else
	  {
		// The vertices are in clockwise order. 
		(midtri).tri[GlobalMembersTriangle.minus1mod3[(midtri).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[2];
		(tri1).tri[GlobalMembersTriangle.plus1mod3[(tri1).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[2];
		(tri2).tri[GlobalMembersTriangle.minus1mod3[(tri2).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[2];
		(midtri).tri[(midtri).orient + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
		(tri2).tri[GlobalMembersTriangle.plus1mod3[(tri2).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
		(tri3).tri[GlobalMembersTriangle.minus1mod3[(tri3).orient] + 3] = (GlobalMembersTriangle.REAL) sortarray[1];
	  }
	  // The topology does not depend on how the vertices are ordered. 
	  (midtri).tri[(midtri).orient] = (GlobalMembersTriangle.REAL)((int)(tri1).tri | (int)(tri1).orient);
	  (tri1).tri[(tri1).orient] = (GlobalMembersTriangle.REAL)((int)(midtri).tri | (int)(midtri).orient);
	  (midtri).orient = GlobalMembersTriangle.plus1mod3[(midtri).orient];
	  (midtri).tri[(midtri).orient] = (GlobalMembersTriangle.REAL)((int)(tri2).tri | (int)(tri2).orient);
	  (tri2).tri[(tri2).orient] = (GlobalMembersTriangle.REAL)((int)(midtri).tri | (int)(midtri).orient);
	  (midtri).orient = GlobalMembersTriangle.plus1mod3[(midtri).orient];
	  (midtri).tri[(midtri).orient] = (GlobalMembersTriangle.REAL)((int)(tri3).tri | (int)(tri3).orient);
	  (tri3).tri[(tri3).orient] = (GlobalMembersTriangle.REAL)((int)(midtri).tri | (int)(midtri).orient);
	  (tri1).orient = GlobalMembersTriangle.minus1mod3[(tri1).orient];
	  (tri2).orient = GlobalMembersTriangle.plus1mod3[(tri2).orient];
	  (tri1).tri[(tri1).orient] = (GlobalMembersTriangle.REAL)((int)(tri2).tri | (int)(tri2).orient);
	  (tri2).tri[(tri2).orient] = (GlobalMembersTriangle.REAL)((int)(tri1).tri | (int)(tri1).orient);
	  (tri1).orient = GlobalMembersTriangle.minus1mod3[(tri1).orient];
	  (tri3).orient = GlobalMembersTriangle.minus1mod3[(tri3).orient];
	  (tri1).tri[(tri1).orient] = (GlobalMembersTriangle.REAL)((int)(tri3).tri | (int)(tri3).orient);
	  (tri3).tri[(tri3).orient] = (GlobalMembersTriangle.REAL)((int)(tri1).tri | (int)(tri1).orient);
	  (tri2).orient = GlobalMembersTriangle.plus1mod3[(tri2).orient];
	  (tri3).orient = GlobalMembersTriangle.minus1mod3[(tri3).orient];
	  (tri2).tri[(tri2).orient] = (GlobalMembersTriangle.REAL)((int)(tri3).tri | (int)(tri3).orient);
	  (tri3).tri[(tri3).orient] = (GlobalMembersTriangle.REAL)((int)(tri2).tri | (int)(tri2).orient);
	  // Ensure that the origin of `farleft' is sortarray[0]. 
	  farleft.tri = (tri1).tri;
	  farleft.orient = (tri1).orient;
	  // Ensure that the destination of `farright' is sortarray[2]. 
	  if (area > 0.0)
	  {
		farright.tri = (tri2).tri;
		farright.orient = (tri2).orient;
	  }
	  else
	  {
		farright.tri = farleft.tri;
		farright.orient = GlobalMembersTriangle.plus1mod3[farleft.orient];
	  }
	}
	if (b.verbose > 2)
	{
	  System.out.print("  Creating ");
	  GlobalMembersTriangle.printtriangle(m, b, midtri);
	  System.out.print("  Creating ");
	  GlobalMembersTriangle.printtriangle(m, b, tri1);
	  System.out.print("  Creating ");
	  GlobalMembersTriangle.printtriangle(m, b, tri2);
	  System.out.print("  Creating ");
	  GlobalMembersTriangle.printtriangle(m, b, tri3);
	}
	return;
	}
  else
  {
	// Split the vertices in half. 
	divider = vertices >> 1;
	// Recursively triangulate each half. 
	GlobalMembersTriangle.divconqrecurse(m, b, sortarray, divider, 1 - axis, farleft, innerleft);
	GlobalMembersTriangle.divconqrecurse(m, b, sortarray[divider], vertices - divider, 1 - axis, innerright, farright);
	if (b.verbose > 1)
	{
	  System.out.printf("  Joining triangulations with %d and %d vertices.\n", divider, vertices - divider);
	}
	// Merge the two triangulations into one. 
	GlobalMembersTriangle.mergehulls(m, b, farleft, innerleft, innerright, farright, axis);
  }
}

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int GlobalMembersTriangle.removeghosts(struct mesh m, struct behavior b, struct otri *startghost)
//#else
int GlobalMembersTriangle.removeghosts(m, b, startghost)
mesh m;
behavior b;
otri startghost;
//#endif // not ANSI_DECLARATORS

{
  otri searchedge = new otri();
  otri dissolveedge = new otri();
  otri deadtriangle = new otri();
  GlobalMembersTriangle.REAL markorg;
  int hullsize;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().

  if (b.verbose != 0)
  {
	System.out.print("  Removing ghost triangles.\n");
  }
  // Find an edge on the convex hull to start point location from. 
  (searchedge).tri = startghost.tri;
  (searchedge).orient = GlobalMembersTriangle.minus1mod3[startghost.orient];
  ptr = (searchedge).tri[(searchedge).orient];
  (searchedge).orient = (int)((int)(ptr) & (int) 3l);
  (searchedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(searchedge).orient);
  ;
  m.dummytri[0] = (GlobalMembersTriangle.REAL)((int)(searchedge).tri | (int)(searchedge).orient);
  // Remove the bounding box and count the convex hull edges. 
  (dissolveedge).tri = startghost.tri;
  (dissolveedge).orient = startghost.orient;
  hullsize = 0;
  do
  {
	hullsize++;
	(deadtriangle).tri = (dissolveedge).tri;
	(deadtriangle).orient = GlobalMembersTriangle.plus1mod3[(dissolveedge).orient];
	(dissolveedge).orient = GlobalMembersTriangle.minus1mod3[(dissolveedge).orient];
	ptr = (dissolveedge).tri[(dissolveedge).orient];
	(dissolveedge).orient = (int)((int)(ptr) & (int) 3l);
	(dissolveedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(dissolveedge).orient);
	;
	// If no PSLG is involved, set the boundary markers of all the vertices 
	//   on the convex hull.  If a PSLG is used, this step is done later.   
	if (b.poly == 0)
	{
	  // Watch out for the case where all the input vertices are collinear. 
	  if (dissolveedge.tri != m.dummytri)
	  {
		markorg = (GlobalMembersTriangle.REAL)(dissolveedge).tri[GlobalMembersTriangle.plus1mod3[(dissolveedge).orient] + 3];
		if (((int)(markorg))[m.vertexmarkindex] == 0)
		{
		  ((int)(markorg))[m.vertexmarkindex] = 1;
		}
	  }
	}
	// Remove a bounding triangle from a convex hull triangle. 
	(dissolveedge).tri[(dissolveedge).orient] = (GlobalMembersTriangle.REAL) m.dummytri;
	// Find the next bounding triangle. 
	ptr = (deadtriangle).tri[(deadtriangle).orient];
	(dissolveedge).orient = (int)((int)(ptr) & (int) 3l);
	(dissolveedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(dissolveedge).orient);
	;
	// Delete the bounding triangle. 
	GlobalMembersTriangle.triangledealloc(m, deadtriangle.tri);
  } while (!(((dissolveedge).tri == startghost.tri) && ((dissolveedge).orient == startghost.orient)));
  return hullsize;
}

//***************************************************************************
//                                                                           
//  divconqdelaunay()   Form a Delaunay triangulation by the divide-and-     
//                      conquer method.                                      
//                                                                           
//  Sorts the vertices, calls a recursive procedure to triangulate them, and 
//  removes the bounding box, setting boundary markers as appropriate.       
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int GlobalMembersTriangle.divconqdelaunay(struct mesh m, struct behavior b)
//#else
int GlobalMembersTriangle.divconqdelaunay(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  GlobalMembersTriangle.REAL * *sortarray;
  otri hullleft = new otri();
  otri hullright = new otri();
  int divider;
  int i;
  int j;

  if (b.verbose != 0)
  {
	System.out.print("  Sorting vertices.\n");
  }

  // Allocate an array of pointers to vertices for sorting. 
  sortarray = (GlobalMembersTriangle.REAL * *) GlobalMembersTriangle.trimalloc(m.invertices * (int) sizeof(GlobalMembersTriangle.REAL));
  GlobalMembersTriangle.traversalinit(m.vertices);
  for (i = 0; i < m.invertices; i++)
  {
	sortarray[i] = GlobalMembersTriangle.vertextraverse(m);
  }
  // Sort the vertices. 
  GlobalMembersTriangle.vertexsort(sortarray, m.invertices);
  // Discard duplicate vertices, which can really mess up the algorithm. 
  i = 0;
  for (j = 1; j < m.invertices; j++)
  {
	if ((sortarray[i][0] == sortarray[j][0]) && (sortarray[i][1] == sortarray[j][1]))
	{
	  if (b.quiet == 0)
	  {
		System.out.printf("Warning:  A duplicate vertex at (%.12g, %.12g) appeared and was ignored.\n", sortarray[j][0], sortarray[j][1]);
	  }
	  ((int)(sortarray[j]))[m.vertexmarkindex + 1] = -32767;
	  m.undeads++;
	  }
	else
	{
	  i++;
	  sortarray[i] = sortarray[j];
	}
  }
  i++;
  if (b.dwyer != 0)
  {
	// Re-sort the array of vertices to accommodate alternating cuts. 
	divider = i >> 1;
	if (i - divider >= 2)
	{
	  if (divider >= 2)
	  {
		GlobalMembersTriangle.alternateaxes(sortarray, divider, 1);
	  }
	  GlobalMembersTriangle.alternateaxes(sortarray[divider], i - divider, 1);
	}
  }

  if (b.verbose != 0)
  {
	System.out.print("  Forming triangulation.\n");
  }

  // Form the Delaunay triangulation. 
  GlobalMembersTriangle.divconqrecurse(m, b, sortarray, i, 0, hullleft, hullright);
  GlobalMembersTriangle.trifree((int) sortarray);

  return GlobalMembersTriangle.removeghosts(m, b, hullleft);
}

//*                                                                         *
//*                                                                         *
//******** Divide-and-conquer Delaunay triangulation ends here       ********

//******** Incremental Delaunay triangulation begins here            ********
//*                                                                         *
//*                                                                         *

//***************************************************************************
//                                                                           
//  boundingbox()   Form an "infinite" bounding triangle to insert vertices  
//                  into.                                                    
//                                                                           
//  The vertices at "infinity" are assigned finite coordinates, which are    
//  used by the point location routines, but (mostly) ignored by the         
//  Delaunay edge flip routines.                                             
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.boundingbox(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.boundingbox(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri inftri = new otri(); // Handle for the triangular bounding box.
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL width;

  if (b.verbose != 0)
  {
	System.out.print("  Creating triangular bounding box.\n");
  }
  // Find the width (or height, whichever is larger) of the triangulation. 
  width = m.xmax - m.xmin;
  if (m.ymax - m.ymin > width)
  {
	width = m.ymax - m.ymin;
  }
  if (width == 0.0)
  {
	width = 1.0;
  }
  // Create the vertices of the bounding box. 
  m.infvertex1 = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.trimalloc(m.vertices.itembytes);
  m.infvertex2 = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.trimalloc(m.vertices.itembytes);
  m.infvertex3 = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.trimalloc(m.vertices.itembytes);
  m.infvertex1[0] = m.xmin - 50.0 * width;
  m.infvertex1[1] = m.ymin - 40.0 * width;
  m.infvertex2[0] = m.xmax + 50.0 * width;
  m.infvertex2[1] = m.ymin - 40.0 * width;
  m.infvertex3[0] = 0.5 * (m.xmin + m.xmax);
  m.infvertex3[1] = m.ymax + 60.0 * width;

  // Create the bounding box. 
  GlobalMembersTriangle.maketriangle(m, b, inftri);
  (inftri).tri[GlobalMembersTriangle.plus1mod3[(inftri).orient] + 3] = (GlobalMembersTriangle.REAL) m.infvertex1;
  (inftri).tri[GlobalMembersTriangle.minus1mod3[(inftri).orient] + 3] = (GlobalMembersTriangle.REAL) m.infvertex2;
  (inftri).tri[(inftri).orient + 3] = (GlobalMembersTriangle.REAL) m.infvertex3;
  // Link dummytri to the bounding box so we can always find an 
  //   edge to begin searching (point location) from.           
  m.dummytri[0] = (GlobalMembersTriangle.REAL) inftri.tri;
  if (b.verbose > 2)
  {
	System.out.print("  Creating ");
	GlobalMembersTriangle.printtriangle(m, b, inftri);
  }
}

//#endif // not REDUCED

//***************************************************************************
//                                                                           
//  removebox()   Remove the "infinite" bounding triangle, setting boundary  
//                markers as appropriate.                                    
//                                                                           
//  The triangular bounding box has three boundary triangles (one for each   
//  side of the bounding box), and a bunch of triangles fanning out from     
//  the three bounding box vertices (one triangle for each edge of the       
//  convex hull of the inner mesh).  This routine removes these triangles.   
//                                                                           
//  Returns the number of edges on the convex hull of the triangulation.     
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int GlobalMembersTriangle.removebox(struct mesh m, struct behavior b)
//#else
int GlobalMembersTriangle.removebox(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri deadtriangle = new otri();
  otri searchedge = new otri();
  otri checkedge = new otri();
  otri nextedge = new otri();
  otri finaledge = new otri();
  otri dissolveedge = new otri();
  GlobalMembersTriangle.REAL markorg;
  int hullsize;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().

  if (b.verbose != 0)
  {
	System.out.print("  Removing triangular bounding box.\n");
  }
  // Find a boundary triangle. 
  nextedge.tri = m.dummytri;
  nextedge.orient = 0;
  ptr = (nextedge).tri[(nextedge).orient];
  (nextedge).orient = (int)((int)(ptr) & (int) 3l);
  (nextedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(nextedge).orient);
  ;
  // Mark a place to stop. 
  (finaledge).tri = (nextedge).tri;
  (finaledge).orient = GlobalMembersTriangle.minus1mod3[(nextedge).orient];
  (nextedge).orient = GlobalMembersTriangle.plus1mod3[(nextedge).orient];
  ptr = (nextedge).tri[(nextedge).orient];
  (nextedge).orient = (int)((int)(ptr) & (int) 3l);
  (nextedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(nextedge).orient);
  ;
  // Find a triangle (on the boundary of the vertex set) that isn't 
  //   a bounding box triangle.                                     
  (searchedge).tri = (nextedge).tri;
  (searchedge).orient = GlobalMembersTriangle.minus1mod3[(nextedge).orient];
  ptr = (searchedge).tri[(searchedge).orient];
  (searchedge).orient = (int)((int)(ptr) & (int) 3l);
  (searchedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(searchedge).orient);
  ;
  // Check whether nextedge is another boundary triangle 
  //   adjacent to the first one.                        
  (checkedge).tri = (nextedge).tri;
  (checkedge).orient = GlobalMembersTriangle.plus1mod3[(nextedge).orient];
  ptr = (checkedge).tri[(checkedge).orient];
  (checkedge).orient = (int)((int)(ptr) & (int) 3l);
  (checkedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(checkedge).orient);
  ;
  if (checkedge.tri == m.dummytri)
  {
	// Go on to the next triangle.  There are only three boundary   
	//   triangles, and this next triangle cannot be the third one, 
	//   so it's safe to stop here.                                 
	(searchedge).orient = GlobalMembersTriangle.minus1mod3[(searchedge).orient];
	ptr = (searchedge).tri[(searchedge).orient];
	(searchedge).orient = (int)((int)(ptr) & (int) 3l);
	(searchedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(searchedge).orient);
	;
  }
  // Find a new boundary edge to search from, as the current search 
  //   edge lies on a bounding box triangle and will be deleted.    
  m.dummytri[0] = (GlobalMembersTriangle.REAL)((int)(searchedge).tri | (int)(searchedge).orient);
  hullsize = -2l;
  while (!(((nextedge).tri == (finaledge).tri) && ((nextedge).orient == (finaledge).orient)))
  {
	hullsize++;
	(dissolveedge).tri = (nextedge).tri;
	(dissolveedge).orient = GlobalMembersTriangle.minus1mod3[(nextedge).orient];
	ptr = (dissolveedge).tri[(dissolveedge).orient];
	(dissolveedge).orient = (int)((int)(ptr) & (int) 3l);
	(dissolveedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(dissolveedge).orient);
	;
	// If not using a PSLG, the vertices should be marked now. 
	//   (If using a PSLG, markhull() will do the job.)        
	if (b.poly == 0)
	{
	  // Be careful!  One must check for the case where all the input     
	  //   vertices are collinear, and thus all the triangles are part of 
	  //   the bounding box.  Otherwise, the setvertexmark() call below   
	  //   will cause a bad pointer reference.                            
	  if (dissolveedge.tri != m.dummytri)
	  {
		markorg = (GlobalMembersTriangle.REAL)(dissolveedge).tri[GlobalMembersTriangle.plus1mod3[(dissolveedge).orient] + 3];
		if (((int)(markorg))[m.vertexmarkindex] == 0)
		{
		  ((int)(markorg))[m.vertexmarkindex] = 1;
		}
	  }
	}
	// Disconnect the bounding box triangle from the mesh triangle. 
	(dissolveedge).tri[(dissolveedge).orient] = (GlobalMembersTriangle.REAL) m.dummytri;
	(deadtriangle).tri = (nextedge).tri;
	(deadtriangle).orient = GlobalMembersTriangle.plus1mod3[(nextedge).orient];
	ptr = (deadtriangle).tri[(deadtriangle).orient];
	(nextedge).orient = (int)((int)(ptr) & (int) 3l);
	(nextedge).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(nextedge).orient);
	;
	// Get rid of the bounding box triangle. 
	GlobalMembersTriangle.triangledealloc(m, deadtriangle.tri);
	// Do we need to turn the corner? 
	if (nextedge.tri == m.dummytri)
	{
	  // Turn the corner. 
	  (nextedge).tri = (dissolveedge).tri;
	  (nextedge).orient = (dissolveedge).orient;
	}
  }
  GlobalMembersTriangle.triangledealloc(m, finaledge.tri);

  GlobalMembersTriangle.trifree((int) m.infvertex1); // Deallocate the bounding box vertices.
  GlobalMembersTriangle.trifree((int) m.infvertex2);
  GlobalMembersTriangle.trifree((int) m.infvertex3);

  return hullsize;
}

//#endif // not REDUCED

//***************************************************************************
//                                                                           
//  incrementaldelaunay()   Form a Delaunay triangulation by incrementally   
//                          inserting vertices.                              
//                                                                           
//  Returns the number of edges on the convex hull of the triangulation.     
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int GlobalMembersTriangle.incrementaldelaunay(struct mesh m, struct behavior b)
//#else
int GlobalMembersTriangle.incrementaldelaunay(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri starttri = new otri();
  GlobalMembersTriangle.REAL vertexloop;

  // Create a triangular bounding box. 
  GlobalMembersTriangle.boundingbox(m, b);
  if (b.verbose != 0)
  {
	System.out.print("  Incrementally inserting vertices.\n");
  }
  GlobalMembersTriangle.traversalinit(m.vertices);
  vertexloop = GlobalMembersTriangle.vertextraverse(m);
  while (vertexloop != (GlobalMembersTriangle.REAL) null)
  {
	starttri.tri = m.dummytri;
	if (GlobalMembersTriangle.insertvertex(m, b, vertexloop, starttri, (osub) null, 0, 0) == insertvertexresult.DUPLICATEVERTEX)
	{
	  if (b.quiet == 0)
	  {
		System.out.printf("Warning:  A duplicate vertex at (%.12g, %.12g) appeared and was ignored.\n", vertexloop[0], vertexloop[1]);
	  }
	  ((int)(vertexloop))[m.vertexmarkindex + 1] = -32767;
	  m.undeads++;
	}
	vertexloop = GlobalMembersTriangle.vertextraverse(m);
  }
  // Remove the bounding box. 
  return GlobalMembersTriangle.removebox(m, b);
}

//#endif // not REDUCED

//*                                                                         *
//*                                                                         *
//******** Incremental Delaunay triangulation ends here              ********

//******** Sweepline Delaunay triangulation begins here              ********
//*                                                                         *
//*                                                                         *


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void eventheapinsert(struct event **heap, int heapsize, struct event *newevent)
//#else
void eventheapinsert(heap, heapsize, newevent)
event[] heap;
int heapsize;
event newevent;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL eventx;
  GlobalMembersTriangle.REAL eventy;
  int eventnum;
  int parent;
  int notdone;

  eventx = newevent.xkey;
  eventy = newevent.ykey;
  eventnum = heapsize;
  notdone = eventnum > 0;
  while (notdone != 0)
  {
	parent = (eventnum - 1) >> 1;
	if ((heap[parent].ykey < eventy) || ((heap[parent].ykey == eventy) && (heap[parent].xkey <= eventx)))
	{
	  notdone = 0;
	}
	else
	{
	  heap[eventnum] = heap[parent];
	  heap[eventnum].heapposition = eventnum;

	  eventnum = parent;
	  notdone = eventnum > 0;
	}
  }
  heap[eventnum] = newevent;
  newevent.heapposition = eventnum;
}

//#endif // not REDUCED


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void eventheapify(struct event **heap, int heapsize, int eventnum)
//#else
void eventheapify(heap, heapsize, eventnum)
event[] heap;
int heapsize;
int eventnum;
//#endif // not ANSI_DECLARATORS

{
  event thisevent;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL eventx;
  GlobalMembersTriangle.REAL eventy;
  int leftchild;
  int rightchild;
  int smallest;
  int notdone;

  thisevent = heap[eventnum];
  eventx = thisevent.xkey;
  eventy = thisevent.ykey;
  leftchild = 2 * eventnum + 1;
  notdone = leftchild < heapsize;
  while (notdone != 0)
  {
	if ((heap[leftchild].ykey < eventy) || ((heap[leftchild].ykey == eventy) && (heap[leftchild].xkey < eventx)))
	{
	  smallest = leftchild;
	}
	else
	{
	  smallest = eventnum;
	}
	rightchild = leftchild + 1;
	if (rightchild < heapsize)
	{
	  if ((heap[rightchild].ykey < heap[smallest].ykey) || ((heap[rightchild].ykey == heap[smallest].ykey) && (heap[rightchild].xkey < heap[smallest].xkey)))
	  {
		smallest = rightchild;
	  }
	}
	if (smallest == eventnum)
	{
	  notdone = 0;
	}
	else
	{
	  heap[eventnum] = heap[smallest];
	  heap[eventnum].heapposition = eventnum;
	  heap[smallest] = thisevent;
	  thisevent.heapposition = smallest;

	  eventnum = smallest;
	  leftchild = 2 * eventnum + 1;
	  notdone = leftchild < heapsize;
	}
  }
}

//#endif // not REDUCED


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void eventheapdelete(struct event **heap, int heapsize, int eventnum)
//#else
void eventheapdelete(heap, heapsize, eventnum)
event[] heap;
int heapsize;
int eventnum;
//#endif // not ANSI_DECLARATORS

{
  event moveevent;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL eventx;
  GlobalMembersTriangle.REAL eventy;
  int parent;
  int notdone;

  moveevent = heap[heapsize - 1];
  if (eventnum > 0)
  {
	eventx = moveevent.xkey;
	eventy = moveevent.ykey;
	do
	{
	  parent = (eventnum - 1) >> 1;
	  if ((heap[parent].ykey < eventy) || ((heap[parent].ykey == eventy) && (heap[parent].xkey <= eventx)))
	  {
		notdone = 0;
	  }
	  else
	  {
		heap[eventnum] = heap[parent];
		heap[eventnum].heapposition = eventnum;

		eventnum = parent;
		notdone = eventnum > 0;
	  }
	} while (notdone);
  }
  heap[eventnum] = moveevent;
  moveevent.heapposition = eventnum;
  eventheapify(heap, heapsize - 1, eventnum);
}

//#endif // not REDUCED


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void createeventheap(struct mesh m, struct event ***eventheap, struct event **events, struct event **freeevents)
//#else
void createeventheap(m, eventheap, events, freeevents)
mesh m;
event[][] eventheap;
event[] events;
event[] freeevents;
//#endif // not ANSI_DECLARATORS

{
  GlobalMembersTriangle.REAL thisvertex;
  int maxevents;
  int i;

  maxevents = (3 m.invertices) / 2;
  *eventheap = (event) GlobalMembersTriangle.trimalloc(maxevents * (int) sizeof(event));
  *events = (event) GlobalMembersTriangle.trimalloc(maxevents * (int) sizeof(event));
  GlobalMembersTriangle.traversalinit(m.vertices);
  for (i = 0; i < m.invertices; i++)
  {
	thisvertex = GlobalMembersTriangle.vertextraverse(m);
	(*events)[i].eventptr = (int) thisvertex;
	(*events)[i].xkey = thisvertex[0];
	(*events)[i].ykey = thisvertex[1];
	eventheapinsert(*eventheap, i, *events + i);
  }
  *freeevents = (event) null;
  for (i = maxevents - 1; i >= m.invertices; i--)
  {
	(*events)[i].eventptr = (int) *freeevents;
	*freeevents = *events + i;
  }
}

//#endif // not REDUCED


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int GlobalMembersTriangle.rightofhyperbola(struct mesh m, struct otri *fronttri, GlobalMembersTriangle.REAL * newsite)
//#else
int GlobalMembersTriangle.rightofhyperbola(m, fronttri, newsite)
mesh m;
otri fronttri;
GlobalMembersTriangle.REAL newsite;
//#endif // not ANSI_DECLARATORS

{
  GlobalMembersTriangle.REAL leftvertex;
  GlobalMembersTriangle.REAL rightvertex;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL dxa;
  GlobalMembersTriangle.REAL dya;
  GlobalMembersTriangle.REAL dxb;
  GlobalMembersTriangle.REAL dyb;

  m.hyperbolacount++;

  leftvertex = (GlobalMembersTriangle.REAL) fronttri.tri[GlobalMembersTriangle.minus1mod3[fronttri.orient] + 3];
  rightvertex = (GlobalMembersTriangle.REAL) fronttri.tri[fronttri.orient + 3];
  if ((leftvertex[1] < rightvertex[1]) || ((leftvertex[1] == rightvertex[1]) && (leftvertex[0] < rightvertex[0])))
  {
	if (newsite[0] >= rightvertex[0])
	{
	  return 1;
	}
	}
  else
  {
	if (newsite[0] <= leftvertex[0])
	{
	  return 0;
	}
  }
  dxa = leftvertex[0] - newsite[0];
  dya = leftvertex[1] - newsite[1];
  dxb = rightvertex[0] - newsite[0];
  dyb = rightvertex[1] - newsite[1];
  return dya * (dxb * dxb + dyb * dyb) > dyb * (dxa * dxa + dya * dya);
}

//#endif // not REDUCED


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.circletop(struct mesh m, GlobalMembersTriangle.REAL pa, GlobalMembersTriangle.REAL pb, GlobalMembersTriangle.REAL pc, GlobalMembersTriangle.REAL ccwabc)
//#else
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL GlobalMembersTriangle.circletop(m, pa, pb, pc, ccwabc)
mesh m;
GlobalMembersTriangle.REAL pa;
GlobalMembersTriangle.REAL pb;
GlobalMembersTriangle.REAL pc;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL ccwabc;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL xac;
  GlobalMembersTriangle.REAL yac;
  GlobalMembersTriangle.REAL xbc;
  GlobalMembersTriangle.REAL ybc;
  GlobalMembersTriangle.REAL xab;
  GlobalMembersTriangle.REAL yab;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL aclen2;
  GlobalMembersTriangle.REAL bclen2;
  GlobalMembersTriangle.REAL ablen2;

  m.circletopcount++;

  xac = pa[0] - pc[0];
  yac = pa[1] - pc[1];
  xbc = pb[0] - pc[0];
  ybc = pb[1] - pc[1];
  xab = pa[0] - pb[0];
  yab = pa[1] - pb[1];
  aclen2 = xac * xac + yac * yac;
  bclen2 = xbc * xbc + ybc * ybc;
  ablen2 = xab * xab + yab * yab;
  return pc[1] + (xac * bclen2 - xbc * aclen2 + Math.sqrt(aclen2 * bclen2 * ablen2)) / (2.0 * ccwabc);
}

//#endif // not REDUCED


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void check4deadevent(struct otri *checktri, struct event **freeevents, struct event **eventheap, int *heapsize)
//#else
void check4deadevent(checktri, freeevents, eventheap, heapsize)
otri checktri;
event[] freeevents;
event[] eventheap;
int heapsize;
//#endif // not ANSI_DECLARATORS

{
  event deadevent;
  GlobalMembersTriangle.REAL eventvertex;
  int eventnum;

  eventvertex = (GlobalMembersTriangle.REAL) checktri.tri[GlobalMembersTriangle.plus1mod3[checktri.orient] + 3];
  if (eventvertex != (GlobalMembersTriangle.REAL) null)
  {
	deadevent = (event) eventvertex;
	eventnum = deadevent.heapposition;
	deadevent.eventptr = (int) *freeevents;
	*freeevents = deadevent;
	eventheapdelete(eventheap, heapsize, eventnum);
	( heapsize)--;
	checktri.tri[GlobalMembersTriangle.plus1mod3[checktri.orient] + 3] = (GlobalMembersTriangle.REAL) null;
  }
}

//#endif // not REDUCED


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
struct splaynode *GlobalMembersTriangle.splay(struct mesh m, struct splaynode *splaytree, GlobalMembersTriangle.REAL searchpoint, struct otri searchtri)
//#else
struct splaynode *GlobalMembersTriangle.splay(m, splaytree, searchpoint, searchtri)
mesh m;
splaynode splaytree;
GlobalMembersTriangle.REAL searchpoint;
otri searchtri;
//#endif // not ANSI_DECLARATORS

{
  splaynode child;
  splaynode grandchild;
  splaynode lefttree;
  splaynode righttree;
  splaynode leftright;
  GlobalMembersTriangle.REAL checkvertex;
  int rightofroot;
  int rightofchild;

  if (splaytree == (splaynode) null)
  {
	return (splaynode) null;
  }
  checkvertex = (GlobalMembersTriangle.REAL)(splaytree.keyedge).tri[GlobalMembersTriangle.minus1mod3[(splaytree.keyedge).orient] + 3];
  if (checkvertex == splaytree.keydest)
  {
	rightofroot = GlobalMembersTriangle.rightofhyperbola(m, splaytree.keyedge, searchpoint);
	if (rightofroot != 0)
	{
	  searchtri.tri = (splaytree.keyedge).tri;
	  searchtri.orient = (splaytree.keyedge).orient;
	  child = splaytree.rchild;
	}
	else
	{
	  child = splaytree.lchild;
	}
	if (child == (splaynode) null)
	{
	  return splaytree;
	}
	checkvertex = (GlobalMembersTriangle.REAL)(child.keyedge).tri[GlobalMembersTriangle.minus1mod3[(child.keyedge).orient] + 3];
	if (checkvertex != child.keydest)
	{
	  child = GlobalMembersTriangle.splay(m, child, searchpoint, searchtri);
	  if (child == (splaynode) null)
	  {
		if (rightofroot != 0)
		{
		  splaytree.rchild = (splaynode) null;
		}
		else
		{
		  splaytree.lchild = (splaynode) null;
		}
		return splaytree;
	  }
	}
	rightofchild = GlobalMembersTriangle.rightofhyperbola(m, child.keyedge, searchpoint);
	if (rightofchild != 0)
	{
	  searchtri.tri = (child.keyedge).tri;
	  searchtri.orient = (child.keyedge).orient;
	  grandchild = GlobalMembersTriangle.splay(m, child.rchild, searchpoint, searchtri);
	  child.rchild = grandchild;
	}
	else
	{
	  grandchild = GlobalMembersTriangle.splay(m, child.lchild, searchpoint, searchtri);
	  child.lchild = grandchild;
	}
	if (grandchild == (splaynode) null)
	{
	  if (rightofroot != 0)
	  {
		splaytree.rchild = child.lchild;
		child.lchild = splaytree;
	  }
	  else
	  {
		splaytree.lchild = child.rchild;
		child.rchild = splaytree;
	  }
	  return child;
	}
	if (rightofchild != 0)
	{
	  if (rightofroot != 0)
	  {
		splaytree.rchild = child.lchild;
		child.lchild = splaytree;
	  }
	  else
	  {
		splaytree.lchild = grandchild.rchild;
		grandchild.rchild = splaytree;
	  }
	  child.rchild = grandchild.lchild;
	  grandchild.lchild = child;
	  }
	else
	{
	  if (rightofroot != 0)
	  {
		splaytree.rchild = grandchild.lchild;
		grandchild.lchild = splaytree;
	  }
	  else
	  {
		splaytree.lchild = child.rchild;
		child.rchild = splaytree;
	  }
	  child.lchild = grandchild.rchild;
	  grandchild.rchild = child;
	}
	return grandchild;
	  }
  else
  {
	lefttree = GlobalMembersTriangle.splay(m, splaytree.lchild, searchpoint, searchtri);
	righttree = GlobalMembersTriangle.splay(m, splaytree.rchild, searchpoint, searchtri);

	GlobalMembersTriangle.pooldealloc(m.splaynodes, (int) splaytree);
	if (lefttree == (splaynode) null)
	{
	  return righttree;
	}
	else if (righttree == (splaynode) null)
	{
	  return lefttree;
	}
	else if (lefttree.rchild == (splaynode) null)
	{
	  lefttree.rchild = righttree.lchild;
	  righttree.lchild = lefttree;
	  return righttree;
	}
	else if (righttree.lchild == (splaynode) null)
	{
	  righttree.lchild = lefttree.rchild;
	  lefttree.rchild = righttree;
	  return lefttree;
	}
	else
	{
//      printf("Holy Toledo!!!\n"); 
	  leftright = lefttree.rchild;
	  while (leftright.rchild != (splaynode) null)
	  {
		leftright = leftright.rchild;
	  }
	  leftright.rchild = righttree;
	  return lefttree;
	}
  }
}

//#endif // not REDUCED


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
struct splaynode *GlobalMembersTriangle.splayinsert(struct mesh m, struct splaynode *splayroot, struct otri *newkey, GlobalMembersTriangle.REAL searchpoint)
//#else
struct splaynode *GlobalMembersTriangle.splayinsert(m, splayroot, newkey, searchpoint)
mesh m;
splaynode splayroot;
otri newkey;
GlobalMembersTriangle.REAL searchpoint;
//#endif // not ANSI_DECLARATORS

{
  splaynode newsplaynode;

  newsplaynode = (splaynode) GlobalMembersTriangle.poolalloc(m.splaynodes);
  (newsplaynode.keyedge).tri = newkey.tri;
  (newsplaynode.keyedge).orient = newkey.orient;
  newsplaynode.keydest = (GlobalMembersTriangle.REAL) newkey.tri[GlobalMembersTriangle.minus1mod3[newkey.orient] + 3];
  if (splayroot == (splaynode) null)
  {
	newsplaynode.lchild = (splaynode) null;
	newsplaynode.rchild = (splaynode) null;
  }
  else if (GlobalMembersTriangle.rightofhyperbola(m, splayroot.keyedge, searchpoint))
  {
	newsplaynode.lchild = splayroot;
	newsplaynode.rchild = splayroot.rchild;
	splayroot.rchild = (splaynode) null;
  }
  else
  {
	newsplaynode.lchild = splayroot.lchild;
	newsplaynode.rchild = splayroot;
	splayroot.lchild = (splaynode) null;
  }
  return newsplaynode;
}

//#endif // not REDUCED


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
struct splaynode *GlobalMembersTriangle.circletopinsert(struct mesh m, struct behavior b, struct splaynode splayroot, struct otri newkey, GlobalMembersTriangle.REAL pa, GlobalMembersTriangle.REAL pb, GlobalMembersTriangle.REAL pc, GlobalMembersTriangle.REAL topy)
//#else
struct splaynode *GlobalMembersTriangle.circletopinsert(m, b, splayroot, newkey, pa, pb, pc, topy)
mesh m;
behavior b;
splaynode splayroot;
otri newkey;
GlobalMembersTriangle.REAL pa;
GlobalMembersTriangle.REAL pb;
GlobalMembersTriangle.REAL pc;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL topy;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL ccwabc;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL xac;
  GlobalMembersTriangle.REAL yac;
  GlobalMembersTriangle.REAL xbc;
  GlobalMembersTriangle.REAL ybc;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL aclen2;
  GlobalMembersTriangle.REAL bclen2;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] searchpoint = new GlobalMembersTriangle.REAL[2];
  otri dummytri = new otri();

  ccwabc = GlobalMembersTriangle.counterclockwise(m, b, pa, pb, pc);
  xac = pa[0] - pc[0];
  yac = pa[1] - pc[1];
  xbc = pb[0] - pc[0];
  ybc = pb[1] - pc[1];
  aclen2 = xac * xac + yac * yac;
  bclen2 = xbc * xbc + ybc * ybc;
  searchpoint[0] = pc[0] - (yac * bclen2 - ybc * aclen2) / (2.0 * ccwabc);
  searchpoint[1] = topy;
  return GlobalMembersTriangle.splayinsert(m, GlobalMembersTriangle.splay(m, splayroot, (GlobalMembersTriangle.REAL) searchpoint, dummytri), newkey, (GlobalMembersTriangle.REAL) searchpoint);
}

//#endif // not REDUCED


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
struct splaynode *GlobalMembersTriangle.frontlocate(struct mesh m, struct splaynode splayroot, struct otri *bottommost, GlobalMembersTriangle.REAL * searchvertex, struct otri searchtri, int farright)
//#else
struct splaynode *GlobalMembersTriangle.frontlocate(m, splayroot, bottommost, searchvertex, searchtri, farright)
mesh m;
splaynode splayroot;
otri bottommost;
GlobalMembersTriangle.REAL searchvertex;
otri searchtri;
int farright;
//#endif // not ANSI_DECLARATORS

{
  int farrightflag;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by onext().

  searchtri.tri = bottommost.tri;
  searchtri.orient = bottommost.orient;
  splayroot = GlobalMembersTriangle.splay(m, splayroot, searchvertex, searchtri);

  farrightflag = 0;
  while (farrightflag == 0 && GlobalMembersTriangle.rightofhyperbola(m, searchtri, searchvertex))
  {
	searchtri.orient = GlobalMembersTriangle.minus1mod3[searchtri.orient];
	ptr = searchtri.tri[searchtri.orient];
	searchtri.orient = (int)((int)(ptr) & (int) 3l);
	searchtri.tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int) searchtri.orient);
	;
	;
	farrightflag = ((searchtri.tri == bottommost.tri) && (searchtri.orient == bottommost.orient));
  }
  farright = farrightflag;
  return splayroot;
}

//#endif // not REDUCED


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int GlobalMembersTriangle.sweeplinedelaunay(struct mesh m, struct behavior b)
//#else
int GlobalMembersTriangle.sweeplinedelaunay(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  event[] eventheap;
  event events;
  event freeevents;
  event nextevent;
  event newevent;
  splaynode splayroot;
  otri bottommost = new otri();
  otri searchtri = new otri();
  otri fliptri = new otri();
  otri lefttri = new otri();
  otri righttri = new otri();
  otri farlefttri = new otri();
  otri farrighttri = new otri();
  otri inserttri = new otri();
  GlobalMembersTriangle.REAL firstvertex;
  GlobalMembersTriangle.REAL secondvertex;
  GlobalMembersTriangle.REAL nextvertex;
  GlobalMembersTriangle.REAL lastvertex;
  GlobalMembersTriangle.REAL connectvertex;
  GlobalMembersTriangle.REAL leftvertex;
  GlobalMembersTriangle.REAL midvertex;
  GlobalMembersTriangle.REAL rightvertex;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL lefttest;
  GlobalMembersTriangle.REAL righttest;
  int heapsize;
  int check4events;
  int farrightflag;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym(), onext(), and oprev().

  GlobalMembersTriangle.poolinit(m.splaynodes, sizeof(splaynode), DefineConstantsTriangle.SPLAYNODEPERBLOCK, DefineConstantsTriangle.SPLAYNODEPERBLOCK, 0);
  splayroot = (splaynode) null;

  if (b.verbose != 0)
  {
	System.out.print("  Placing vertices in event heap.\n");
  }
  createeventheap(m, eventheap, events, freeevents);
  heapsize = m.invertices;

  if (b.verbose != 0)
  {
	System.out.print("  Forming triangulation.\n");
  }
  GlobalMembersTriangle.maketriangle(m, b, lefttri);
  GlobalMembersTriangle.maketriangle(m, b, righttri);
  (lefttri).tri[(lefttri).orient] = (GlobalMembersTriangle.REAL)((int)(righttri).tri | (int)(righttri).orient);
  (righttri).tri[(righttri).orient] = (GlobalMembersTriangle.REAL)((int)(lefttri).tri | (int)(lefttri).orient);
  (lefttri).orient = GlobalMembersTriangle.plus1mod3[(lefttri).orient];
  (righttri).orient = GlobalMembersTriangle.minus1mod3[(righttri).orient];
  (lefttri).tri[(lefttri).orient] = (GlobalMembersTriangle.REAL)((int)(righttri).tri | (int)(righttri).orient);
  (righttri).tri[(righttri).orient] = (GlobalMembersTriangle.REAL)((int)(lefttri).tri | (int)(lefttri).orient);
  (lefttri).orient = GlobalMembersTriangle.plus1mod3[(lefttri).orient];
  (righttri).orient = GlobalMembersTriangle.minus1mod3[(righttri).orient];
  (lefttri).tri[(lefttri).orient] = (GlobalMembersTriangle.REAL)((int)(righttri).tri | (int)(righttri).orient);
  (righttri).tri[(righttri).orient] = (GlobalMembersTriangle.REAL)((int)(lefttri).tri | (int)(lefttri).orient);
  firstvertex = (GlobalMembersTriangle.REAL) eventheap[0].eventptr;
  eventheap[0].eventptr = (int) freeevents;
  freeevents = eventheap[0];
  eventheapdelete(eventheap, heapsize, 0);
  heapsize--;
  do
  {
	if (heapsize == 0)
	{
	  System.out.print("Error:  Input vertices are all identical.\n");
	  GlobalMembersTriangle.triexit(1);
	}
	secondvertex = (GlobalMembersTriangle.REAL) eventheap[0].eventptr;
	eventheap[0].eventptr = (int) freeevents;
	freeevents = eventheap[0];
	eventheapdelete(eventheap, heapsize, 0);
	heapsize--;
	if ((firstvertex[0] == secondvertex[0]) && (firstvertex[1] == secondvertex[1]))
	{
	  if (b.quiet == 0)
	  {
		System.out.printf("Warning:  A duplicate vertex at (%.12g, %.12g) appeared and was ignored.\n", secondvertex[0], secondvertex[1]);
	  }
	  ((int)(secondvertex))[m.vertexmarkindex + 1] = -32767;
	  m.undeads++;
	}
  } while ((firstvertex[0] == secondvertex[0]) && (firstvertex[1] == secondvertex[1]));
  (lefttri).tri[GlobalMembersTriangle.plus1mod3[(lefttri).orient] + 3] = (GlobalMembersTriangle.REAL) firstvertex;
  (lefttri).tri[GlobalMembersTriangle.minus1mod3[(lefttri).orient] + 3] = (GlobalMembersTriangle.REAL) secondvertex;
  (righttri).tri[GlobalMembersTriangle.plus1mod3[(righttri).orient] + 3] = (GlobalMembersTriangle.REAL) secondvertex;
  (righttri).tri[GlobalMembersTriangle.minus1mod3[(righttri).orient] + 3] = (GlobalMembersTriangle.REAL) firstvertex;
  (bottommost).tri = (lefttri).tri;
  (bottommost).orient = GlobalMembersTriangle.minus1mod3[(lefttri).orient];
  lastvertex = secondvertex;
  while (heapsize > 0)
  {
	nextevent = eventheap[0];
	eventheapdelete(eventheap, heapsize, 0);
	heapsize--;
	check4events = 1;
	if (nextevent.xkey < m.xmin)
	{
	  (fliptri).orient = (int)((int)(nextevent.eventptr) & (int) 3l);
	  (fliptri).tri = (GlobalMembersTriangle.REAL ** *)((int)(nextevent.eventptr) ^ (int)(fliptri).orient);
	  ptr = (fliptri).tri[(fliptri).orient];
	  (farlefttri).orient = (int)((int)(ptr) & (int) 3l);
	  (farlefttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(farlefttri).orient);
	  ;
	  (farlefttri).orient = GlobalMembersTriangle.plus1mod3[(farlefttri).orient];
	  ;
	  check4deadevent(farlefttri, freeevents, eventheap, heapsize);
	  (farrighttri).tri = (fliptri).tri;
	  (farrighttri).orient = GlobalMembersTriangle.minus1mod3[(fliptri).orient];
	  ptr = (farrighttri).tri[(farrighttri).orient];
	  (farrighttri).orient = (int)((int)(ptr) & (int) 3l);
	  (farrighttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(farrighttri).orient);
	  ;
	  ;
	  check4deadevent(farrighttri, freeevents, eventheap, heapsize);

	  if ((((farlefttri).tri == (bottommost).tri) && ((farlefttri).orient == (bottommost).orient)))
	  {
		(bottommost).tri = (fliptri).tri;
		(bottommost).orient = GlobalMembersTriangle.minus1mod3[(fliptri).orient];
	  }
	  GlobalMembersTriangle.flip(m, b, fliptri);
	  (fliptri).tri[(fliptri).orient + 3] = (GlobalMembersTriangle.REAL) null;
	  (lefttri).tri = (fliptri).tri;
	  (lefttri).orient = GlobalMembersTriangle.minus1mod3[(fliptri).orient];
	  (righttri).tri = (fliptri).tri;
	  (righttri).orient = GlobalMembersTriangle.plus1mod3[(fliptri).orient];
	  ptr = (lefttri).tri[(lefttri).orient];
	  (farlefttri).orient = (int)((int)(ptr) & (int) 3l);
	  (farlefttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(farlefttri).orient);
	  ;

	  if (GlobalMembersTriangle.randomnation(DefineConstantsTriangle.SAMPLERATE) == 0)
	  {
		ptr = (fliptri).tri[(fliptri).orient];
		(fliptri).orient = (int)((int)(ptr) & (int) 3l);
		(fliptri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(fliptri).orient);
		;
		leftvertex = (GlobalMembersTriangle.REAL)(fliptri).tri[GlobalMembersTriangle.minus1mod3[(fliptri).orient] + 3];
		midvertex = (GlobalMembersTriangle.REAL)(fliptri).tri[(fliptri).orient + 3];
		rightvertex = (GlobalMembersTriangle.REAL)(fliptri).tri[GlobalMembersTriangle.plus1mod3[(fliptri).orient] + 3];
		splayroot = GlobalMembersTriangle.circletopinsert(m, b, splayroot, lefttri, leftvertex, midvertex, rightvertex, nextevent.ykey);
	  }
	  }
	else
	{
	  nextvertex = (GlobalMembersTriangle.REAL) nextevent.eventptr;
	  if ((nextvertex[0] == lastvertex[0]) && (nextvertex[1] == lastvertex[1]))
	  {
		if (b.quiet == 0)
		{
		  System.out.printf("Warning:  A duplicate vertex at (%.12g, %.12g) appeared and was ignored.\n", nextvertex[0], nextvertex[1]);
		}
		((int)(nextvertex))[m.vertexmarkindex + 1] = -32767;
		m.undeads++;
		check4events = 0;
		}
	  else
	  {
		lastvertex = nextvertex;

		splayroot = GlobalMembersTriangle.frontlocate(m, splayroot, bottommost, nextvertex, searchtri, farrightflag);
//
//        otricopy(bottommost, searchtri);
//        farrightflag = 0;
//        while (!farrightflag && rightofhyperbola(m, &searchtri, nextvertex)) {
//          onextself(searchtri);
//          farrightflag = otriequal(searchtri, bottommost);
//        }
//

		check4deadevent(searchtri, freeevents, eventheap, heapsize);

		(farrighttri).tri = (searchtri).tri;
		(farrighttri).orient = (searchtri).orient;
		ptr = (searchtri).tri[(searchtri).orient];
		(farlefttri).orient = (int)((int)(ptr) & (int) 3l);
		(farlefttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(farlefttri).orient);
		;
		GlobalMembersTriangle.maketriangle(m, b, lefttri);
		GlobalMembersTriangle.maketriangle(m, b, righttri);
		connectvertex = (GlobalMembersTriangle.REAL)(farrighttri).tri[GlobalMembersTriangle.minus1mod3[(farrighttri).orient] + 3];
		(lefttri).tri[GlobalMembersTriangle.plus1mod3[(lefttri).orient] + 3] = (GlobalMembersTriangle.REAL) connectvertex;
		(lefttri).tri[GlobalMembersTriangle.minus1mod3[(lefttri).orient] + 3] = (GlobalMembersTriangle.REAL) nextvertex;
		(righttri).tri[GlobalMembersTriangle.plus1mod3[(righttri).orient] + 3] = (GlobalMembersTriangle.REAL) nextvertex;
		(righttri).tri[GlobalMembersTriangle.minus1mod3[(righttri).orient] + 3] = (GlobalMembersTriangle.REAL) connectvertex;
		(lefttri).tri[(lefttri).orient] = (GlobalMembersTriangle.REAL)((int)(righttri).tri | (int)(righttri).orient);
		(righttri).tri[(righttri).orient] = (GlobalMembersTriangle.REAL)((int)(lefttri).tri | (int)(lefttri).orient);
		(lefttri).orient = GlobalMembersTriangle.plus1mod3[(lefttri).orient];
		(righttri).orient = GlobalMembersTriangle.minus1mod3[(righttri).orient];
		(lefttri).tri[(lefttri).orient] = (GlobalMembersTriangle.REAL)((int)(righttri).tri | (int)(righttri).orient);
		(righttri).tri[(righttri).orient] = (GlobalMembersTriangle.REAL)((int)(lefttri).tri | (int)(lefttri).orient);
		(lefttri).orient = GlobalMembersTriangle.plus1mod3[(lefttri).orient];
		(righttri).orient = GlobalMembersTriangle.minus1mod3[(righttri).orient];
		(lefttri).tri[(lefttri).orient] = (GlobalMembersTriangle.REAL)((int)(farlefttri).tri | (int)(farlefttri).orient);
		(farlefttri).tri[(farlefttri).orient] = (GlobalMembersTriangle.REAL)((int)(lefttri).tri | (int)(lefttri).orient);
		(righttri).tri[(righttri).orient] = (GlobalMembersTriangle.REAL)((int)(farrighttri).tri | (int)(farrighttri).orient);
		(farrighttri).tri[(farrighttri).orient] = (GlobalMembersTriangle.REAL)((int)(righttri).tri | (int)(righttri).orient);
		if (farrightflag == 0 && (((farrighttri).tri == (bottommost).tri) && ((farrighttri).orient == (bottommost).orient)))
		{
		  (bottommost).tri = (lefttri).tri;
		  (bottommost).orient = (lefttri).orient;
		}

		if (GlobalMembersTriangle.randomnation(DefineConstantsTriangle.SAMPLERATE) == 0)
		{
		  splayroot = GlobalMembersTriangle.splayinsert(m, splayroot, lefttri, nextvertex);
		}
		else if (GlobalMembersTriangle.randomnation(DefineConstantsTriangle.SAMPLERATE) == 0)
		{
		  (inserttri).tri = (righttri).tri;
		  (inserttri).orient = GlobalMembersTriangle.plus1mod3[(righttri).orient];
		  splayroot = GlobalMembersTriangle.splayinsert(m, splayroot, inserttri, nextvertex);
		}
	  }
	}
	nextevent.eventptr = (int) freeevents;
	freeevents = nextevent;

	if (check4events != 0)
	{
	  leftvertex = (GlobalMembersTriangle.REAL)(farlefttri).tri[(farlefttri).orient + 3];
	  midvertex = (GlobalMembersTriangle.REAL)(lefttri).tri[GlobalMembersTriangle.minus1mod3[(lefttri).orient] + 3];
	  rightvertex = (GlobalMembersTriangle.REAL)(lefttri).tri[(lefttri).orient + 3];
	  lefttest = GlobalMembersTriangle.counterclockwise(m, b, leftvertex, midvertex, rightvertex);
	  if (lefttest > 0.0)
	  {
		newevent = freeevents;
		freeevents = (event) freeevents.eventptr;
		newevent.xkey = m.xminextreme;
		newevent.ykey = GlobalMembersTriangle.circletop(m, leftvertex, midvertex, rightvertex, lefttest);
		newevent.eventptr = (int)(GlobalMembersTriangle.REAL)((int)(lefttri).tri | (int)(lefttri).orient);
		eventheapinsert(eventheap, heapsize, newevent);
		heapsize++;
		(lefttri).tri[GlobalMembersTriangle.plus1mod3[(lefttri).orient] + 3] = (GlobalMembersTriangle.REAL) newevent;
	  }
	  leftvertex = (GlobalMembersTriangle.REAL)(righttri).tri[(righttri).orient + 3];
	  midvertex = (GlobalMembersTriangle.REAL)(righttri).tri[GlobalMembersTriangle.plus1mod3[(righttri).orient] + 3];
	  rightvertex = (GlobalMembersTriangle.REAL)(farrighttri).tri[(farrighttri).orient + 3];
	  righttest = GlobalMembersTriangle.counterclockwise(m, b, leftvertex, midvertex, rightvertex);
	  if (righttest > 0.0)
	  {
		newevent = freeevents;
		freeevents = (event) freeevents.eventptr;
		newevent.xkey = m.xminextreme;
		newevent.ykey = GlobalMembersTriangle.circletop(m, leftvertex, midvertex, rightvertex, righttest);
		newevent.eventptr = (int)(GlobalMembersTriangle.REAL)((int)(farrighttri).tri | (int)(farrighttri).orient);
		eventheapinsert(eventheap, heapsize, newevent);
		heapsize++;
		(farrighttri).tri[GlobalMembersTriangle.plus1mod3[(farrighttri).orient] + 3] = (GlobalMembersTriangle.REAL) newevent;
	  }
	}
  }

  GlobalMembersTriangle.pooldeinit(m.splaynodes);
  (bottommost).orient = GlobalMembersTriangle.minus1mod3[(bottommost).orient];
  return GlobalMembersTriangle.removeghosts(m, b, bottommost);
}

//#endif // not REDUCED

//*                                                                         *
//*                                                                         *
//******** Sweepline Delaunay triangulation ends here                ********

//******** General mesh construction routines begin here             ********
//*                                                                         *
//*                                                                         *

//***************************************************************************
//                                                                           
//  delaunay()   Form a Delaunay triangulation.                              
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int GlobalMembersTriangle.delaunay(struct mesh m, struct behavior b)
//#else
int GlobalMembersTriangle.delaunay(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  int hulledges;

  m.eextras = 0;
  GlobalMembersTriangle.initializetrisubpools(m, b);

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if REDUCED
  if (b.quiet == 0)
  {
	System.out.print("Constructing Delaunay triangulation by divide-and-conquer method.\n");
  }
  hulledges = GlobalMembersTriangle.divconqdelaunay(m, b);
//#else
  if (b.quiet == 0)
  {
	System.out.print("Constructing Delaunay triangulation ");
	if (b.incremental != 0)
	{
	  System.out.print("by incremental method.\n");
	}
	else if (b.sweepline != 0)
	{
	  System.out.print("by sweepline method.\n");
	}
	else
	{
	  System.out.print("by divide-and-conquer method.\n");
	}
  }
  if (b.incremental != 0)
  {
	hulledges = GlobalMembersTriangle.incrementaldelaunay(m, b);
  }
  else if (b.sweepline != 0)
  {
	hulledges = GlobalMembersTriangle.sweeplinedelaunay(m, b);
  }
  else
  {
	hulledges = GlobalMembersTriangle.divconqdelaunay(m, b);
  }
//#endif // not REDUCED

  if (m.triangles.items == 0)
  {
	// The input vertices were all collinear, so there are no triangles. 
	return 0l;
  }
  else
  {
	return hulledges;
  }
}

//***************************************************************************
//                                                                           
//  reconstruct()   Reconstruct a triangulation from its .ele (and possibly  
//                  .poly) file.  Used when the -r switch is used.           
//                                                                           
//  Reads an .ele file and reconstructs the original mesh.  If the -p switch 
//  is used, this procedure will also read a .poly file and reconstruct the  
//  subsegments of the original mesh.  If the -a switch is used, this        
//  procedure will also read an .area file and set a maximum area constraint 
//  on each triangle.                                                        
//                                                                           
//  Vertices that are not corners of triangles, such as nodes on edges of    
//  subparametric elements, are discarded.                                   
//                                                                           
//  This routine finds the adjacencies between triangles (and subsegments)   
//  by forming one stack of triangles for each vertex.  Each triangle is on  
//  three different stacks simultaneously.  Each triangle's subsegment       
//  pointers are used to link the items in each stack.  This memory-saving   
//  feature makes the code harder to read.  The most important thing to keep 
//  in mind is that each triangle is removed from a stack precisely when     
//  the corresponding pointer is adjusted to refer to a subsegment rather    
//  than the next triangle of the stack.                                     
//                                                                           
//***************************************************************************



//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
int GlobalMembersTriangle.reconstruct(struct mesh m, struct behavior b, int *trianglelist, GlobalMembersTriangle.REAL *triangleattriblist, GlobalMembersTriangle.REAL *trianglearealist, int elements, int corners, int attribs, int *segmentlist,int *segmentmarkerlist, int numberofsegments)
//#else
int GlobalMembersTriangle.reconstruct(m, b, trianglelist, triangleattriblist, trianglearealist, elements, corners, attribs, segmentlist, segmentmarkerlist, numberofsegments)
mesh m;
behavior b;
int trianglelist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL triangleattriblist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL trianglearealist;
int elements;
int corners;
int attribs;
int segmentlist;
int segmentmarkerlist;
int numberofsegments;
//#endif // not ANSI_DECLARATORS


//#else
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int GlobalMembersTriangle.reconstruct(struct mesh m, struct behavior b, char *elefilename, char *areafilename, char *polyfilename, FILE *polyfile)
//#else
int GlobalMembersTriangle.reconstruct(m, b, elefilename, areafilename, polyfilename, polyfile)
mesh m;
behavior b;
String elefilename;
String areafilename;
String polyfilename;
FILE polyfile;
//#endif // not ANSI_DECLARATORS

//#endif // not TRILIBRARY

{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  int vertexindex;
  int attribindex;
//#else
  FILE elefile;
  FILE areafile;
  String inputline = new String(new char[DefineConstantsTriangle.INPUTLINESIZE]);
  String stringptr;
  int areaelements;
//#endif // not TRILIBRARY
  otri triangleloop = new otri();
  otri triangleleft = new otri();
  otri checktri = new otri();
  otri checkleft = new otri();
  otri checkneighbor = new otri();
  osub subsegloop = new osub();
  GlobalMembersTriangle.REAL[][][] vertexarray;
  GlobalMembersTriangle.REAL[][][] prevlink;
  GlobalMembersTriangle.REAL[][] nexttri;
  GlobalMembersTriangle.REAL tdest;
  GlobalMembersTriangle.REAL tapex;
  GlobalMembersTriangle.REAL checkdest;
  GlobalMembersTriangle.REAL checkapex;
  GlobalMembersTriangle.REAL shorg;
  GlobalMembersTriangle.REAL killvertex;
  GlobalMembersTriangle.REAL segmentorg;
  GlobalMembersTriangle.REAL segmentdest;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL area;
  int[] corner = new int[3];
  int[] end = new int[2];
  int killvertexindex;
  int incorners;
  int segmentmarkers;
  int boundmarker;
  int aroundvertex;
  int hullsize;
  int notfound;
  int elementnumber;
  int segmentnumber;
  int i;
  int j;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  m.inelements = elements;
  incorners = corners;
  if (incorners < 3)
  {
	System.out.print("Error:  Triangles must have at least 3 vertices.\n");
	GlobalMembersTriangle.triexit(1);
  }
  m.eextras = attribs;
//#else
  // Read the triangles from an .ele file. 
  if (b.quiet == 0)
  {
	System.out.printf("Opening %s.\n", elefilename);
  }
  elefile = fopen(elefilename, "r");
  if (elefile == (FILE) null)
  {
	System.out.printf("  Error:  Cannot access file %s.\n", elefilename);
	GlobalMembersTriangle.triexit(1);
  }
  // Read number of triangles, number of vertices per triangle, and 
  //   number of triangle attributes from .ele file.                
  stringptr = GlobalMembersTriangle.readline(inputline, elefile, elefilename);
  m.inelements = (int) strtol(stringptr, stringptr, 0);
  stringptr = GlobalMembersTriangle.findfield(stringptr);
  if ( stringptr.equals('\0'))
  {
	incorners = 3;
  }
  else
  {
	incorners = (int) strtol(stringptr, stringptr, 0);
	if (incorners < 3)
	{
	  System.out.printf("Error:  Triangles in %s must have at least 3 vertices.\n", elefilename);
	  GlobalMembersTriangle.triexit(1);
	}
  }
  stringptr = GlobalMembersTriangle.findfield(stringptr);
  if ( stringptr.equals('\0'))
  {
	m.eextras = 0;
  }
  else
  {
	m.eextras = (int) strtol(stringptr, stringptr, 0);
  }
//#endif // not TRILIBRARY

  GlobalMembersTriangle.initializetrisubpools(m, b);

  // Create the triangles. 
  for (elementnumber = 1; elementnumber <= m.inelements; elementnumber++)
  {
	GlobalMembersTriangle.maketriangle(m, b, triangleloop);
	// Mark the triangle as living. 
	triangleloop.tri[3] = (GlobalMembersTriangle.REAL) triangleloop.tri;
  }

  segmentmarkers = 0;
  if (b.poly != 0)
  {
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	m.insegments = numberofsegments;
	segmentmarkers = segmentmarkerlist != (int) null;
//#else
	// Read number of segments and number of segment 
	//   boundary markers from .poly file.           
	stringptr = GlobalMembersTriangle.readline(inputline, polyfile, b.inpolyfilename);
	m.insegments = (int) strtol(stringptr, stringptr, 0);
	stringptr = GlobalMembersTriangle.findfield(stringptr);
	if ( !stringptr.equals('\0'))
	{
	  segmentmarkers = (int) strtol(stringptr, stringptr, 0);
	}
//#endif // not TRILIBRARY

	// Create the subsegments. 
	for (segmentnumber = 1; segmentnumber <= m.insegments; segmentnumber++)
	{
	  GlobalMembersTriangle.makesubseg(m, subsegloop);
	  // Mark the subsegment as living. 
	  subsegloop.ss[2] = (GlobalMembersTriangle.REAL) subsegloop.ss;
	}
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  vertexindex = 0;
  attribindex = 0;
//#else
  if (b.vararea != 0)
  {
	// Open an .area file, check for consistency with the .ele file. 
	if (b.quiet == 0)
	{
	  System.out.printf("Opening %s.\n", areafilename);
	}
	areafile = fopen(areafilename, "r");
	if (areafile == (FILE) null)
	{
	  System.out.printf("  Error:  Cannot access file %s.\n", areafilename);
	  GlobalMembersTriangle.triexit(1);
	}
	stringptr = GlobalMembersTriangle.readline(inputline, areafile, areafilename);
	areaelements = (int) strtol(stringptr, stringptr, 0);
	if (areaelements != m.inelements)
	{
	  System.out.printf("Error:  %s and %s disagree on number of triangles.\n", elefilename, areafilename);
	  GlobalMembersTriangle.triexit(1);
	}
  }
//#endif // not TRILIBRARY

  if (b.quiet == 0)
  {
	System.out.print("Reconstructing mesh.\n");
  }
  // Allocate a temporary array that maps each vertex to some adjacent 
  //   triangle.  I took care to allocate all the permanent memory for 
  //   triangles and subsegments first.                                
  vertexarray = (GlobalMembersTriangle.REAL ** *) GlobalMembersTriangle.trimalloc(m.vertices.items * (int) sizeof(GlobalMembersTriangle.REAL));
  // Each vertex is initially unrepresented. 
  for (i = 0; i < m.vertices.items; i++)
  {
	vertexarray[i] = (GlobalMembersTriangle.REAL) m.dummytri;
  }

  if (b.verbose != 0)
  {
	System.out.print("  Assembling triangles.\n");
  }
  // Read the triangles from the .ele file, and link 
  //   together those that share an edge.            
  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  elementnumber = b.firstnumber;
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	// Copy the triangle's three corners. 
	for (j = 0; j < 3; j++)
	{
	  corner[j] = trianglelist[vertexindex++];
	  if ((corner[j] < b.firstnumber) || (corner[j] >= b.firstnumber + m.invertices))
	  {
		System.out.printf("Error:  Triangle %ld has an invalid vertex index.\n", elementnumber);
		GlobalMembersTriangle.triexit(1);
	  }
	}
//#else
	// Read triangle number and the triangle's three corners. 
	stringptr = GlobalMembersTriangle.readline(inputline, elefile, elefilename);
	for (j = 0; j < 3; j++)
	{
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( stringptr.equals('\0'))
	  {
		System.out.printf("Error:  Triangle %ld is missing vertex %d in %s.\n", elementnumber, j + 1, elefilename);
		GlobalMembersTriangle.triexit(1);
	  }
	  else
	  {
		corner[j] = (int) strtol(stringptr, stringptr, 0);
		if ((corner[j] < b.firstnumber) || (corner[j] >= b.firstnumber + m.invertices))
		{
		  System.out.printf("Error:  Triangle %ld has an invalid vertex index.\n", elementnumber);
		  GlobalMembersTriangle.triexit(1);
		}
	  }
	}
//#endif // not TRILIBRARY

	// Find out about (and throw away) extra nodes. 
	for (j = 3; j < incorners; j++)
	{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	  killvertexindex = trianglelist[vertexindex++];
//#else
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( !stringptr.equals('\0'))
	  {
		killvertexindex = (int) strtol(stringptr, stringptr, 0);
//#endif // not TRILIBRARY
		if ((killvertexindex >= b.firstnumber) && (killvertexindex < b.firstnumber + m.invertices))
		{
		  // Delete the non-corner vertex if it's not already deleted. 
		  killvertex = GlobalMembersTriangle.getvertex(m, b, killvertexindex);
		  if (((int)(killvertex))[m.vertexmarkindex + 1] != -32768)
		  {
			GlobalMembersTriangle.vertexdealloc(m, killvertex);
		  }
		}
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
	  }
//#endif // not TRILIBRARY
	}

	// Read the triangle's attributes. 
	for (j = 0; j < m.eextras; j++)
	{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ((GlobalMembersTriangle.REAL)(triangleloop).tri)[m.elemattribindex + (j)] = triangleattriblist[attribindex++];
//#else
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( stringptr.equals('\0'))
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		((GlobalMembersTriangle.REAL)(triangleloop).tri)[m.elemattribindex + (j)] = 0;
	  }
	  else
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		((GlobalMembersTriangle.REAL)(triangleloop).tri)[m.elemattribindex + (j)] = (GlobalMembersTriangle.REAL) strtod(stringptr, stringptr);
	  }
//#endif // not TRILIBRARY
	}

	if (b.vararea != 0)
	{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	  area = trianglearealist[elementnumber - b.firstnumber];
//#else
	  // Read an area constraint from the .area file. 
	  stringptr = GlobalMembersTriangle.readline(inputline, areafile, areafilename);
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( stringptr.equals('\0'))
	  {
		area = -1.0; // No constraint on this triangle.
	  }
	  else
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		area = (GlobalMembersTriangle.REAL) strtod(stringptr, stringptr);
	  }
//#endif // not TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ((GlobalMembersTriangle.REAL)(triangleloop).tri)[m.areaboundindex] = area;
	}

	// Set the triangle's vertices. 
	triangleloop.orient = 0;
	(triangleloop).tri[GlobalMembersTriangle.plus1mod3[(triangleloop).orient] + 3] = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.getvertex(m, b, corner[0]);
	(triangleloop).tri[GlobalMembersTriangle.minus1mod3[(triangleloop).orient] + 3] = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.getvertex(m, b, corner[1]);
	(triangleloop).tri[(triangleloop).orient + 3] = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.getvertex(m, b, corner[2]);
	// Try linking the triangle to others that share these vertices. 
	for (triangleloop.orient = 0; triangleloop.orient < 3; triangleloop.orient++)
	{
	  // Take the number for the origin of triangleloop. 
	  aroundvertex = corner[triangleloop.orient];
	  // Look for other triangles having this vertex. 
	  nexttri = vertexarray[aroundvertex - b.firstnumber];
	  // Link the current triangle to the next one in the stack. 
	  triangleloop.tri[6 + triangleloop.orient] = nexttri;
	  // Push the current triangle onto the stack. 
	  vertexarray[aroundvertex - b.firstnumber] = (GlobalMembersTriangle.REAL)((int)(triangleloop).tri | (int)(triangleloop).orient);
	  (checktri).orient = (int)((int)(nexttri) & (int) 3l);
	  (checktri).tri = (GlobalMembersTriangle.REAL ** *)((int)(nexttri) ^ (int)(checktri).orient);
	  if (checktri.tri != m.dummytri)
	  {
		tdest = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.minus1mod3[(triangleloop).orient] + 3];
		tapex = (GlobalMembersTriangle.REAL)(triangleloop).tri[(triangleloop).orient + 3];
		// Look for other triangles that share an edge. 
		do
		{
		  checkdest = (GlobalMembersTriangle.REAL)(checktri).tri[GlobalMembersTriangle.minus1mod3[(checktri).orient] + 3];
		  checkapex = (GlobalMembersTriangle.REAL)(checktri).tri[(checktri).orient + 3];
		  if (tapex == checkdest)
		  {
			// The two triangles share an edge; bond them together. 
			(triangleleft).tri = (triangleloop).tri;
			(triangleleft).orient = GlobalMembersTriangle.minus1mod3[(triangleloop).orient];
			(triangleleft).tri[(triangleleft).orient] = (GlobalMembersTriangle.REAL)((int)(checktri).tri | (int)(checktri).orient);
			(checktri).tri[(checktri).orient] = (GlobalMembersTriangle.REAL)((int)(triangleleft).tri | (int)(triangleleft).orient);
		  }
		  if (tdest == checkapex)
		  {
			// The two triangles share an edge; bond them together. 
			(checkleft).tri = (checktri).tri;
			(checkleft).orient = GlobalMembersTriangle.minus1mod3[(checktri).orient];
			(triangleloop).tri[(triangleloop).orient] = (GlobalMembersTriangle.REAL)((int)(checkleft).tri | (int)(checkleft).orient);
			(checkleft).tri[(checkleft).orient] = (GlobalMembersTriangle.REAL)((int)(triangleloop).tri | (int)(triangleloop).orient);
		  }
		  // Find the next triangle in the stack. 
		  nexttri = checktri.tri[6 + checktri.orient];
		  (checktri).orient = (int)((int)(nexttri) & (int) 3l);
		  (checktri).tri = (GlobalMembersTriangle.REAL ** *)((int)(nexttri) ^ (int)(checktri).orient);
		} while (checktri.tri != m.dummytri);
	  }
	}
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
	elementnumber++;
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  vertexindex = 0;
//#else
  fclose(elefile);
  if (b.vararea != 0)
  {
	fclose(areafile);
  }
//#endif // not TRILIBRARY

  hullsize = 0; // Prepare to count the boundary edges.
  if (b.poly != 0)
  {
	if (b.verbose != 0)
	{
	  System.out.print("  Marking segments in triangulation.\n");
	}
	// Read the segments from the .poly file, and link them 
	//   to their neighboring triangles.                    
	boundmarker = 0;
	GlobalMembersTriangle.traversalinit(m.subsegs);
	subsegloop.ss = GlobalMembersTriangle.subsegtraverse(m);
	segmentnumber = b.firstnumber;
	while (subsegloop.ss != (GlobalMembersTriangle.REAL ** *) null)
	{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	  end[0] = segmentlist[vertexindex++];
	  end[1] = segmentlist[vertexindex++];
	  if (segmentmarkers != 0)
	  {
		boundmarker = segmentmarkerlist[segmentnumber - b.firstnumber];
	  }
//#else
	  // Read the endpoints of each segment, and possibly a boundary marker. 
	  stringptr = GlobalMembersTriangle.readline(inputline, polyfile, b.inpolyfilename);
	  // Skip the first (segment number) field. 
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( stringptr.equals('\0'))
	  {
		System.out.printf("Error:  Segment %ld has no endpoints in %s.\n", segmentnumber, polyfilename);
		GlobalMembersTriangle.triexit(1);
	  }
	  else
	  {
		end[0] = (int) strtol(stringptr, stringptr, 0);
	  }
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( stringptr.equals('\0'))
	  {
		System.out.printf("Error:  Segment %ld is missing its second endpoint in %s.\n", segmentnumber, polyfilename);
		GlobalMembersTriangle.triexit(1);
	  }
	  else
	  {
		end[1] = (int) strtol(stringptr, stringptr, 0);
	  }
	  if (segmentmarkers != 0)
	  {
		stringptr = GlobalMembersTriangle.findfield(stringptr);
		if ( stringptr.equals('\0'))
		{
		  boundmarker = 0;
		}
		else
		{
		  boundmarker = (int) strtol(stringptr, stringptr, 0);
		}
	  }
//#endif // not TRILIBRARY
	  for (j = 0; j < 2; j++)
	  {
		if ((end[j] < b.firstnumber) || (end[j] >= b.firstnumber + m.invertices))
		{
		  System.out.printf("Error:  Segment %ld has an invalid vertex index.\n", segmentnumber);
		  GlobalMembersTriangle.triexit(1);
		}
	  }

	  // set the subsegment's vertices. 
	  subsegloop.ssorient = 0;
	  segmentorg = GlobalMembersTriangle.getvertex(m, b, end[0]);
	  segmentdest = GlobalMembersTriangle.getvertex(m, b, end[1]);
	  (subsegloop).ss[2 + (subsegloop).ssorient] = (GlobalMembersTriangle.REAL) segmentorg;
	  (subsegloop).ss[3 - (subsegloop).ssorient] = (GlobalMembersTriangle.REAL) segmentdest;
	  (subsegloop).ss[4 + (subsegloop).ssorient] = (GlobalMembersTriangle.REAL) segmentorg;
	  (subsegloop).ss[5 - (subsegloop).ssorient] = (GlobalMembersTriangle.REAL) segmentdest;
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
//	  * (int *)((subsegloop).ss + 8) = boundmarker;
	  // Try linking the subsegment to triangles that share these vertices. 
	  for (subsegloop.ssorient = 0; subsegloop.ssorient < 2; subsegloop.ssorient++)
	  {
		// Take the number for the destination of subsegloop. 
		aroundvertex = end[1 - subsegloop.ssorient];
		// Look for triangles having this vertex. 
		prevlink = vertexarray[aroundvertex - b.firstnumber];
		nexttri = vertexarray[aroundvertex - b.firstnumber];
		(checktri).orient = (int)((int)(nexttri) & (int) 3l);
		(checktri).tri = (GlobalMembersTriangle.REAL ** *)((int)(nexttri) ^ (int)(checktri).orient);
		shorg = (GlobalMembersTriangle.REAL)(subsegloop).ss[2 + (subsegloop).ssorient];
		notfound = 1;
		// Look for triangles having this edge.  Note that I'm only       
		//   comparing each triangle's destination with the subsegment;   
		//   each triangle's apex is handled through a different vertex.  
		//   Because each triangle appears on three vertices' lists, each 
		//   occurrence of a triangle on a list can (and does) represent  
		//   an edge.  In this way, most edges are represented twice, and 
		//   every triangle-subsegment bond is represented once.          
		while (notfound != 0 && (checktri.tri != m.dummytri))
		{
		  checkdest = (GlobalMembersTriangle.REAL)(checktri).tri[GlobalMembersTriangle.minus1mod3[(checktri).orient] + 3];
		  if (shorg == checkdest)
		  {
			// We have a match.  Remove this triangle from the list. 
			*prevlink = checktri.tri[6 + checktri.orient];
			// Bond the subsegment to the triangle. 
			(checktri).tri[6 + (checktri).orient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(subsegloop).ss | (int)(subsegloop).ssorient);
			(subsegloop).ss[6 + (subsegloop).ssorient] = (GlobalMembersTriangle.REAL)(GlobalMembersTriangle.REAL)((int)(checktri).tri | (int)(checktri).orient);
			// Check if this is a boundary edge. 
			ptr = (checktri).tri[(checktri).orient];
			(checkneighbor).orient = (int)((int)(ptr) & (int) 3l);
			(checkneighbor).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(checkneighbor).orient);
			;
			if (checkneighbor.tri == m.dummytri)
			{
			  // The next line doesn't insert a subsegment (because there's 
			  //   already one there), but it sets the boundary markers of  
			  //   the existing subsegment and its vertices.                
			  GlobalMembersTriangle.insertsubseg(m, b, checktri, 1);
			  hullsize++;
			}
			notfound = 0;
		  }
		  // Find the next triangle in the stack. 
		  prevlink = checktri.tri[6 + checktri.orient];
		  nexttri = checktri.tri[6 + checktri.orient];
		  (checktri).orient = (int)((int)(nexttri) & (int) 3l);
		  (checktri).tri = (GlobalMembersTriangle.REAL ** *)((int)(nexttri) ^ (int)(checktri).orient);
		}
	  }
	  subsegloop.ss = GlobalMembersTriangle.subsegtraverse(m);
	  segmentnumber++;
	}
  }

  // Mark the remaining edges as not being attached to any subsegment. 
  // Also, count the (yet uncounted) boundary edges.                   
  for (i = 0; i < m.vertices.items; i++)
  {
	// Search the stack of triangles adjacent to a vertex. 
	nexttri = vertexarray[i];
	(checktri).orient = (int)((int)(nexttri) & (int) 3l);
	(checktri).tri = (GlobalMembersTriangle.REAL ** *)((int)(nexttri) ^ (int)(checktri).orient);
	while (checktri.tri != m.dummytri)
	{
	  // Find the next triangle in the stack before this 
	  //   information gets overwritten.                 
	  nexttri = checktri.tri[6 + checktri.orient];
	  // No adjacent subsegment.  (This overwrites the stack info.) 
	  (checktri).tri[6 + (checktri).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
	  ptr = (checktri).tri[(checktri).orient];
	  (checkneighbor).orient = (int)((int)(ptr) & (int) 3l);
	  (checkneighbor).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(checkneighbor).orient);
	  ;
	  if (checkneighbor.tri == m.dummytri)
	  {
		GlobalMembersTriangle.insertsubseg(m, b, checktri, 1);
		hullsize++;
	  }
	  (checktri).orient = (int)((int)(nexttri) & (int) 3l);
	  (checktri).tri = (GlobalMembersTriangle.REAL ** *)((int)(nexttri) ^ (int)(checktri).orient);
	}
  }

  GlobalMembersTriangle.trifree((int) vertexarray);
  return hullsize;
}

//#endif // not CDT_ONLY

//*                                                                         *
//*                                                                         *
//******** General mesh construction routines end here               ********

//******** Segment insertion begins here                             ********
//*                                                                         *
//*                                                                         *

//***************************************************************************
//                                                                           
//  finddirection()   Find the first triangle on the path from one point     
//                    to another.                                            
//                                                                           
//  Finds the triangle that intersects a line segment drawn from the         
//  origin of `searchtri' to the point `searchpoint', and returns the result 
//  in `searchtri'.  The origin of `searchtri' does not change, even though  
//  the triangle returned may differ from the one passed in.  This routine   
//  is used to find the direction to move in to get from one point to        
//  another.                                                                 
//                                                                           
//  The return value notes whether the destination or apex of the found      
//  triangle is collinear with the two points in question.                   
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
enum finddirectionresult GlobalMembersTriangle.finddirection(struct mesh m, struct behavior b, struct otri searchtri, GlobalMembersTriangle.REAL searchpoint)
//#else
enum finddirectionresult GlobalMembersTriangle.finddirection(m, b, searchtri, searchpoint)
mesh m;
behavior b;
otri searchtri;
GlobalMembersTriangle.REAL searchpoint;
//#endif // not ANSI_DECLARATORS

{
  otri checktri = new otri();
  GlobalMembersTriangle.REAL startvertex;
  GlobalMembersTriangle.REAL leftvertex;
  GlobalMembersTriangle.REAL rightvertex;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL leftccw;
  GlobalMembersTriangle.REAL rightccw;
  int leftflag;
  int rightflag;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by onext() and oprev().

  startvertex = (GlobalMembersTriangle.REAL) searchtri.tri[GlobalMembersTriangle.plus1mod3[searchtri.orient] + 3];
  rightvertex = (GlobalMembersTriangle.REAL) searchtri.tri[GlobalMembersTriangle.minus1mod3[searchtri.orient] + 3];
  leftvertex = (GlobalMembersTriangle.REAL) searchtri.tri[searchtri.orient + 3];
  // Is `searchpoint' to the left? 
  leftccw = GlobalMembersTriangle.counterclockwise(m, b, searchpoint, startvertex, leftvertex);
  leftflag = leftccw > 0.0;
  // Is `searchpoint' to the right? 
  rightccw = GlobalMembersTriangle.counterclockwise(m, b, startvertex, searchpoint, rightvertex);
  rightflag = rightccw > 0.0;
  if (leftflag != 0 && rightflag != 0)
  {
	// `searchtri' faces directly away from `searchpoint'.  We could go left 
	//   or right.  Ask whether it's a triangle or a boundary on the left.   
	(checktri).tri = searchtri.tri;
	(checktri).orient = GlobalMembersTriangle.minus1mod3[searchtri.orient];
	ptr = (checktri).tri[(checktri).orient];
	(checktri).orient = (int)((int)(ptr) & (int) 3l);
	(checktri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(checktri).orient);
	;
	;
	if (checktri.tri == m.dummytri)
	{
	  leftflag = 0;
	}
	else
	{
	  rightflag = 0;
	}
  }
  while (leftflag != 0)
  {
	// Turn left until satisfied. 
	searchtri.orient = GlobalMembersTriangle.minus1mod3[searchtri.orient];
	ptr = searchtri.tri[searchtri.orient];
	searchtri.orient = (int)((int)(ptr) & (int) 3l);
	searchtri.tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int) searchtri.orient);
	;
	;
	if (searchtri.tri == m.dummytri)
	{
	  System.out.print("Internal error in finddirection():  Unable to find a\n");
	  System.out.printf("  triangle leading from (%.12g, %.12g) to", startvertex[0], startvertex[1]);
	  System.out.printf("  (%.12g, %.12g).\n", searchpoint[0], searchpoint[1]);
	  GlobalMembersTriangle.internalerror();
	}
	leftvertex = (GlobalMembersTriangle.REAL) searchtri.tri[searchtri.orient + 3];
	rightccw = leftccw;
	leftccw = GlobalMembersTriangle.counterclockwise(m, b, searchpoint, startvertex, leftvertex);
	leftflag = leftccw > 0.0;
  }
  while (rightflag != 0)
  {
	// Turn right until satisfied. 
	ptr = searchtri.tri[searchtri.orient];
	searchtri.orient = (int)((int)(ptr) & (int) 3l);
	searchtri.tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int) searchtri.orient);
	;
	searchtri.orient = GlobalMembersTriangle.plus1mod3[searchtri.orient];
	;
	if (searchtri.tri == m.dummytri)
	{
	  System.out.print("Internal error in finddirection():  Unable to find a\n");
	  System.out.printf("  triangle leading from (%.12g, %.12g) to", startvertex[0], startvertex[1]);
	  System.out.printf("  (%.12g, %.12g).\n", searchpoint[0], searchpoint[1]);
	  GlobalMembersTriangle.internalerror();
	}
	rightvertex = (GlobalMembersTriangle.REAL) searchtri.tri[GlobalMembersTriangle.minus1mod3[searchtri.orient] + 3];
	leftccw = rightccw;
	rightccw = GlobalMembersTriangle.counterclockwise(m, b, startvertex, searchpoint, rightvertex);
	rightflag = rightccw > 0.0;
  }
  if (leftccw == 0.0)
  {
	return finddirectionresult.LEFTCOLLINEAR;
  }
  else if (rightccw == 0.0)
  {
	return finddirectionresult.RIGHTCOLLINEAR;
  }
  else
  {
	return finddirectionresult.WITHIN;
  }
}

//***************************************************************************
//                                                                           
//  segmentintersection()   Find the intersection of an existing segment     
//                          and a segment that is being inserted.  Insert    
//                          a vertex at the intersection, splitting an       
//                          existing subsegment.                             
//                                                                           
//  The segment being inserted connects the apex of splittri to endpoint2.   
//  splitsubseg is the subsegment being split, and MUST adjoin splittri.     
//  Hence, endpoints of the subsegment being split are the origin and        
//  destination of splittri.                                                 
//                                                                           
//  On completion, splittri is a handle having the newly inserted            
//  intersection point as its origin, and endpoint1 as its destination.      
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.segmentintersection(struct mesh m, struct behavior b, struct otri *splittri, struct osub *splitsubseg, GlobalMembersTriangle.REAL * endpoint2)
//#else
void GlobalMembersTriangle.segmentintersection(m, b, splittri, splitsubseg, endpoint2)
mesh m;
behavior b;
otri splittri;
osub splitsubseg;
GlobalMembersTriangle.REAL endpoint2;
//#endif // not ANSI_DECLARATORS

{
  osub opposubseg = new osub();
  GlobalMembersTriangle.REAL endpoint1;
  GlobalMembersTriangle.REAL torg;
  GlobalMembersTriangle.REAL tdest;
  GlobalMembersTriangle.REAL leftvertex;
  GlobalMembersTriangle.REAL rightvertex;
  GlobalMembersTriangle.REAL newvertex;
  insertvertexresult success;
  finddirectionresult collinear;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL ex;
  GlobalMembersTriangle.REAL ey;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL tx;
  GlobalMembersTriangle.REAL ty;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL etx;
  GlobalMembersTriangle.REAL ety;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL split;
  GlobalMembersTriangle.REAL denom;
  int i;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by onext().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by snext().

  // Find the other three segment endpoints. 
  endpoint1 = (GlobalMembersTriangle.REAL) splittri.tri[splittri.orient + 3];
  torg = (GlobalMembersTriangle.REAL) splittri.tri[GlobalMembersTriangle.plus1mod3[splittri.orient] + 3];
  tdest = (GlobalMembersTriangle.REAL) splittri.tri[GlobalMembersTriangle.minus1mod3[splittri.orient] + 3];
  // Segment intersection formulae; see the Antonio reference. 
  tx = tdest[0] - torg[0];
  ty = tdest[1] - torg[1];
  ex = endpoint2[0] - endpoint1[0];
  ey = endpoint2[1] - endpoint1[1];
  etx = torg[0] - endpoint2[0];
  ety = torg[1] - endpoint2[1];
  denom = ty * ex - tx * ey;
  if (denom == 0.0)
  {
	System.out.print("Internal error in segmentintersection():");
	System.out.print("  Attempt to find intersection of parallel segments.\n");
	GlobalMembersTriangle.internalerror();
  }
  split = (ey * etx - ex * ety) / denom;
  // Create the new vertex. 
  newvertex = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.poolalloc(m.vertices);
  // Interpolate its coordinate and attributes. 
  for (i = 0; i < 2 + m.nextras; i++)
  {
	newvertex[i] = torg[i] + split * (tdest[i] - torg[i]);
  }
  ((int)(newvertex))[m.vertexmarkindex] = (* (int)(splitsubseg.ss + 8));
  ((int)(newvertex))[m.vertexmarkindex + 1] = DefineConstantsTriangle.INPUTVERTEX;
  if (b.verbose > 1)
  {
	System.out.printf("  Splitting subsegment (%.12g, %.12g) (%.12g, %.12g) at (%.12g, %.12g).\n", torg[0], torg[1], tdest[0], tdest[1], newvertex[0], newvertex[1]);
  }
  // Insert the intersection vertex.  This should always succeed. 
  success = GlobalMembersTriangle.insertvertex(m, b, newvertex, splittri, splitsubseg, 0, 0);
  if (success != insertvertexresult.SUCCESSFULVERTEX)
  {
	System.out.print("Internal error in segmentintersection():\n");
	System.out.print("  Failure to split a segment.\n");
	GlobalMembersTriangle.internalerror();
  }
  // Record a triangle whose origin is the new vertex. 
  ((GlobalMembersTriangle.REAL ** *)(newvertex))[m.vertex2triindex] = (GlobalMembersTriangle.REAL)((int) splittri.tri | (int) splittri.orient);
  if (m.steinerleft > 0)
  {
	m.steinerleft--;
  }

  // Divide the segment into two, and correct the segment endpoints. 
  splitsubseg.ssorient = 1 - splitsubseg.ssorient;
  sptr = splitsubseg.ss[splitsubseg.ssorient];
  (opposubseg).ssorient = (int)((int)(sptr) & (int) 1l);
  (opposubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
  splitsubseg.ss[splitsubseg.ssorient] = (GlobalMembersTriangle.REAL) m.dummysub;
  (opposubseg).ss[(opposubseg).ssorient] = (GlobalMembersTriangle.REAL) m.dummysub;
  do
  {
	splitsubseg.ss[4 + splitsubseg.ssorient] = (GlobalMembersTriangle.REAL) newvertex;
	sptr = splitsubseg.ss[1 - splitsubseg.ssorient];
	splitsubseg.ssorient = (int)((int)(sptr) & (int) 1l);
	splitsubseg.ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
  } while (splitsubseg.ss != m.dummysub);
  do
  {
	(opposubseg).ss[4 + (opposubseg).ssorient] = (GlobalMembersTriangle.REAL) newvertex;
	sptr = (opposubseg).ss[1 - (opposubseg).ssorient];
	(opposubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(opposubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
  } while (opposubseg.ss != m.dummysub);

  // Inserting the vertex may have caused edge flips.  We wish to rediscover 
  //   the edge connecting endpoint1 to the new intersection vertex.         
  collinear = GlobalMembersTriangle.finddirection(m, b, splittri, endpoint1);
  rightvertex = (GlobalMembersTriangle.REAL) splittri.tri[GlobalMembersTriangle.minus1mod3[splittri.orient] + 3];
  leftvertex = (GlobalMembersTriangle.REAL) splittri.tri[splittri.orient + 3];
  if ((leftvertex[0] == endpoint1[0]) && (leftvertex[1] == endpoint1[1]))
  {
	splittri.orient = GlobalMembersTriangle.minus1mod3[splittri.orient];
	ptr = splittri.tri[splittri.orient];
	splittri.orient = (int)((int)(ptr) & (int) 3l);
	splittri.tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int) splittri.orient);
	;
	;
  }
  else if ((rightvertex[0] != endpoint1[0]) || (rightvertex[1] != endpoint1[1]))
  {
	System.out.print("Internal error in segmentintersection():\n");
	System.out.print("  Topological inconsistency after splitting a segment.\n");
	GlobalMembersTriangle.internalerror();
  }
  // `splittri' should have destination endpoint1. 
}

//***************************************************************************
//                                                                           
//  scoutsegment()   Scout the first triangle on the path from one endpoint  
//                   to another, and check for completion (reaching the      
//                   second endpoint), a collinear vertex, or the            
//                   intersection of two segments.                           
//                                                                           
//  Returns one if the entire segment is successfully inserted, and zero if  
//  the job must be finished by conformingedge() or constrainededge().       
//                                                                           
//  If the first triangle on the path has the second endpoint as its         
//  destination or apex, a subsegment is inserted and the job is done.       
//                                                                           
//  If the first triangle on the path has a destination or apex that lies on 
//  the segment, a subsegment is inserted connecting the first endpoint to   
//  the collinear vertex, and the search is continued from the collinear     
//  vertex.                                                                  
//                                                                           
//  If the first triangle on the path has a subsegment opposite its origin,  
//  then there is a segment that intersects the segment being inserted.      
//  Their intersection vertex is inserted, splitting the subsegment.         
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int GlobalMembersTriangle.scoutsegment(struct mesh m, struct behavior b, struct otri searchtri, GlobalMembersTriangle.REAL endpoint2, int newmark)
//#else
int GlobalMembersTriangle.scoutsegment(m, b, searchtri, endpoint2, newmark)
mesh m;
behavior b;
otri searchtri;
GlobalMembersTriangle.REAL endpoint2;
int newmark;
//#endif // not ANSI_DECLARATORS

{
  otri crosstri = new otri();
  osub crosssubseg = new osub();
  GlobalMembersTriangle.REAL leftvertex;
  GlobalMembersTriangle.REAL rightvertex;
  finddirectionresult collinear;
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  collinear = GlobalMembersTriangle.finddirection(m, b, searchtri, endpoint2);
  rightvertex = (GlobalMembersTriangle.REAL) searchtri.tri[GlobalMembersTriangle.minus1mod3[searchtri.orient] + 3];
  leftvertex = (GlobalMembersTriangle.REAL) searchtri.tri[searchtri.orient + 3];
  if (((leftvertex[0] == endpoint2[0]) && (leftvertex[1] == endpoint2[1])) || ((rightvertex[0] == endpoint2[0]) && (rightvertex[1] == endpoint2[1])))
  {
	// The segment is already an edge in the mesh. 
	if ((leftvertex[0] == endpoint2[0]) && (leftvertex[1] == endpoint2[1]))
	{
	  searchtri.orient = GlobalMembersTriangle.minus1mod3[searchtri.orient];
	}
	// Insert a subsegment, if there isn't already one there. 
	GlobalMembersTriangle.insertsubseg(m, b, searchtri, newmark);
	return 1;
	}
  else if (collinear == finddirectionresult.LEFTCOLLINEAR)
  {
	// We've collided with a vertex between the segment's endpoints. 
	// Make the collinear vertex be the triangle's origin. 
	searchtri.orient = GlobalMembersTriangle.minus1mod3[searchtri.orient];
	GlobalMembersTriangle.insertsubseg(m, b, searchtri, newmark);
	// Insert the remainder of the segment. 
	return GlobalMembersTriangle.scoutsegment(m, b, searchtri, endpoint2, newmark);
  }
  else if (collinear == finddirectionresult.RIGHTCOLLINEAR)
  {
	// We've collided with a vertex between the segment's endpoints. 
	GlobalMembersTriangle.insertsubseg(m, b, searchtri, newmark);
	// Make the collinear vertex be the triangle's origin. 
	searchtri.orient = GlobalMembersTriangle.plus1mod3[searchtri.orient];
	// Insert the remainder of the segment. 
	return GlobalMembersTriangle.scoutsegment(m, b, searchtri, endpoint2, newmark);
  }
  else
  {
	(crosstri).tri = searchtri.tri;
	(crosstri).orient = GlobalMembersTriangle.plus1mod3[searchtri.orient];
	sptr = (GlobalMembersTriangle.REAL)(crosstri).tri[6 + (crosstri).orient];
	(crosssubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	(crosssubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	// Check for a crossing segment. 
	if (crosssubseg.ss == m.dummysub)
	{
	  return 0;
	}
	else
	{
	  // Insert a vertex at the intersection. 
	  GlobalMembersTriangle.segmentintersection(m, b, crosstri, crosssubseg, endpoint2);
	  searchtri.tri = (crosstri).tri;
	  searchtri.orient = (crosstri).orient;
	  GlobalMembersTriangle.insertsubseg(m, b, searchtri, newmark);
	  // Insert the remainder of the segment. 
	  return GlobalMembersTriangle.scoutsegment(m, b, searchtri, endpoint2, newmark);
	}
  }
}

//***************************************************************************
//                                                                           
//  conformingedge()   Force a segment into a conforming Delaunay            
//                     triangulation by inserting a vertex at its midpoint,  
//                     and recursively forcing in the two half-segments if   
//                     necessary.                                            
//                                                                           
//  Generates a sequence of subsegments connecting `endpoint1' to            
//  `endpoint2'.  `newmark' is the boundary marker of the segment, assigned  
//  to each new splitting vertex and subsegment.                             
//                                                                           
//  Note that conformingedge() does not always maintain the conforming       
//  Delaunay property.  Once inserted, segments are locked into place;       
//  vertices inserted later (to force other segments in) may render these    
//  fixed segments non-Delaunay.  The conforming Delaunay property will be   
//  restored by enforcequality() by splitting encroached subsegments.        
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.conformingedge(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL endpoint1, GlobalMembersTriangle.REAL endpoint2, int newmark)
//#else
void GlobalMembersTriangle.conformingedge(m, b, endpoint1, endpoint2, newmark)
mesh m;
behavior b;
GlobalMembersTriangle.REAL endpoint1;
GlobalMembersTriangle.REAL endpoint2;
int newmark;
//#endif // not ANSI_DECLARATORS

{
  otri searchtri1 = new otri();
  otri searchtri2 = new otri();
  osub brokensubseg = new osub();
  GlobalMembersTriangle.REAL newvertex;
  GlobalMembersTriangle.REAL midvertex1;
  GlobalMembersTriangle.REAL midvertex2;
  insertvertexresult success;
  int i;
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  if (b.verbose > 2)
  {
	System.out.print("Forcing segment into triangulation by recursive splitting:\n");
	System.out.printf("  (%.12g, %.12g) (%.12g, %.12g)\n", endpoint1[0], endpoint1[1], endpoint2[0], endpoint2[1]);
  }
  // Create a new vertex to insert in the middle of the segment. 
  newvertex = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.poolalloc(m.vertices);
  // Interpolate coordinates and attributes. 
  for (i = 0; i < 2 + m.nextras; i++)
  {
	newvertex[i] = 0.5 * (endpoint1[i] + endpoint2[i]);
  }
  ((int)(newvertex))[m.vertexmarkindex] = newmark;
  ((int)(newvertex))[m.vertexmarkindex + 1] = DefineConstantsTriangle.SEGMENTVERTEX;
  // No known triangle to search from. 
  searchtri1.tri = m.dummytri;
  // Attempt to insert the new vertex. 
  success = GlobalMembersTriangle.insertvertex(m, b, newvertex, searchtri1, (osub) null, 0, 0);
  if (success == insertvertexresult.DUPLICATEVERTEX)
  {
	if (b.verbose > 2)
	{
	  System.out.printf("  Segment intersects existing vertex (%.12g, %.12g).\n", newvertex[0], newvertex[1]);
	}
	// Use the vertex that's already there. 
	GlobalMembersTriangle.vertexdealloc(m, newvertex);
	newvertex = (GlobalMembersTriangle.REAL)(searchtri1).tri[GlobalMembersTriangle.plus1mod3[(searchtri1).orient] + 3];
	}
  else
  {
	if (success == insertvertexresult.VIOLATINGVERTEX)
	{
	  if (b.verbose > 2)
	  {
		System.out.printf("  Two segments intersect at (%.12g, %.12g).\n", newvertex[0], newvertex[1]);
	  }
	  // By fluke, we've landed right on another segment.  Split it. 
	  sptr = (GlobalMembersTriangle.REAL)(searchtri1).tri[6 + (searchtri1).orient];
	  (brokensubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (brokensubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  success = GlobalMembersTriangle.insertvertex(m, b, newvertex, searchtri1, brokensubseg, 0, 0);
	  if (success != insertvertexresult.SUCCESSFULVERTEX)
	  {
		System.out.print("Internal error in conformingedge():\n");
		System.out.print("  Failure to split a segment.\n");
		GlobalMembersTriangle.internalerror();
	  }
	}
	// The vertex has been inserted successfully. 
	if (m.steinerleft > 0)
	{
	  m.steinerleft--;
	}
  }
  (searchtri2).tri = (searchtri1).tri;
  (searchtri2).orient = (searchtri1).orient;
  // `searchtri1' and `searchtri2' are fastened at their origins to         
  //   `newvertex', and will be directed toward `endpoint1' and `endpoint2' 
  //   respectively.  First, we must get `searchtri2' out of the way so it  
  //   won't be invalidated during the insertion of the first half of the   
  //   segment.                                                             
  GlobalMembersTriangle.finddirection(m, b, searchtri2, endpoint2);
  if (!GlobalMembersTriangle.scoutsegment(m, b, searchtri1, endpoint1, newmark))
  {
	// The origin of searchtri1 may have changed if a collision with an 
	//   intervening vertex on the segment occurred.                    
	midvertex1 = (GlobalMembersTriangle.REAL)(searchtri1).tri[GlobalMembersTriangle.plus1mod3[(searchtri1).orient] + 3];
	GlobalMembersTriangle.conformingedge(m, b, midvertex1, endpoint1, newmark);
  }
  if (!GlobalMembersTriangle.scoutsegment(m, b, searchtri2, endpoint2, newmark))
  {
	// The origin of searchtri2 may have changed if a collision with an 
	//   intervening vertex on the segment occurred.                    
	midvertex2 = (GlobalMembersTriangle.REAL)(searchtri2).tri[GlobalMembersTriangle.plus1mod3[(searchtri2).orient] + 3];
	GlobalMembersTriangle.conformingedge(m, b, midvertex2, endpoint2, newmark);
  }
}

//#endif // not CDT_ONLY
//#endif // not REDUCED

//***************************************************************************
//                                                                           
//  delaunayfixup()   Enforce the Delaunay condition at an edge, fanning out 
//                    recursively from an existing vertex.  Pay special      
//                    attention to stacking inverted triangles.              
//                                                                           
//  This is a support routine for inserting segments into a constrained      
//  Delaunay triangulation.                                                  
//                                                                           
//  The origin of fixuptri is treated as if it has just been inserted, and   
//  the local Delaunay condition needs to be enforced.  It is only enforced  
//  in one sector, however, that being the angular range defined by          
//  fixuptri.                                                                
//                                                                           
//  This routine also needs to make decisions regarding the "stacking" of    
//  triangles.  (Read the description of constrainededge() below before      
//  reading on here, so you understand the algorithm.)  If the position of   
//  the new vertex (the origin of fixuptri) indicates that the vertex before 
//  it on the polygon is a reflex vertex, then "stack" the triangle by       
//  doing nothing.  (fixuptri is an inverted triangle, which is how stacked  
//  triangles are identified.)                                               
//                                                                           
//  Otherwise, check whether the vertex before that was a reflex vertex.     
//  If so, perform an edge flip, thereby eliminating an inverted triangle    
//  (popping it off the stack).  The edge flip may result in the creation    
//  of a new inverted triangle, depending on whether or not the new vertex   
//  is visible to the vertex three edges behind on the polygon.              
//                                                                           
//  If neither of the two vertices behind the new vertex are reflex          
//  vertices, fixuptri and fartri, the triangle opposite it, are not         
//  inverted; hence, ensure that the edge between them is locally Delaunay.  
//                                                                           
//  `leftside' indicates whether or not fixuptri is to the left of the       
//  segment being inserted.  (Imagine that the segment is pointing up from   
//  endpoint1 to endpoint2.)                                                 
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.delaunayfixup(struct mesh m, struct behavior b, struct otri *fixuptri, int leftside)
//#else
void GlobalMembersTriangle.delaunayfixup(m, b, fixuptri, leftside)
mesh m;
behavior b;
otri fixuptri;
int leftside;
//#endif // not ANSI_DECLARATORS

{
  otri neartri = new otri();
  otri fartri = new otri();
  osub faredge = new osub();
  GlobalMembersTriangle.REAL nearvertex;
  GlobalMembersTriangle.REAL leftvertex;
  GlobalMembersTriangle.REAL rightvertex;
  GlobalMembersTriangle.REAL farvertex;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  (neartri).tri = fixuptri.tri;
  (neartri).orient = GlobalMembersTriangle.plus1mod3[fixuptri.orient];
  ptr = (neartri).tri[(neartri).orient];
  (fartri).orient = (int)((int)(ptr) & (int) 3l);
  (fartri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(fartri).orient);
  ;
  // Check if the edge opposite the origin of fixuptri can be flipped. 
  if (fartri.tri == m.dummytri)
  {
	return;
  }
  sptr = (GlobalMembersTriangle.REAL)(neartri).tri[6 + (neartri).orient];
  (faredge).ssorient = (int)((int)(sptr) & (int) 1l);
  (faredge).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
  if (faredge.ss != m.dummysub)
  {
	return;
  }
  // Find all the relevant vertices. 
  nearvertex = (GlobalMembersTriangle.REAL)(neartri).tri[(neartri).orient + 3];
  leftvertex = (GlobalMembersTriangle.REAL)(neartri).tri[GlobalMembersTriangle.plus1mod3[(neartri).orient] + 3];
  rightvertex = (GlobalMembersTriangle.REAL)(neartri).tri[GlobalMembersTriangle.minus1mod3[(neartri).orient] + 3];
  farvertex = (GlobalMembersTriangle.REAL)(fartri).tri[(fartri).orient + 3];
  // Check whether the previous polygon vertex is a reflex vertex. 
  if (leftside != 0)
  {
	if (GlobalMembersTriangle.counterclockwise(m, b, nearvertex, leftvertex, farvertex) <= 0.0)
	{
	  // leftvertex is a reflex vertex too.  Nothing can 
	  //   be done until a convex section is found.      
	  return;
	}
	}
  else
  {
	if (GlobalMembersTriangle.counterclockwise(m, b, farvertex, rightvertex, nearvertex) <= 0.0)
	{
	  // rightvertex is a reflex vertex too.  Nothing can 
	  //   be done until a convex section is found.       
	  return;
	}
  }
  if (GlobalMembersTriangle.counterclockwise(m, b, rightvertex, leftvertex, farvertex) > 0.0)
  {
	// fartri is not an inverted triangle, and farvertex is not a reflex 
	//   vertex.  As there are no reflex vertices, fixuptri isn't an     
	//   inverted triangle, either.  Hence, test the edge between the    
	//   triangles to ensure it is locally Delaunay.                     
	if (GlobalMembersTriangle.incircle(m, b, leftvertex, farvertex, rightvertex, nearvertex) <= 0.0)
	{
	  return;
	}
	// Not locally Delaunay; go on to an edge flip. 
  } // else fartri is inverted; remove it from the stack by flipping.
  GlobalMembersTriangle.flip(m, b, neartri);
  fixuptri.orient = GlobalMembersTriangle.minus1mod3[fixuptri.orient];
  // Recursively process the two triangles that result from the flip. 
  GlobalMembersTriangle.delaunayfixup(m, b, fixuptri, leftside);
  GlobalMembersTriangle.delaunayfixup(m, b, fartri, leftside);
}

//***************************************************************************
//                                                                           
//  constrainededge()   Force a segment into a constrained Delaunay          
//                      triangulation by deleting the triangles it           
//                      intersects, and triangulating the polygons that      
//                      form on each side of it.                             
//                                                                           
//  Generates a single subsegment connecting `endpoint1' to `endpoint2'.     
//  The triangle `starttri' has `endpoint1' as its origin.  `newmark' is the 
//  boundary marker of the segment.                                          
//                                                                           
//  To insert a segment, every triangle whose interior intersects the        
//  segment is deleted.  The union of these deleted triangles is a polygon   
//  (which is not necessarily monotone, but is close enough), which is       
//  divided into two polygons by the new segment.  This routine's task is    
//  to generate the Delaunay triangulation of these two polygons.            
//                                                                           
//  You might think of this routine's behavior as a two-step process.  The   
//  first step is to walk from endpoint1 to endpoint2, flipping each edge    
//  encountered.  This step creates a fan of edges connected to endpoint1,   
//  including the desired edge to endpoint2.  The second step enforces the   
//  Delaunay condition on each side of the segment in an incremental manner: 
//  proceeding along the polygon from endpoint1 to endpoint2 (this is done   
//  independently on each side of the segment), each vertex is "enforced"    
//  as if it had just been inserted, but affecting only the previous         
//  vertices.  The result is the same as if the vertices had been inserted   
//  in the order they appear on the polygon, so the result is Delaunay.      
//                                                                           
//  In truth, constrainededge() interleaves these two steps.  The procedure  
//  walks from endpoint1 to endpoint2, and each time an edge is encountered  
//  and flipped, the newly exposed vertex (at the far end of the flipped     
//  edge) is "enforced" upon the previously flipped edges, usually affecting 
//  only one side of the polygon (depending upon which side of the segment   
//  the vertex falls on).                                                    
//                                                                           
//  The algorithm is complicated by the need to handle polygons that are not 
//  convex.  Although the polygon is not necessarily monotone, it can be     
//  triangulated in a manner similar to the stack-based algorithms for       
//  monotone polygons.  For each reflex vertex (local concavity) of the      
//  polygon, there will be an inverted triangle formed by one of the edge    
//  flips.  (An inverted triangle is one with negative area - that is, its   
//  vertices are arranged in clockwise order - and is best thought of as a   
//  wrinkle in the fabric of the mesh.)  Each inverted triangle can be       
//  thought of as a reflex vertex pushed on the stack, waiting to be fixed   
//  later.                                                                   
//                                                                           
//  A reflex vertex is popped from the stack when a vertex is inserted that  
//  is visible to the reflex vertex.  (However, if the vertex behind the     
//  reflex vertex is not visible to the reflex vertex, a new inverted        
//  triangle will take its place on the stack.)  These details are handled   
//  by the delaunayfixup() routine above.                                    
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.constrainededge(struct mesh m, struct behavior b, struct otri *starttri, GlobalMembersTriangle.REAL endpoint2, int newmark)
//#else
void GlobalMembersTriangle.constrainededge(m, b, starttri, endpoint2, newmark)
mesh m;
behavior b;
otri starttri;
GlobalMembersTriangle.REAL endpoint2;
int newmark;
//#endif // not ANSI_DECLARATORS

{
  otri fixuptri = new otri();
  otri fixuptri2 = new otri();
  osub crosssubseg = new osub();
  GlobalMembersTriangle.REAL endpoint1;
  GlobalMembersTriangle.REAL farvertex;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL area;
  int collision;
  int done;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym() and oprev().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  endpoint1 = (GlobalMembersTriangle.REAL) starttri.tri[GlobalMembersTriangle.plus1mod3[starttri.orient] + 3];
  (fixuptri).tri = starttri.tri;
  (fixuptri).orient = GlobalMembersTriangle.plus1mod3[starttri.orient];
  GlobalMembersTriangle.flip(m, b, fixuptri);
  // `collision' indicates whether we have found a vertex directly 
  //   between endpoint1 and endpoint2.                            
  collision = 0;
  done = 0;
  do
  {
	farvertex = (GlobalMembersTriangle.REAL)(fixuptri).tri[GlobalMembersTriangle.plus1mod3[(fixuptri).orient] + 3];
	// `farvertex' is the extreme point of the polygon we are "digging" 
	//   to get from endpoint1 to endpoint2.                           
	if ((farvertex[0] == endpoint2[0]) && (farvertex[1] == endpoint2[1]))
	{
	  ptr = (fixuptri).tri[(fixuptri).orient];
	  (fixuptri2).orient = (int)((int)(ptr) & (int) 3l);
	  (fixuptri2).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(fixuptri2).orient);
	  ;
	  (fixuptri2).orient = GlobalMembersTriangle.plus1mod3[(fixuptri2).orient];
	  ;
	  // Enforce the Delaunay condition around endpoint2. 
	  GlobalMembersTriangle.delaunayfixup(m, b, fixuptri, 0);
	  GlobalMembersTriangle.delaunayfixup(m, b, fixuptri2, 1);
	  done = 1;
	}
	else
	{
	  // Check whether farvertex is to the left or right of the segment 
	  //   being inserted, to decide which edge of fixuptri to dig      
	  //   through next.                                                
	  area = GlobalMembersTriangle.counterclockwise(m, b, endpoint1, endpoint2, farvertex);
	  if (area == 0.0)
	  {
		// We've collided with a vertex between endpoint1 and endpoint2. 
		collision = 1;
		ptr = (fixuptri).tri[(fixuptri).orient];
		(fixuptri2).orient = (int)((int)(ptr) & (int) 3l);
		(fixuptri2).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(fixuptri2).orient);
		;
		(fixuptri2).orient = GlobalMembersTriangle.plus1mod3[(fixuptri2).orient];
		;
		// Enforce the Delaunay condition around farvertex. 
		GlobalMembersTriangle.delaunayfixup(m, b, fixuptri, 0);
		GlobalMembersTriangle.delaunayfixup(m, b, fixuptri2, 1);
		done = 1;
	  }
	  else
	  {
		if (area > 0.0) // farvertex is to the left of the segment.
		{
		  ptr = (fixuptri).tri[(fixuptri).orient];
		  (fixuptri2).orient = (int)((int)(ptr) & (int) 3l);
		  (fixuptri2).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(fixuptri2).orient);
		  ;
		  (fixuptri2).orient = GlobalMembersTriangle.plus1mod3[(fixuptri2).orient];
		  ;
		  // Enforce the Delaunay condition around farvertex, on the 
		  //   left side of the segment only.                        
		  GlobalMembersTriangle.delaunayfixup(m, b, fixuptri2, 1);
		  // Flip the edge that crosses the segment.  After the edge is 
		  //   flipped, one of its endpoints is the fan vertex, and the 
		  //   destination of fixuptri is the fan vertex.               
		  (fixuptri).orient = GlobalMembersTriangle.minus1mod3[(fixuptri).orient];
		} // farvertex is to the right of the segment.
		else
		{
		  GlobalMembersTriangle.delaunayfixup(m, b, fixuptri, 0);
		  // Flip the edge that crosses the segment.  After the edge is 
		  //   flipped, one of its endpoints is the fan vertex, and the 
		  //   destination of fixuptri is the fan vertex.               
		  ptr = (fixuptri).tri[(fixuptri).orient];
		  (fixuptri).orient = (int)((int)(ptr) & (int) 3l);
		  (fixuptri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(fixuptri).orient);
		  ;
		  (fixuptri).orient = GlobalMembersTriangle.plus1mod3[(fixuptri).orient];
		  ;
		}
		// Check for two intersecting segments. 
		sptr = (GlobalMembersTriangle.REAL)(fixuptri).tri[6 + (fixuptri).orient];
		(crosssubseg).ssorient = (int)((int)(sptr) & (int) 1l);
		(crosssubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		if (crosssubseg.ss == m.dummysub)
		{
		  GlobalMembersTriangle.flip(m, b, fixuptri); // May create inverted triangle at left.
		}
		else
		{
		  // We've collided with a segment between endpoint1 and endpoint2. 
		  collision = 1;
		  // Insert a vertex at the intersection. 
		  GlobalMembersTriangle.segmentintersection(m, b, fixuptri, crosssubseg, endpoint2);
		  done = 1;
		}
	  }
	}
  } while (!done);
  // Insert a subsegment to make the segment permanent. 
  GlobalMembersTriangle.insertsubseg(m, b, fixuptri, newmark);
  // If there was a collision with an interceding vertex, install another 
  //   segment connecting that vertex with endpoint2.                     
  if (collision != 0)
  {
	// Insert the remainder of the segment. 
	if (!GlobalMembersTriangle.scoutsegment(m, b, fixuptri, endpoint2, newmark))
	{
	  GlobalMembersTriangle.constrainededge(m, b, fixuptri, endpoint2, newmark);
	}
  }
}

//***************************************************************************
//                                                                           
//  insertsegment()   Insert a PSLG segment into a triangulation.            
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.insertsegment(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL endpoint1, GlobalMembersTriangle.REAL endpoint2, int newmark)
//#else
void GlobalMembersTriangle.insertsegment(m, b, endpoint1, endpoint2, newmark)
mesh m;
behavior b;
GlobalMembersTriangle.REAL endpoint1;
GlobalMembersTriangle.REAL endpoint2;
int newmark;
//#endif // not ANSI_DECLARATORS

{
  otri searchtri1 = new otri();
  otri searchtri2 = new otri();
  GlobalMembersTriangle.REAL[][] encodedtri;
  GlobalMembersTriangle.REAL checkvertex;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().

  if (b.verbose > 1)
  {
	System.out.printf("  Connecting (%.12g, %.12g) to (%.12g, %.12g).\n", endpoint1[0], endpoint1[1], endpoint2[0], endpoint2[1]);
  }

  // Find a triangle whose origin is the segment's first endpoint. 
  checkvertex = (GlobalMembersTriangle.REAL) null;
  encodedtri = ((GlobalMembersTriangle.REAL ** *)(endpoint1))[m.vertex2triindex];
  if (encodedtri != (GlobalMembersTriangle.REAL) null)
  {
	(searchtri1).orient = (int)((int)(encodedtri) & (int) 3l);
	(searchtri1).tri = (GlobalMembersTriangle.REAL ** *)((int)(encodedtri) ^ (int)(searchtri1).orient);
	checkvertex = (GlobalMembersTriangle.REAL)(searchtri1).tri[GlobalMembersTriangle.plus1mod3[(searchtri1).orient] + 3];
  }
  if (checkvertex != endpoint1)
  {
	// Find a boundary triangle to search from. 
	searchtri1.tri = m.dummytri;
	searchtri1.orient = 0;
	ptr = (searchtri1).tri[(searchtri1).orient];
	(searchtri1).orient = (int)((int)(ptr) & (int) 3l);
	(searchtri1).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(searchtri1).orient);
	;
	// Search for the segment's first endpoint by point location. 
	if (GlobalMembersTriangle.locate(m, b, endpoint1, searchtri1) != locateresult.ONVERTEX)
	{
	  System.out.print("Internal error in insertsegment():  Unable to locate PSLG vertex\n");
	  System.out.printf("  (%.12g, %.12g) in triangulation.\n", endpoint1[0], endpoint1[1]);
	  GlobalMembersTriangle.internalerror();
	}
  }
  // Remember this triangle to improve subsequent point location. 
  (m.recenttri).tri = (searchtri1).tri;
  (m.recenttri).orient = (searchtri1).orient;
  // Scout the beginnings of a path from the first endpoint 
  //   toward the second.                                   
  if (GlobalMembersTriangle.scoutsegment(m, b, searchtri1, endpoint2, newmark))
  {
	// The segment was easily inserted. 
	return;
  }
  // The first endpoint may have changed if a collision with an intervening 
  //   vertex on the segment occurred.                                      
  endpoint1 = (GlobalMembersTriangle.REAL)(searchtri1).tri[GlobalMembersTriangle.plus1mod3[(searchtri1).orient] + 3];

  // Find a triangle whose origin is the segment's second endpoint. 
  checkvertex = (GlobalMembersTriangle.REAL) null;
  encodedtri = ((GlobalMembersTriangle.REAL ** *)(endpoint2))[m.vertex2triindex];
  if (encodedtri != (GlobalMembersTriangle.REAL) null)
  {
	(searchtri2).orient = (int)((int)(encodedtri) & (int) 3l);
	(searchtri2).tri = (GlobalMembersTriangle.REAL ** *)((int)(encodedtri) ^ (int)(searchtri2).orient);
	checkvertex = (GlobalMembersTriangle.REAL)(searchtri2).tri[GlobalMembersTriangle.plus1mod3[(searchtri2).orient] + 3];
  }
  if (checkvertex != endpoint2)
  {
	// Find a boundary triangle to search from. 
	searchtri2.tri = m.dummytri;
	searchtri2.orient = 0;
	ptr = (searchtri2).tri[(searchtri2).orient];
	(searchtri2).orient = (int)((int)(ptr) & (int) 3l);
	(searchtri2).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(searchtri2).orient);
	;
	// Search for the segment's second endpoint by point location. 
	if (GlobalMembersTriangle.locate(m, b, endpoint2, searchtri2) != locateresult.ONVERTEX)
	{
	  System.out.print("Internal error in insertsegment():  Unable to locate PSLG vertex\n");
	  System.out.printf("  (%.12g, %.12g) in triangulation.\n", endpoint2[0], endpoint2[1]);
	  GlobalMembersTriangle.internalerror();
	}
  }
  // Remember this triangle to improve subsequent point location. 
  (m.recenttri).tri = (searchtri2).tri;
  (m.recenttri).orient = (searchtri2).orient;
  // Scout the beginnings of a path from the second endpoint 
  //   toward the first.                                     
  if (GlobalMembersTriangle.scoutsegment(m, b, searchtri2, endpoint1, newmark))
  {
	// The segment was easily inserted. 
	return;
  }
  // The second endpoint may have changed if a collision with an intervening 
  //   vertex on the segment occurred.                                       
  endpoint2 = (GlobalMembersTriangle.REAL)(searchtri2).tri[GlobalMembersTriangle.plus1mod3[(searchtri2).orient] + 3];

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
  if (b.splitseg != 0)
  {
	// Insert vertices to force the segment into the triangulation. 
	GlobalMembersTriangle.conformingedge(m, b, endpoint1, endpoint2, newmark);
  }
  else
  {
//#endif // not CDT_ONLY
//#endif // not REDUCED
	// Insert the segment directly into the triangulation. 
	GlobalMembersTriangle.constrainededge(m, b, searchtri1, endpoint2, newmark);
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
  }
//#endif // not CDT_ONLY
//#endif // not REDUCED
}

//***************************************************************************
//                                                                           
//  markhull()   Cover the convex hull of a triangulation with subsegments.  
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.markhull(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.markhull(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri hulltri = new otri();
  otri nexttri = new otri();
  otri starttri = new otri();
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym() and oprev().

  // Find a triangle handle on the hull. 
  hulltri.tri = m.dummytri;
  hulltri.orient = 0;
  ptr = (hulltri).tri[(hulltri).orient];
  (hulltri).orient = (int)((int)(ptr) & (int) 3l);
  (hulltri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(hulltri).orient);
  ;
  // Remember where we started so we know when to stop. 
  (starttri).tri = (hulltri).tri;
  (starttri).orient = (hulltri).orient;
  // Go once counterclockwise around the convex hull. 
  do
  {
	// Create a subsegment if there isn't already one here. 
	GlobalMembersTriangle.insertsubseg(m, b, hulltri, 1);
	// To find the next hull edge, go clockwise around the next vertex. 
	(hulltri).orient = GlobalMembersTriangle.plus1mod3[(hulltri).orient];
	ptr = (hulltri).tri[(hulltri).orient];
	(nexttri).orient = (int)((int)(ptr) & (int) 3l);
	(nexttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(nexttri).orient);
	;
	(nexttri).orient = GlobalMembersTriangle.plus1mod3[(nexttri).orient];
	;
	while (nexttri.tri != m.dummytri)
	{
	  (hulltri).tri = (nexttri).tri;
	  (hulltri).orient = (nexttri).orient;
	  ptr = (hulltri).tri[(hulltri).orient];
	  (nexttri).orient = (int)((int)(ptr) & (int) 3l);
	  (nexttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(nexttri).orient);
	  ;
	  (nexttri).orient = GlobalMembersTriangle.plus1mod3[(nexttri).orient];
	  ;
	}
  } while (!(((hulltri).tri == (starttri).tri) && ((hulltri).orient == (starttri).orient)));
}

//***************************************************************************
//                                                                           
//  formskeleton()   Create the segments of a triangulation, including PSLG  
//                   segments and edges on the convex hull.                  
//                                                                           
//  The PSLG segments are read from a .poly file.  The return value is the   
//  number of segments in the file.                                          
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.formskeleton(struct mesh m, struct behavior b, int segmentlist, int segmentmarkerlist, int numberofsegments)
//#else
void GlobalMembersTriangle.formskeleton(m, b, segmentlist, segmentmarkerlist, numberofsegments)
mesh m;
behavior b;
int segmentlist;
int segmentmarkerlist;
int numberofsegments;
//#endif // not ANSI_DECLARATORS


//#else
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.formskeleton(struct mesh m, struct behavior b, FILE polyfile, char polyfilename)
//#else
void GlobalMembersTriangle.formskeleton(m, b, polyfile, polyfilename)
mesh m;
behavior b;
FILE polyfile;
String polyfilename;
//#endif // not ANSI_DECLARATORS

//#endif // not TRILIBRARY

{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  String polyfilename = new String(new char[6]);
  int index;
//#else
  String inputline = new String(new char[DefineConstantsTriangle.INPUTLINESIZE]);
  String stringptr;
//#endif // not TRILIBRARY
  GlobalMembersTriangle.REAL endpoint1;
  GlobalMembersTriangle.REAL endpoint2;
  int segmentmarkers;
  int end1;
  int end2;
  int boundmarker;
  int i;

  if (b.poly != 0)
  {
	if (b.quiet == 0)
	{
	  System.out.print("Recovering segments in Delaunay triangulation.\n");
	}
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	polyfilename = "input";
	m.insegments = numberofsegments;
	segmentmarkers = segmentmarkerlist != (int) null;
	index = 0;
//#else
	// Read the segments from a .poly file. 
	// Read number of segments and number of boundary markers. 
	stringptr = GlobalMembersTriangle.readline(inputline, polyfile, polyfilename);
	m.insegments = (int) strtol(stringptr, stringptr, 0);
	stringptr = GlobalMembersTriangle.findfield(stringptr);
	if ( stringptr.equals('\0'))
	{
	  segmentmarkers = 0;
	}
	else
	{
	  segmentmarkers = (int) strtol(stringptr, stringptr, 0);
	}
//#endif // not TRILIBRARY
	// If the input vertices are collinear, there is no triangulation, 
	//   so don't try to insert segments.                              
	if (m.triangles.items == 0)
	{
	  return;
	}

	// If segments are to be inserted, compute a mapping 
	//   from vertices to triangles.                     
	if (m.insegments > 0)
	{
	  GlobalMembersTriangle.makevertexmap(m, b);
	  if (b.verbose != 0)
	  {
		System.out.print("  Recovering PSLG segments.\n");
	  }
	}

	boundmarker = 0;
	// Read and insert the segments. 
	for (i = 0; i < m.insegments; i++)
	{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	  end1 = segmentlist[index++];
	  end2 = segmentlist[index++];
	  if (segmentmarkers != 0)
	  {
		boundmarker = segmentmarkerlist[i];
	  }
//#else
	  stringptr = GlobalMembersTriangle.readline(inputline, polyfile, b.inpolyfilename);
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( stringptr.equals('\0'))
	  {
		System.out.printf("Error:  Segment %d has no endpoints in %s.\n", b.firstnumber + i, polyfilename);
		GlobalMembersTriangle.triexit(1);
	  }
	  else
	  {
		end1 = (int) strtol(stringptr, stringptr, 0);
	  }
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( stringptr.equals('\0'))
	  {
		System.out.printf("Error:  Segment %d is missing its second endpoint in %s.\n", b.firstnumber + i, polyfilename);
		GlobalMembersTriangle.triexit(1);
	  }
	  else
	  {
		end2 = (int) strtol(stringptr, stringptr, 0);
	  }
	  if (segmentmarkers != 0)
	  {
		stringptr = GlobalMembersTriangle.findfield(stringptr);
		if ( stringptr.equals('\0'))
		{
		  boundmarker = 0;
		}
		else
		{
		  boundmarker = (int) strtol(stringptr, stringptr, 0);
		}
	  }
//#endif // not TRILIBRARY
	  if ((end1 < b.firstnumber) || (end1 >= b.firstnumber + m.invertices))
	  {
		if (b.quiet == 0)
		{
		  System.out.printf("Warning:  Invalid first endpoint of segment %d in %s.\n", b.firstnumber + i, polyfilename);
		}
		}
	  else if ((end2 < b.firstnumber) || (end2 >= b.firstnumber + m.invertices))
	  {
		if (b.quiet == 0)
		{
		  System.out.printf("Warning:  Invalid second endpoint of segment %d in %s.\n", b.firstnumber + i, polyfilename);
		}
		}
	  else
	  {
		// Find the vertices numbered `end1' and `end2'. 
		endpoint1 = GlobalMembersTriangle.getvertex(m, b, end1);
		endpoint2 = GlobalMembersTriangle.getvertex(m, b, end2);
		if ((endpoint1[0] == endpoint2[0]) && (endpoint1[1] == endpoint2[1]))
		{
		  if (b.quiet == 0)
		  {
			System.out.printf("Warning:  Endpoints of segment %d are coincident in %s.\n", b.firstnumber + i, polyfilename);
		  }
		  }
		else
		{
		  GlobalMembersTriangle.insertsegment(m, b, endpoint1, endpoint2, boundmarker);
		}
	  }
	}
		}
  else
  {
	m.insegments = 0;
  }
  if (b.convex != 0 || b.poly == 0)
  {
	// Enclose the convex hull with subsegments. 
	if (b.verbose != 0)
	{
	  System.out.print("  Enclosing convex hull with segments.\n");
	}
	GlobalMembersTriangle.markhull(m, b);
  }
}

//*                                                                         *
//*                                                                         *
//******** Segment insertion ends here                               ********

//******** Carving out holes and concavities begins here             ********
//*                                                                         *
//*                                                                         *

//***************************************************************************
//                                                                           
//  infecthull()   Virally infect all of the triangles of the convex hull    
//                 that are not protected by subsegments.  Where there are   
//                 subsegments, set boundary markers as appropriate.         
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.infecthull(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.infecthull(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri hulltri = new otri();
  otri nexttri = new otri();
  otri starttri = new otri();
  osub hullsubseg = new osub();
  GlobalMembersTriangle.REAL[][][][] deadtriangle;
  GlobalMembersTriangle.REAL horg;
  GlobalMembersTriangle.REAL hdest;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  if (b.verbose != 0)
  {
	System.out.print("  Marking concavities (external triangles) for elimination.\n");
  }
  // Find a triangle handle on the hull. 
  hulltri.tri = m.dummytri;
  hulltri.orient = 0;
  ptr = (hulltri).tri[(hulltri).orient];
  (hulltri).orient = (int)((int)(ptr) & (int) 3l);
  (hulltri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(hulltri).orient);
  ;
  // Remember where we started so we know when to stop. 
  (starttri).tri = (hulltri).tri;
  (starttri).orient = (hulltri).orient;
  // Go once counterclockwise around the convex hull. 
  do
  {
	// Ignore triangles that are already infected. 
	if (!(((int)(hulltri).tri[6] & (int) 2l) != 0l))
	{
	  // Is the triangle protected by a subsegment? 
	  sptr = (GlobalMembersTriangle.REAL)(hulltri).tri[6 + (hulltri).orient];
	  (hullsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (hullsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  if (hullsubseg.ss == m.dummysub)
	  {
		// The triangle is not protected; infect it. 
		if (!(((int)(hulltri).tri[6] & (int) 2l) != 0l))
		{
		  (hulltri).tri[6] = (GlobalMembersTriangle.REAL)((int)(hulltri).tri[6] | (int) 2l);
		  deadtriangle = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.poolalloc(m.viri);
		  *deadtriangle = hulltri.tri;
		}
		}
	  else
	  {
		// The triangle is protected; set boundary markers if appropriate. 
		if ((* (int)((hullsubseg).ss + 8)) == 0)
		{
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
//		  * (int *)((hullsubseg).ss + 8) = 1;
		  horg = (GlobalMembersTriangle.REAL)(hulltri).tri[GlobalMembersTriangle.plus1mod3[(hulltri).orient] + 3];
		  hdest = (GlobalMembersTriangle.REAL)(hulltri).tri[GlobalMembersTriangle.minus1mod3[(hulltri).orient] + 3];
		  if (((int)(horg))[m.vertexmarkindex] == 0)
		  {
			((int)(horg))[m.vertexmarkindex] = 1;
		  }
		  if (((int)(hdest))[m.vertexmarkindex] == 0)
		  {
			((int)(hdest))[m.vertexmarkindex] = 1;
		  }
		}
	  }
	}
	// To find the next hull edge, go clockwise around the next vertex. 
	(hulltri).orient = GlobalMembersTriangle.plus1mod3[(hulltri).orient];
	ptr = (hulltri).tri[(hulltri).orient];
	(nexttri).orient = (int)((int)(ptr) & (int) 3l);
	(nexttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(nexttri).orient);
	;
	(nexttri).orient = GlobalMembersTriangle.plus1mod3[(nexttri).orient];
	;
	while (nexttri.tri != m.dummytri)
	{
	  (hulltri).tri = (nexttri).tri;
	  (hulltri).orient = (nexttri).orient;
	  ptr = (hulltri).tri[(hulltri).orient];
	  (nexttri).orient = (int)((int)(ptr) & (int) 3l);
	  (nexttri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(nexttri).orient);
	  ;
	  (nexttri).orient = GlobalMembersTriangle.plus1mod3[(nexttri).orient];
	  ;
	}
  } while (!(((hulltri).tri == (starttri).tri) && ((hulltri).orient == (starttri).orient)));
}

//***************************************************************************
//                                                                           
//  plague()   Spread the virus from all infected triangles to any neighbors 
//             not protected by subsegments.  Delete all infected triangles. 
//                                                                           
//  This is the procedure that actually creates holes and concavities.       
//                                                                           
//  This procedure operates in two phases.  The first phase identifies all   
//  the triangles that will die, and marks them as infected.  They are       
//  marked to ensure that each triangle is added to the virus pool only      
//  once, so the procedure will terminate.                                   
//                                                                           
//  The second phase actually eliminates the infected triangles.  It also    
//  eliminates orphaned vertices.                                            
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.plague(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.plague(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri testtri = new otri();
  otri neighbor = new otri();
  GlobalMembersTriangle.REAL[][][][] virusloop;
  GlobalMembersTriangle.REAL[][][][] deadtriangle;
  osub neighborsubseg = new osub();
  GlobalMembersTriangle.REAL testvertex;
  GlobalMembersTriangle.REAL norg;
  GlobalMembersTriangle.REAL ndest;
  GlobalMembersTriangle.REAL deadorg;
  GlobalMembersTriangle.REAL deaddest;
  GlobalMembersTriangle.REAL deadapex;
  int killorg;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym() and onext().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  if (b.verbose != 0)
  {
	System.out.print("  Marking neighbors of marked triangles.\n");
  }
  // Loop through all the infected triangles, spreading the virus to 
  //   their neighbors, then to their neighbors' neighbors.          
  GlobalMembersTriangle.traversalinit(m.viri);
  virusloop = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.traverse(m.viri);
  while (virusloop != (GlobalMembersTriangle.REAL ** **) null)
  {
	testtri.tri = *virusloop;
	// A triangle is marked as infected by messing with one of its pointers 
	//   to subsegments, setting it to an illegal value.  Hence, we have to 
	//   temporarily uninfect this triangle so that we can examine its      
	//   adjacent subsegments.                                              
	(testtri).tri[6] = (GlobalMembersTriangle.REAL)((int)(testtri).tri[6] & ~ (int) 2l);
	if (b.verbose > 2)
	{
	  // Assign the triangle an orientation for convenience in 
	  //   checking its vertices.                              
	  testtri.orient = 0;
	  deadorg = (GlobalMembersTriangle.REAL)(testtri).tri[GlobalMembersTriangle.plus1mod3[(testtri).orient] + 3];
	  deaddest = (GlobalMembersTriangle.REAL)(testtri).tri[GlobalMembersTriangle.minus1mod3[(testtri).orient] + 3];
	  deadapex = (GlobalMembersTriangle.REAL)(testtri).tri[(testtri).orient + 3];
	  System.out.printf("    Checking (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n", deadorg[0], deadorg[1], deaddest[0], deaddest[1], deadapex[0], deadapex[1]);
	}
	// Check each of the triangle's three neighbors. 
	for (testtri.orient = 0; testtri.orient < 3; testtri.orient++)
	{
	  // Find the neighbor. 
	  ptr = (testtri).tri[(testtri).orient];
	  (neighbor).orient = (int)((int)(ptr) & (int) 3l);
	  (neighbor).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(neighbor).orient);
	  ;
	  // Check for a subsegment between the triangle and its neighbor. 
	  sptr = (GlobalMembersTriangle.REAL)(testtri).tri[6 + (testtri).orient];
	  (neighborsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (neighborsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  // Check if the neighbor is nonexistent or already infected. 
	  if ((neighbor.tri == m.dummytri) || (((int)(neighbor).tri[6] & (int) 2l) != 0l))
	  {
		if (neighborsubseg.ss != m.dummysub)
		{
		  // There is a subsegment separating the triangle from its      
		  //   neighbor, but both triangles are dying, so the subsegment 
		  //   dies too.                                                 
		  GlobalMembersTriangle.subsegdealloc(m, neighborsubseg.ss);
		  if (neighbor.tri != m.dummytri)
		  {
			// Make sure the subsegment doesn't get deallocated again 
			//   later when the infected neighbor is visited.         
			(neighbor).tri[6] = (GlobalMembersTriangle.REAL)((int)(neighbor).tri[6] & ~ (int) 2l);
			(neighbor).tri[6 + (neighbor).orient] = (GlobalMembersTriangle.REAL) m.dummysub;
			(neighbor).tri[6] = (GlobalMembersTriangle.REAL)((int)(neighbor).tri[6] | (int) 2l);
		  }
		}
		  } // The neighbor exists and is not infected.
	  else
	  {
		if (neighborsubseg.ss == m.dummysub)
		{
		  // There is no subsegment protecting the neighbor, so 
		  //   the neighbor becomes infected.                   
		  if (b.verbose > 2)
		  {
			deadorg = (GlobalMembersTriangle.REAL)(neighbor).tri[GlobalMembersTriangle.plus1mod3[(neighbor).orient] + 3];
			deaddest = (GlobalMembersTriangle.REAL)(neighbor).tri[GlobalMembersTriangle.minus1mod3[(neighbor).orient] + 3];
			deadapex = (GlobalMembersTriangle.REAL)(neighbor).tri[(neighbor).orient + 3];
			System.out.printf("    Marking (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n", deadorg[0], deadorg[1], deaddest[0], deaddest[1], deadapex[0], deadapex[1]);
		  }
		  (neighbor).tri[6] = (GlobalMembersTriangle.REAL)((int)(neighbor).tri[6] | (int) 2l);
		  // Ensure that the neighbor's neighbors will be infected. 
		  deadtriangle = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.poolalloc(m.viri);
		  *deadtriangle = neighbor.tri;
		  } // The neighbor is protected by a subsegment.
		else
		{
		  // Remove this triangle from the subsegment. 
		  (neighborsubseg).ss[6 + (neighborsubseg).ssorient] = (GlobalMembersTriangle.REAL) m.dummytri;
		  // The subsegment becomes a boundary.  Set markers accordingly. 
		  if ((* (int)((neighborsubseg).ss + 8)) == 0)
		  {
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
//			* (int *)((neighborsubseg).ss + 8) = 1;
		  }
		  norg = (GlobalMembersTriangle.REAL)(neighbor).tri[GlobalMembersTriangle.plus1mod3[(neighbor).orient] + 3];
		  ndest = (GlobalMembersTriangle.REAL)(neighbor).tri[GlobalMembersTriangle.minus1mod3[(neighbor).orient] + 3];
		  if (((int)(norg))[m.vertexmarkindex] == 0)
		  {
			((int)(norg))[m.vertexmarkindex] = 1;
		  }
		  if (((int)(ndest))[m.vertexmarkindex] == 0)
		  {
			((int)(ndest))[m.vertexmarkindex] = 1;
		  }
		}
	  }
	}
	// Remark the triangle as infected, so it doesn't get added to the 
	//   virus pool again.                                             
	(testtri).tri[6] = (GlobalMembersTriangle.REAL)((int)(testtri).tri[6] | (int) 2l);
	virusloop = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.traverse(m.viri);
  }

  if (b.verbose != 0)
  {
	System.out.print("  Deleting marked triangles.\n");
  }

  GlobalMembersTriangle.traversalinit(m.viri);
  virusloop = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.traverse(m.viri);
  while (virusloop != (GlobalMembersTriangle.REAL ** **) null)
  {
	testtri.tri = *virusloop;

	// Check each of the three corners of the triangle for elimination. 
	//   This is done by walking around each vertex, checking if it is  
	//   still connected to at least one live triangle.                 
	for (testtri.orient = 0; testtri.orient < 3; testtri.orient++)
	{
	  testvertex = (GlobalMembersTriangle.REAL)(testtri).tri[GlobalMembersTriangle.plus1mod3[(testtri).orient] + 3];
	  // Check if the vertex has already been tested. 
	  if (testvertex != (GlobalMembersTriangle.REAL) null)
	  {
		killorg = 1;
		// Mark the corner of the triangle as having been tested. 
		(testtri).tri[GlobalMembersTriangle.plus1mod3[(testtri).orient] + 3] = (GlobalMembersTriangle.REAL) null;
		// Walk counterclockwise about the vertex. 
		(neighbor).tri = (testtri).tri;
		(neighbor).orient = GlobalMembersTriangle.minus1mod3[(testtri).orient];
		ptr = (neighbor).tri[(neighbor).orient];
		(neighbor).orient = (int)((int)(ptr) & (int) 3l);
		(neighbor).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(neighbor).orient);
		;
		;
		// Stop upon reaching a boundary or the starting triangle. 
		while ((neighbor.tri != m.dummytri) && (!(((neighbor).tri == (testtri).tri) && ((neighbor).orient == (testtri).orient))))
		{
		  if ((((int)(neighbor).tri[6] & (int) 2l) != 0l))
		  {
			// Mark the corner of this triangle as having been tested. 
			(neighbor).tri[GlobalMembersTriangle.plus1mod3[(neighbor).orient] + 3] = (GlobalMembersTriangle.REAL) null;
		  }
		  else
		  {
			// A live triangle.  The vertex survives. 
			killorg = 0;
		  }
		  // Walk counterclockwise about the vertex. 
		  (neighbor).orient = GlobalMembersTriangle.minus1mod3[(neighbor).orient];
		  ptr = (neighbor).tri[(neighbor).orient];
		  (neighbor).orient = (int)((int)(ptr) & (int) 3l);
		  (neighbor).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(neighbor).orient);
		  ;
		  ;
		}
		// If we reached a boundary, we must walk clockwise as well. 
		if (neighbor.tri == m.dummytri)
		{
		  // Walk clockwise about the vertex. 
		  ptr = (testtri).tri[(testtri).orient];
		  (neighbor).orient = (int)((int)(ptr) & (int) 3l);
		  (neighbor).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(neighbor).orient);
		  ;
		  (neighbor).orient = GlobalMembersTriangle.plus1mod3[(neighbor).orient];
		  ;
		  // Stop upon reaching a boundary. 
		  while (neighbor.tri != m.dummytri)
		  {
			if ((((int)(neighbor).tri[6] & (int) 2l) != 0l))
			{
			// Mark the corner of this triangle as having been tested. 
			  (neighbor).tri[GlobalMembersTriangle.plus1mod3[(neighbor).orient] + 3] = (GlobalMembersTriangle.REAL) null;
			}
			else
			{
			  // A live triangle.  The vertex survives. 
			  killorg = 0;
			}
			// Walk clockwise about the vertex. 
			ptr = (neighbor).tri[(neighbor).orient];
			(neighbor).orient = (int)((int)(ptr) & (int) 3l);
			(neighbor).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(neighbor).orient);
			;
			(neighbor).orient = GlobalMembersTriangle.plus1mod3[(neighbor).orient];
			;
		  }
		}
		if (killorg != 0)
		{
		  if (b.verbose > 1)
		  {
			System.out.printf("    Deleting vertex (%.12g, %.12g)\n", testvertex[0], testvertex[1]);
		  }
		  ((int)(testvertex))[m.vertexmarkindex + 1] = -32767;
		  m.undeads++;
		}
	  }
	}

	// Record changes in the number of boundary edges, and disconnect 
	//   dead triangles from their neighbors.                         
	for (testtri.orient = 0; testtri.orient < 3; testtri.orient++)
	{
	  ptr = (testtri).tri[(testtri).orient];
	  (neighbor).orient = (int)((int)(ptr) & (int) 3l);
	  (neighbor).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(neighbor).orient);
	  ;
	  if (neighbor.tri == m.dummytri)
	  {
		// There is no neighboring triangle on this edge, so this edge    
		//   is a boundary edge.  This triangle is being deleted, so this 
		//   boundary edge is deleted.                                    
		m.hullsize--;
	  }
	  else
	  {
		// Disconnect the triangle from its neighbor. 
		(neighbor).tri[(neighbor).orient] = (GlobalMembersTriangle.REAL) m.dummytri;
		// There is a neighboring triangle on this edge, so this edge 
		//   becomes a boundary edge when this triangle is deleted.   
		m.hullsize++;
	  }
	}
	// Return the dead triangle to the pool of triangles. 
	GlobalMembersTriangle.triangledealloc(m, testtri.tri);
	virusloop = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.traverse(m.viri);
  }
  // Empty the virus pool. 
  GlobalMembersTriangle.poolrestart(m.viri);
}

//***************************************************************************
//                                                                           
//  regionplague()   Spread regional attributes and/or area constraints      
//                   (from a .poly file) throughout the mesh.                
//                                                                           
//  This procedure operates in two phases.  The first phase spreads an       
//  attribute and/or an area constraint through a (segment-bounded) region.  
//  The triangles are marked to ensure that each triangle is added to the    
//  virus pool only once, so the procedure will terminate.                   
//                                                                           
//  The second phase uninfects all infected triangles, returning them to     
//  normal.                                                                  
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
void GlobalMembersTriangle.regionplague(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL attribute, GlobalMembersTriangle.REAL area)
//#else
void GlobalMembersTriangle.regionplague(m, b, attribute, area)
mesh m;
behavior b;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL attribute;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL area;
//#endif // not ANSI_DECLARATORS

{
  otri testtri = new otri();
  otri neighbor = new otri();
  GlobalMembersTriangle.REAL[][][][] virusloop;
  GlobalMembersTriangle.REAL[][][][] regiontri;
  osub neighborsubseg = new osub();
  GlobalMembersTriangle.REAL regionorg;
  GlobalMembersTriangle.REAL regiondest;
  GlobalMembersTriangle.REAL regionapex;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym() and onext().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  if (b.verbose > 1)
  {
	System.out.print("  Marking neighbors of marked triangles.\n");
  }
  // Loop through all the infected triangles, spreading the attribute      
  //   and/or area constraint to their neighbors, then to their neighbors' 
  //   neighbors.                                                          
  GlobalMembersTriangle.traversalinit(m.viri);
  virusloop = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.traverse(m.viri);
  while (virusloop != (GlobalMembersTriangle.REAL ** **) null)
  {
	testtri.tri = *virusloop;
	// A triangle is marked as infected by messing with one of its pointers 
	//   to subsegments, setting it to an illegal value.  Hence, we have to 
	//   temporarily uninfect this triangle so that we can examine its      
	//   adjacent subsegments.                                              
	(testtri).tri[6] = (GlobalMembersTriangle.REAL)((int)(testtri).tri[6] & ~ (int) 2l);
	if (b.regionattrib != 0)
	{
	  // Set an attribute. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ((GlobalMembersTriangle.REAL)(testtri).tri)[m.elemattribindex + (m.eextras)] = attribute;
	}
	if (b.vararea != 0)
	{
	  // Set an area constraint. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  ((GlobalMembersTriangle.REAL)(testtri).tri)[m.areaboundindex] = area;
	}
	if (b.verbose > 2)
	{
	  // Assign the triangle an orientation for convenience in 
	  //   checking its vertices.                              
	  testtri.orient = 0;
	  regionorg = (GlobalMembersTriangle.REAL)(testtri).tri[GlobalMembersTriangle.plus1mod3[(testtri).orient] + 3];
	  regiondest = (GlobalMembersTriangle.REAL)(testtri).tri[GlobalMembersTriangle.minus1mod3[(testtri).orient] + 3];
	  regionapex = (GlobalMembersTriangle.REAL)(testtri).tri[(testtri).orient + 3];
	  System.out.printf("    Checking (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n", regionorg[0], regionorg[1], regiondest[0], regiondest[1], regionapex[0], regionapex[1]);
	}
	// Check each of the triangle's three neighbors. 
	for (testtri.orient = 0; testtri.orient < 3; testtri.orient++)
	{
	  // Find the neighbor. 
	  ptr = (testtri).tri[(testtri).orient];
	  (neighbor).orient = (int)((int)(ptr) & (int) 3l);
	  (neighbor).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(neighbor).orient);
	  ;
	  // Check for a subsegment between the triangle and its neighbor. 
	  sptr = (GlobalMembersTriangle.REAL)(testtri).tri[6 + (testtri).orient];
	  (neighborsubseg).ssorient = (int)((int)(sptr) & (int) 1l);
	  (neighborsubseg).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
	  // Make sure the neighbor exists, is not already infected, and 
	  //   isn't protected by a subsegment.                          
	  if ((neighbor.tri != m.dummytri) && !(((int)(neighbor).tri[6] & (int) 2l) != 0l) && (neighborsubseg.ss == m.dummysub))
	  {
		if (b.verbose > 2)
		{
		  regionorg = (GlobalMembersTriangle.REAL)(neighbor).tri[GlobalMembersTriangle.plus1mod3[(neighbor).orient] + 3];
		  regiondest = (GlobalMembersTriangle.REAL)(neighbor).tri[GlobalMembersTriangle.minus1mod3[(neighbor).orient] + 3];
		  regionapex = (GlobalMembersTriangle.REAL)(neighbor).tri[(neighbor).orient + 3];
		  System.out.printf("    Marking (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n", regionorg[0], regionorg[1], regiondest[0], regiondest[1], regionapex[0], regionapex[1]);
		}
		// Infect the neighbor. 
		(neighbor).tri[6] = (GlobalMembersTriangle.REAL)((int)(neighbor).tri[6] | (int) 2l);
		// Ensure that the neighbor's neighbors will be infected. 
		regiontri = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.poolalloc(m.viri);
		*regiontri = neighbor.tri;
	  }
	}
	// Remark the triangle as infected, so it doesn't get added to the 
	//   virus pool again.                                             
	(testtri).tri[6] = (GlobalMembersTriangle.REAL)((int)(testtri).tri[6] | (int) 2l);
	virusloop = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.traverse(m.viri);
  }

  // Uninfect all triangles. 
  if (b.verbose > 1)
  {
	System.out.print("  Unmarking marked triangles.\n");
  }
  GlobalMembersTriangle.traversalinit(m.viri);
  virusloop = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.traverse(m.viri);
  while (virusloop != (GlobalMembersTriangle.REAL ** **) null)
  {
	testtri.tri = *virusloop;
	(testtri).tri[6] = (GlobalMembersTriangle.REAL)((int)(testtri).tri[6] & ~ (int) 2l);
	virusloop = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.traverse(m.viri);
  }
  // Empty the virus pool. 
  GlobalMembersTriangle.poolrestart(m.viri);
}

//***************************************************************************
//                                                                           
//  carveholes()   Find the holes and infect them.  Find the area            
//                 constraints and infect them.  Infect the convex hull.     
//                 Spread the infection and kill triangles.  Spread the      
//                 area constraints.                                         
//                                                                           
//  This routine mainly calls other routines to carry out all these          
//  functions.                                                               
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
void GlobalMembersTriangle.carveholes(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL *holelist, int holes, GlobalMembersTriangle.REAL *regionlist, int regions)
//#else
void GlobalMembersTriangle.carveholes(m, b, holelist, holes, regionlist, regions)
mesh m;
behavior b;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL holelist;
int holes;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL regionlist;
int regions;
//#endif // not ANSI_DECLARATORS

{
  otri searchtri = new otri();
  otri triangleloop = new otri();
  otri regiontris;
  GlobalMembersTriangle.REAL[][][][] holetri;
  GlobalMembersTriangle.REAL[][][][] regiontri;
  GlobalMembersTriangle.REAL searchorg;
  GlobalMembersTriangle.REAL searchdest;
  locateresult intersect;
  int i;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().

  if (!(b.quiet != 0 || (b.noholes != 0 && b.convex != 0)))
  {
	System.out.print("Removing unwanted triangles.\n");
	if (b.verbose != 0 && (holes > 0))
	{
	  System.out.print("  Marking holes for elimination.\n");
	}
  }

  if (regions > 0)
  {
	// Allocate storage for the triangles in which region points fall. 
	regiontris = (otri) GlobalMembersTriangle.trimalloc(regions * (int) sizeof(otri));
  }
  else
  {
	regiontris = (otri) null;
  }

  if (((holes > 0) && b.noholes == 0) || !b.convex || (regions > 0))
  {
	// Initialize a pool of viri to be used for holes, concavities, 
	//   regional attributes, and/or regional area constraints.     
	GlobalMembersTriangle.poolinit(m.viri, sizeof(GlobalMembersTriangle.REAL ** *), DefineConstantsTriangle.VIRUSPERBLOCK, DefineConstantsTriangle.VIRUSPERBLOCK, 0);
  }

  if (b.convex == 0)
  {
	// Mark as infected any unprotected triangles on the boundary. 
	//   This is one way by which concavities are created.         
	GlobalMembersTriangle.infecthull(m, b);
  }

  if ((holes > 0) && b.noholes == 0)
  {
	// Infect each triangle in which a hole lies. 
	for (i = 0; i < 2 * holes; i += 2)
	{
	  // Ignore holes that aren't within the bounds of the mesh. 
	  if ((holelist[i] >= m.xmin) && (holelist[i] <= m.xmax) && (holelist[i + 1] >= m.ymin) && (holelist[i + 1] <= m.ymax))
	  {
		// Start searching from some triangle on the outer boundary. 
		searchtri.tri = m.dummytri;
		searchtri.orient = 0;
		ptr = (searchtri).tri[(searchtri).orient];
		(searchtri).orient = (int)((int)(ptr) & (int) 3l);
		(searchtri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(searchtri).orient);
		;
		// Ensure that the hole is to the left of this boundary edge; 
		//   otherwise, locate() will falsely report that the hole    
		//   falls within the starting triangle.                      
		searchorg = (GlobalMembersTriangle.REAL)(searchtri).tri[GlobalMembersTriangle.plus1mod3[(searchtri).orient] + 3];
		searchdest = (GlobalMembersTriangle.REAL)(searchtri).tri[GlobalMembersTriangle.minus1mod3[(searchtri).orient] + 3];
		if (GlobalMembersTriangle.counterclockwise(m, b, searchorg, searchdest, holelist[i]) > 0.0)
		{
		  // Find a triangle that contains the hole. 
		  intersect = GlobalMembersTriangle.locate(m, b, holelist[i], searchtri);
		  if ((intersect != locateresult.OUTSIDE) && (!(((int)(searchtri).tri[6] & (int) 2l) != 0l)))
		  {
			// Infect the triangle.  This is done by marking the triangle  
			//   as infected and including the triangle in the virus pool. 
			(searchtri).tri[6] = (GlobalMembersTriangle.REAL)((int)(searchtri).tri[6] | (int) 2l);
			holetri = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.poolalloc(m.viri);
			*holetri = searchtri.tri;
		  }
		}
	  }
	}
  }

  // Now, we have to find all the regions BEFORE we carve the holes, because 
  //   locate() won't work when the triangulation is no longer convex.       
  //   (Incidentally, this is the reason why regional attributes and area    
  //   constraints can't be used when refining a preexisting mesh, which     
  //   might not be convex; they can only be used with a freshly             
  //   triangulated PSLG.)                                                   
  if (regions > 0)
  {
	// Find the starting triangle for each region. 
	for (i = 0; i < regions; i++)
	{
	  regiontris[i].tri = m.dummytri;
	  // Ignore region points that aren't within the bounds of the mesh. 
	  if ((regionlist[4 * i] >= m.xmin) && (regionlist[4 * i] <= m.xmax) && (regionlist[4 * i + 1] >= m.ymin) && (regionlist[4 * i + 1] <= m.ymax))
	  {
		// Start searching from some triangle on the outer boundary. 
		searchtri.tri = m.dummytri;
		searchtri.orient = 0;
		ptr = (searchtri).tri[(searchtri).orient];
		(searchtri).orient = (int)((int)(ptr) & (int) 3l);
		(searchtri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(searchtri).orient);
		;
		// Ensure that the region point is to the left of this boundary 
		//   edge; otherwise, locate() will falsely report that the     
		//   region point falls within the starting triangle.           
		searchorg = (GlobalMembersTriangle.REAL)(searchtri).tri[GlobalMembersTriangle.plus1mod3[(searchtri).orient] + 3];
		searchdest = (GlobalMembersTriangle.REAL)(searchtri).tri[GlobalMembersTriangle.minus1mod3[(searchtri).orient] + 3];
		if (GlobalMembersTriangle.counterclockwise(m, b, searchorg, searchdest, regionlist[4 * i]) > 0.0)
		{
		  // Find a triangle that contains the region point. 
		  intersect = GlobalMembersTriangle.locate(m, b, regionlist[4 * i], searchtri);
		  if ((intersect != locateresult.OUTSIDE) && (!(((int)(searchtri).tri[6] & (int) 2l) != 0l)))
		  {
			// Record the triangle for processing after the 
			//   holes have been carved.                    
			(regiontris[i]).tri = (searchtri).tri;
			(regiontris[i]).orient = (searchtri).orient;
		  }
		}
	  }
	}
  }

  if (m.viri.items > 0)
  {
	// Carve the holes and concavities. 
	GlobalMembersTriangle.plague(m, b);
  }
  // The virus pool should be empty now. 

  if (regions > 0)
  {
	if (b.quiet == 0)
	{
	  if (b.regionattrib != 0)
	  {
		if (b.vararea != 0)
		{
		  System.out.print("Spreading regional attributes and area constraints.\n");
		}
		else
		{
		  System.out.print("Spreading regional attributes.\n");
		}
		}
	  else
	  {
		System.out.print("Spreading regional area constraints.\n");
	  }
	}
	if (b.regionattrib != 0 && b.refine == 0)
	{
	  // Assign every triangle a regional attribute of zero. 
	  GlobalMembersTriangle.traversalinit(m.triangles);
	  triangleloop.orient = 0;
	  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
	  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		((GlobalMembersTriangle.REAL)(triangleloop).tri)[m.elemattribindex + (m.eextras)] = 0.0;
		triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
	  }
	}
	for (i = 0; i < regions; i++)
	{
	  if (regiontris[i].tri != m.dummytri)
	  {
		// Make sure the triangle under consideration still exists. 
		//   It may have been eaten by the virus.                   
		if (!((regiontris[i].tri)[1] == (GlobalMembersTriangle.REAL) null))
		{
		  // Put one triangle in the virus pool. 
		  (regiontris[i]).tri[6] = (GlobalMembersTriangle.REAL)((int)(regiontris[i]).tri[6] | (int) 2l);
		  regiontri = (GlobalMembersTriangle.REAL ** **) GlobalMembersTriangle.poolalloc(m.viri);
		  *regiontri = regiontris[i].tri;
		  // Apply one region's attribute and/or area constraint. 
		  GlobalMembersTriangle.regionplague(m, b, regionlist[4 * i + 2], regionlist[4 * i + 3]);
		  // The virus pool should be empty now. 
		}
	  }
	}
	if (b.regionattrib != 0 && b.refine == 0)
	{
	  // Note the fact that each triangle has an additional attribute. 
	  m.eextras++;
	}
  }

  // Free up memory. 
  if (((holes > 0) && b.noholes == 0) || !b.convex || (regions > 0))
  {
	GlobalMembersTriangle.pooldeinit(m.viri);
  }
  if (regions > 0)
  {
	GlobalMembersTriangle.trifree((int) regiontris);
  }
}

//*                                                                         *
//*                                                                         *
//******** Carving out holes and concavities ends here               ********

//******** Mesh quality maintenance begins here                      ********
//*                                                                         *
//*                                                                         *

//***************************************************************************
//                                                                           
//  tallyencs()   Traverse the entire list of subsegments, and check each    
//                to see if it is encroached.  If so, add it to the list.    
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.tallyencs(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.tallyencs(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  osub subsegloop = new osub();
  int dummy;

  GlobalMembersTriangle.traversalinit(m.subsegs);
  subsegloop.ssorient = 0;
  subsegloop.ss = GlobalMembersTriangle.subsegtraverse(m);
  while (subsegloop.ss != (GlobalMembersTriangle.REAL ** *) null)
  {
	// If the segment is encroached, add it to the list. 
	dummy = GlobalMembersTriangle.checkseg4encroach(m, b, subsegloop);
	subsegloop.ss = GlobalMembersTriangle.subsegtraverse(m);
  }
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  precisionerror()  Print an error message for precision problems.         
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
void GlobalMembersTriangle.precisionerror()
{
  System.out.print("Try increasing the area criterion and/or reducing the minimum\n");
  System.out.print("  allowable angle so that tiny triangles are not created.\n");
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if SINGLE
  System.out.print("Alternatively, try recompiling me with double precision\n");
  System.out.print("  arithmetic (by removing \"#define SINGLE\" from the\n");
  System.out.print("  source file or \"-DSINGLE\" from the makefile).\n");
//#endif // SINGLE
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  splitencsegs()   Split all the encroached subsegments.                   
//                                                                           
//  Each encroached subsegment is repaired by splitting it - inserting a     
//  vertex at or near its midpoint.  Newly inserted vertices may encroach    
//  upon other subsegments; these are also repaired.                         
//                                                                           
//  `triflaws' is a flag that specifies whether one should take note of new  
//  bad triangles that result from inserting vertices to repair encroached   
//  subsegments.                                                             
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.splitencsegs(struct mesh m, struct behavior b, int triflaws)
//#else
void GlobalMembersTriangle.splitencsegs(m, b, triflaws)
mesh m;
behavior b;
int triflaws;
//#endif // not ANSI_DECLARATORS

{
  otri enctri = new otri();
  otri testtri = new otri();
  osub testsh = new osub();
  osub currentenc = new osub();
  badsubseg encloop;
  GlobalMembersTriangle.REAL eorg;
  GlobalMembersTriangle.REAL edest;
  GlobalMembersTriangle.REAL eapex;
  GlobalMembersTriangle.REAL newvertex;
  insertvertexresult success;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL segmentlength;
  GlobalMembersTriangle.REAL nearestpoweroftwo;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL split;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL multiplier;
  GlobalMembersTriangle.REAL divisor;
  int acuteorg;
  int acuteorg2;
  int acutedest;
  int acutedest2;
  int dummy;
  int i;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by stpivot().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by snext().

  // Note that steinerleft == -1 if an unlimited number 
  //   of Steiner points is allowed.                    
  while ((m.badsubsegs.items > 0) && (m.steinerleft != 0))
  {
	GlobalMembersTriangle.traversalinit(m.badsubsegs);
	encloop = GlobalMembersTriangle.badsubsegtraverse(m);
	while ((encloop != (badsubseg) null) && (m.steinerleft != 0))
	{
	  (currentenc).ssorient = (int)((int)(encloop.encsubseg) & (int) 1l);
	  (currentenc).ss = (GlobalMembersTriangle.REAL ** *)((int)(encloop.encsubseg) & ~ (int) 3l);
	  eorg = (GlobalMembersTriangle.REAL)(currentenc).ss[2 + (currentenc).ssorient];
	  edest = (GlobalMembersTriangle.REAL)(currentenc).ss[3 - (currentenc).ssorient];
	  // Make sure that this segment is still the same segment it was   
	  //   when it was determined to be encroached.  If the segment was 
	  //   enqueued multiple times (because several newly inserted      
	  //   vertices encroached it), it may have already been split.     
	  if (!((currentenc.ss)[1] == (GlobalMembersTriangle.REAL) null) && (eorg == encloop.subsegorg) && (edest == encloop.subsegdest))
	  {
		// To decide where to split a segment, we need to know if the   
		//   segment shares an endpoint with an adjacent segment.       
		//   The concern is that, if we simply split every encroached   
		//   segment in its center, two adjacent segments with a small  
		//   angle between them might lead to an infinite loop; each    
		//   vertex added to split one segment will encroach upon the   
		//   other segment, which must then be split with a vertex that 
		//   will encroach upon the first segment, and so on forever.   
		// To avoid this, imagine a set of concentric circles, whose    
		//   radii are powers of two, about each segment endpoint.      
		//   These concentric circles determine where the segment is    
		//   split.  (If both endpoints are shared with adjacent        
		//   segments, split the segment in the middle, and apply the   
		//   concentric circles for later splittings.)                  

		// Is the origin shared with another segment? 
		ptr = (GlobalMembersTriangle.REAL)(currentenc).ss[6 + (currentenc).ssorient];
		(enctri).orient = (int)((int)(ptr) & (int) 3l);
		(enctri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(enctri).orient);
		(testtri).tri = (enctri).tri;
		(testtri).orient = GlobalMembersTriangle.plus1mod3[(enctri).orient];
		sptr = (GlobalMembersTriangle.REAL)(testtri).tri[6 + (testtri).orient];
		(testsh).ssorient = (int)((int)(sptr) & (int) 1l);
		(testsh).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		acuteorg = testsh.ss != m.dummysub;
		// Is the destination shared with another segment? 
		(testtri).orient = GlobalMembersTriangle.plus1mod3[(testtri).orient];
		sptr = (GlobalMembersTriangle.REAL)(testtri).tri[6 + (testtri).orient];
		(testsh).ssorient = (int)((int)(sptr) & (int) 1l);
		(testsh).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		acutedest = testsh.ss != m.dummysub;

		// If we're using Chew's algorithm (rather than Ruppert's) 
		//   to define encroachment, delete free vertices from the 
		//   subsegment's diametral circle.                        
		if (b.conformdel == 0 && !acuteorg && acutedest == 0)
		{
		  eapex = (GlobalMembersTriangle.REAL)(enctri).tri[(enctri).orient + 3];
		  while ((((int)(eapex))[m.vertexmarkindex + 1] == DefineConstantsTriangle.FREEVERTEX) && ((eorg[0] - eapex[0]) * (edest[0] - eapex[0]) + (eorg[1] - eapex[1]) * (edest[1] - eapex[1]) < 0.0))
		  {
			GlobalMembersTriangle.deletevertex(m, b, testtri);
			ptr = (GlobalMembersTriangle.REAL)(currentenc).ss[6 + (currentenc).ssorient];
			(enctri).orient = (int)((int)(ptr) & (int) 3l);
			(enctri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(enctri).orient);
			eapex = (GlobalMembersTriangle.REAL)(enctri).tri[(enctri).orient + 3];
			(testtri).tri = (enctri).tri;
			(testtri).orient = GlobalMembersTriangle.minus1mod3[(enctri).orient];
		  }
		}

		// Now, check the other side of the segment, if there's a triangle 
		//   there.                                                        
		ptr = (enctri).tri[(enctri).orient];
		(testtri).orient = (int)((int)(ptr) & (int) 3l);
		(testtri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(testtri).orient);
		;
		if (testtri.tri != m.dummytri)
		{
		  // Is the destination shared with another segment? 
		  (testtri).orient = GlobalMembersTriangle.plus1mod3[(testtri).orient];
		  sptr = (GlobalMembersTriangle.REAL)(testtri).tri[6 + (testtri).orient];
		  (testsh).ssorient = (int)((int)(sptr) & (int) 1l);
		  (testsh).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		  acutedest2 = testsh.ss != m.dummysub;
		  acutedest = acutedest || acutedest2;
		  // Is the origin shared with another segment? 
		  (testtri).orient = GlobalMembersTriangle.plus1mod3[(testtri).orient];
		  sptr = (GlobalMembersTriangle.REAL)(testtri).tri[6 + (testtri).orient];
		  (testsh).ssorient = (int)((int)(sptr) & (int) 1l);
		  (testsh).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		  acuteorg2 = testsh.ss != m.dummysub;
		  acuteorg = acuteorg || acuteorg2;

		  // Delete free vertices from the subsegment's diametral circle. 
		  if (b.conformdel == 0 && !acuteorg2 && acutedest2 == 0)
		  {
			eapex = (GlobalMembersTriangle.REAL)(testtri).tri[GlobalMembersTriangle.plus1mod3[(testtri).orient] + 3];
			while ((((int)(eapex))[m.vertexmarkindex + 1] == DefineConstantsTriangle.FREEVERTEX) && ((eorg[0] - eapex[0]) * (edest[0] - eapex[0]) + (eorg[1] - eapex[1]) * (edest[1] - eapex[1]) < 0.0))
			{
			  GlobalMembersTriangle.deletevertex(m, b, testtri);
			  ptr = (enctri).tri[(enctri).orient];
			  (testtri).orient = (int)((int)(ptr) & (int) 3l);
			  (testtri).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(testtri).orient);
			  ;
			  eapex = (GlobalMembersTriangle.REAL)(testtri).tri[(testtri).orient + 3];
			  (testtri).orient = GlobalMembersTriangle.minus1mod3[(testtri).orient];
			}
		  }
		}

		// Use the concentric circles if exactly one endpoint is shared 
		//   with another adjacent segment.                             
		if (acuteorg != 0 || acutedest != 0)
		{
		  segmentlength = Math.sqrt((edest[0] - eorg[0]) * (edest[0] - eorg[0]) + (edest[1] - eorg[1]) * (edest[1] - eorg[1]));
		  // Find the power of two that most evenly splits the segment.  
		  //   The worst case is a 2:1 ratio between subsegment lengths. 
		  nearestpoweroftwo = 1.0;
		  while (segmentlength > 3.0 * nearestpoweroftwo)
		  {
			nearestpoweroftwo *= 2.0;
		  }
		  while (segmentlength < 1.5 * nearestpoweroftwo)
		  {
			nearestpoweroftwo *= 0.5;
		  }
		  // Where do we split the segment? 
		  split = nearestpoweroftwo / segmentlength;
		  if (acutedest != 0)
		  {
			split = 1.0 - split;
		  }
		  }
		else
		{
		  // If we're not worried about adjacent segments, split 
		  //   this segment in the middle.                       
		  split = 0.5;
		}

		// Create the new vertex. 
		newvertex = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.poolalloc(m.vertices);
		// Interpolate its coordinate and attributes. 
		for (i = 0; i < 2 + m.nextras; i++)
		{
		  newvertex[i] = eorg[i] + split * (edest[i] - eorg[i]);
		}

		if (b.noexact == 0)
		{
		  // Roundoff in the above calculation may yield a `newvertex'   
		  //   that is not precisely collinear with `eorg' and `edest'.  
		  //   Improve collinearity by one step of iterative refinement. 
		  multiplier = GlobalMembersTriangle.counterclockwise(m, b, eorg, edest, newvertex);
		  divisor = ((eorg[0] - edest[0]) * (eorg[0] - edest[0]) + (eorg[1] - edest[1]) * (eorg[1] - edest[1]));
		  if ((multiplier != 0.0) && (divisor != 0.0))
		  {
			multiplier = multiplier / divisor;
			// Watch out for NANs. 
			if (multiplier == multiplier)
			{
			  newvertex[0] += multiplier * (edest[1] - eorg[1]);
			  newvertex[1] += multiplier * (eorg[0] - edest[0]);
			}
		  }
		}

		((int)(newvertex))[m.vertexmarkindex] = (* (int)((currentenc).ss + 8));
		((int)(newvertex))[m.vertexmarkindex + 1] = DefineConstantsTriangle.SEGMENTVERTEX;
		if (b.verbose > 1)
		{
		  System.out.printf("  Splitting subsegment (%.12g, %.12g) (%.12g, %.12g) at (%.12g, %.12g).\n", eorg[0], eorg[1], edest[0], edest[1], newvertex[0], newvertex[1]);
		}
		// Check whether the new vertex lies on an endpoint. 
		if (((newvertex[0] == eorg[0]) && (newvertex[1] == eorg[1])) || ((newvertex[0] == edest[0]) && (newvertex[1] == edest[1])))
		{
		  System.out.printf("Error:  Ran out of precision at (%.12g, %.12g).\n", newvertex[0], newvertex[1]);
		  System.out.print("I attempted to split a segment to a smaller size than\n");
		  System.out.print("  can be accommodated by the finite precision of\n");
		  System.out.print("  floating point arithmetic.\n");
		  GlobalMembersTriangle.precisionerror();
		  GlobalMembersTriangle.triexit(1);
		}
		// Insert the splitting vertex.  This should always succeed. 
		success = GlobalMembersTriangle.insertvertex(m, b, newvertex, enctri, currentenc, 1, triflaws);
		if ((success != insertvertexresult.SUCCESSFULVERTEX) && (success != insertvertexresult.ENCROACHINGVERTEX))
		{
		  System.out.print("Internal error in splitencsegs():\n");
		  System.out.print("  Failure to split a segment.\n");
		  GlobalMembersTriangle.internalerror();
		}
		if (m.steinerleft > 0)
		{
		  m.steinerleft--;
		}
		// Check the two new subsegments to see if they're encroached. 
		dummy = GlobalMembersTriangle.checkseg4encroach(m, b, currentenc);
		sptr = (currentenc).ss[1 - (currentenc).ssorient];
		(currentenc).ssorient = (int)((int)(sptr) & (int) 1l);
		(currentenc).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		dummy = GlobalMembersTriangle.checkseg4encroach(m, b, currentenc);
	  }

	  GlobalMembersTriangle.badsubsegdealloc(m, encloop);
	  encloop = GlobalMembersTriangle.badsubsegtraverse(m);
	}
  }
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  tallyfaces()   Test every triangle in the mesh for quality measures.     
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.tallyfaces(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.tallyfaces(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri triangleloop = new otri();

  if (b.verbose != 0)
  {
	System.out.print("  Making a list of bad triangles.\n");
  }
  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.orient = 0;
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	// If the triangle is bad, enqueue it. 
	GlobalMembersTriangle.testtriangle(m, b, triangleloop);
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  }
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  splittriangle()   Inserts a vertex at the circumcenter of a triangle.    
//                    Deletes the newly inserted vertex if it encroaches     
//                    upon a segment.                                        
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.splittriangle(struct mesh m, struct behavior b, struct badtriang badtri)
//#else
void GlobalMembersTriangle.splittriangle(m, b, badtri)
mesh m;
behavior b;
badtriang badtri;
//#endif // not ANSI_DECLARATORS

{
  otri badotri = new otri();
  GlobalMembersTriangle.REAL borg;
  GlobalMembersTriangle.REAL bdest;
  GlobalMembersTriangle.REAL bapex;
  GlobalMembersTriangle.REAL newvertex;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL xi;
  GlobalMembersTriangle.REAL eta;
  insertvertexresult success;
  int errorflag;
  int i;

  (badotri).orient = (int)((int)(badtri.poortri) & (int) 3l);
  (badotri).tri = (GlobalMembersTriangle.REAL ** *)((int)(badtri.poortri) ^ (int)(badotri).orient);
  borg = (GlobalMembersTriangle.REAL)(badotri).tri[GlobalMembersTriangle.plus1mod3[(badotri).orient] + 3];
  bdest = (GlobalMembersTriangle.REAL)(badotri).tri[GlobalMembersTriangle.minus1mod3[(badotri).orient] + 3];
  bapex = (GlobalMembersTriangle.REAL)(badotri).tri[(badotri).orient + 3];
  // Make sure that this triangle is still the same triangle it was      
  //   when it was tested and determined to be of bad quality.           
  //   Subsequent transformations may have made it a different triangle. 
  if (!((badotri.tri)[1] == (GlobalMembersTriangle.REAL) null) && (borg == badtri.triangorg) && (bdest == badtri.triangdest) && (bapex == badtri.triangapex))
  {
	if (b.verbose > 1)
	{
	  System.out.print("  Splitting this triangle at its circumcenter:\n");
	  System.out.printf("    (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n", borg[0], borg[1], bdest[0], bdest[1], bapex[0], bapex[1]);
	}

	errorflag = 0;
	// Create a new vertex at the triangle's circumcenter. 
	newvertex = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.poolalloc(m.vertices);
	GlobalMembersTriangle.findcircumcenter(m, b, borg, bdest, bapex, newvertex, xi, eta, 1);

	// Check whether the new vertex lies on a triangle vertex. 
	if (((newvertex[0] == borg[0]) && (newvertex[1] == borg[1])) || ((newvertex[0] == bdest[0]) && (newvertex[1] == bdest[1])) || ((newvertex[0] == bapex[0]) && (newvertex[1] == bapex[1])))
	{
	  if (b.quiet == 0)
	  {
		System.out.printf("Warning:  New vertex (%.12g, %.12g) falls on existing vertex.\n", newvertex[0], newvertex[1]);
		errorflag = 1;
	  }
	  GlobalMembersTriangle.vertexdealloc(m, newvertex);
	  }
	else
	{
	  for (i = 2; i < 2 + m.nextras; i++)
	  {
		// Interpolate the vertex attributes at the circumcenter. 
		newvertex[i] = borg[i] + xi * (bdest[i] - borg[i]) + eta * (bapex[i] - borg[i]);
	  }
	  // The new vertex must be in the interior, and therefore is a 
	  //   free vertex with a marker of zero.                       
	  ((int)(newvertex))[m.vertexmarkindex] = 0;
	  ((int)(newvertex))[m.vertexmarkindex + 1] = DefineConstantsTriangle.FREEVERTEX;

	  // Ensure that the handle `badotri' does not represent the longest  
	  //   edge of the triangle.  This ensures that the circumcenter must 
	  //   fall to the left of this edge, so point location will work.    
	  //   (If the angle org-apex-dest exceeds 90 degrees, then the       
	  //   circumcenter lies outside the org-dest edge, and eta is        
	  //   negative.  Roundoff error might prevent eta from being         
	  //   negative when it should be, so I test eta against xi.)         
	  if (eta < xi)
	  {
		(badotri).orient = GlobalMembersTriangle.minus1mod3[(badotri).orient];
	  }

	  // Insert the circumcenter, searching from the edge of the triangle, 
	  //   and maintain the Delaunay property of the triangulation.        
	  success = GlobalMembersTriangle.insertvertex(m, b, newvertex, badotri, (osub) null, 1, 1);
	  if (success == insertvertexresult.SUCCESSFULVERTEX)
	  {
		if (m.steinerleft > 0)
		{
		  m.steinerleft--;
		}
		}
	  else if (success == insertvertexresult.ENCROACHINGVERTEX)
	  {
		// If the newly inserted vertex encroaches upon a subsegment, 
		//   delete the new vertex.                                   
		GlobalMembersTriangle.undovertex(m, b);
		if (b.verbose > 1)
		{
		  System.out.printf("  Rejecting (%.12g, %.12g).\n", newvertex[0], newvertex[1]);
		}
		GlobalMembersTriangle.vertexdealloc(m, newvertex);
		}
	  else if (success == insertvertexresult.VIOLATINGVERTEX)
	  {
		// Failed to insert the new vertex, but some subsegment was 
		//   marked as being encroached.                            
		GlobalMembersTriangle.vertexdealloc(m, newvertex);
	  } // success == DUPLICATEVERTEX
	  else
	  {
		// Couldn't insert the new vertex because a vertex is already there. 
		if (b.quiet == 0)
		{
		  System.out.printf("Warning:  New vertex (%.12g, %.12g) falls on existing vertex.\n", newvertex[0], newvertex[1]);
		  errorflag = 1;
		}
		GlobalMembersTriangle.vertexdealloc(m, newvertex);
	  }
	}
	if (errorflag != 0)
	{
	  if (b.verbose != 0)
	  {
		System.out.print("  The new vertex is at the circumcenter of triangle\n");
		System.out.printf("    (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n", borg[0], borg[1], bdest[0], bdest[1], bapex[0], bapex[1]);
	  }
	  System.out.print("This probably means that I am trying to refine triangles\n");
	  System.out.print("  to a smaller size than can be accommodated by the finite\n");
	  System.out.print("  precision of floating point arithmetic.  (You can be\n");
	  System.out.print("  sure of this if I fail to terminate.)\n");
	  GlobalMembersTriangle.precisionerror();
	}
  }
}

//#endif // not CDT_ONLY

//***************************************************************************
//                                                                           
//  enforcequality()   Remove all the encroached subsegments and bad         
//                     triangles from the triangulation.                     
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.enforcequality(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.enforcequality(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  badtriang badtri;
  int i;

  if (b.quiet == 0)
  {
	System.out.print("Adding Steiner points to enforce quality.\n");
  }
  // Initialize the pool of encroached subsegments. 
  GlobalMembersTriangle.poolinit(m.badsubsegs, sizeof(badsubseg), DefineConstantsTriangle.BADSUBSEGPERBLOCK, DefineConstantsTriangle.BADSUBSEGPERBLOCK, 0);
  if (b.verbose != 0)
  {
	System.out.print("  Looking for encroached subsegments.\n");
  }
  // Test all segments to see if they're encroached. 
  GlobalMembersTriangle.tallyencs(m, b);
  if (b.verbose != 0 && (m.badsubsegs.items > 0))
  {
	System.out.print("  Splitting encroached subsegments.\n");
  }
  // Fix encroached subsegments without noting bad triangles. 
  GlobalMembersTriangle.splitencsegs(m, b, 0);
  // At this point, if we haven't run out of Steiner points, the 
  //   triangulation should be (conforming) Delaunay.            

  // Next, we worry about enforcing triangle quality. 
  if ((b.minangle > 0.0) || b.vararea || b.fixedarea || b.usertest != 0)
  {
	// Initialize the pool of bad triangles. 
	GlobalMembersTriangle.poolinit(m.badtriangles, sizeof(badtriang), DefineConstantsTriangle.BADTRIPERBLOCK, DefineConstantsTriangle.BADTRIPERBLOCK, 0);
	// Initialize the queues of bad triangles. 
	for (i = 0; i < 4096; i++)
	{
	  m.queuefront[i] = (badtriang) null;
	}
	m.firstnonemptyq = -1;
	// Test all triangles to see if they're bad. 
	GlobalMembersTriangle.tallyfaces(m, b);
	// Initialize the pool of recently flipped triangles. 
	GlobalMembersTriangle.poolinit(m.flipstackers, sizeof(flipstacker), DefineConstantsTriangle.FLIPSTACKERPERBLOCK, DefineConstantsTriangle.FLIPSTACKERPERBLOCK, 0);
	m.checkquality = 1;
	if (b.verbose != 0)
	{
	  System.out.print("  Splitting bad triangles.\n");
	}
	while ((m.badtriangles.items > 0) && (m.steinerleft != 0))
	{
	  // Fix one bad triangle by inserting a vertex at its circumcenter. 
	  badtri = GlobalMembersTriangle.dequeuebadtriang(m);
	  GlobalMembersTriangle.splittriangle(m, b, badtri);
	  if (m.badsubsegs.items > 0)
	  {
		// Put bad triangle back in queue for another try later. 
		GlobalMembersTriangle.enqueuebadtriang(m, b, badtri);
		// Fix any encroached subsegments that resulted. 
		//   Record any new bad triangles that result.   
		GlobalMembersTriangle.splitencsegs(m, b, 1);
	  }
	  else
	  {
		// Return the bad triangle to the pool. 
		GlobalMembersTriangle.pooldealloc(m.badtriangles, (int) badtri);
	  }
	}
  }
  // At this point, if the "-D" switch was selected and we haven't run out  
  //   of Steiner points, the triangulation should be (conforming) Delaunay 
  //   and have no low-quality triangles.                                   

  // Might we have run out of Steiner points too soon? 
  if (b.quiet == 0 && b.conformdel && (m.badsubsegs.items > 0) && (m.steinerleft == 0))
  {
	System.out.print("\nWarning:  I ran out of Steiner points, but the mesh has\n");
	if (m.badsubsegs.items == 1)
	{
	  System.out.print("  one encroached subsegment, and therefore might not be truly\n");
	}
	else
	{
	  System.out.printf("  %ld encroached subsegments, and therefore might not be truly\n", m.badsubsegs.items);
	}
	System.out.print("  Delaunay.  If the Delaunay property is important to you,\n");
	System.out.print("  try increasing the number of Steiner points (controlled by\n");
	System.out.print("  the -S switch) slightly and try again.\n\n");
  }
}

//#endif // not CDT_ONLY

//*                                                                         *
//*                                                                         *
//******** Mesh quality maintenance ends here                        ********

//***************************************************************************
//                                                                           
//  highorder()   Create extra nodes for quadratic subparametric elements.   
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.highorder(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.highorder(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri triangleloop = new otri();
  otri trisym = new otri();
  osub checkmark = new osub();
  GlobalMembersTriangle.REAL newvertex;
  GlobalMembersTriangle.REAL torg;
  GlobalMembersTriangle.REAL tdest;
  int i;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

  if (b.quiet == 0)
  {
	System.out.print("Adding vertices for second-order triangles.\n");
  }
  // The following line ensures that dead items in the pool of nodes    
  //   cannot be allocated for the extra nodes associated with high     
  //   order elements.  This ensures that the primary nodes (at the     
  //   corners of elements) will occur earlier in the output files, and 
  //   have lower indices, than the extra nodes.                        
  m.vertices.deaditemstack = (int) null;

  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  // To loop over the set of edges, loop over all triangles, and look at   
  //   the three edges of each triangle.  If there isn't another triangle  
  //   adjacent to the edge, operate on the edge.  If there is another     
  //   adjacent triangle, operate on the edge only if the current triangle 
  //   has a smaller pointer than its neighbor.  This way, each edge is    
  //   considered only once.                                               
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	for (triangleloop.orient = 0; triangleloop.orient < 3; triangleloop.orient++)
	{
	  ptr = (triangleloop).tri[(triangleloop).orient];
	  (trisym).orient = (int)((int)(ptr) & (int) 3l);
	  (trisym).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(trisym).orient);
	  ;
	  if ((triangleloop.tri < trisym.tri) || (trisym.tri == m.dummytri))
	  {
		torg = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.plus1mod3[(triangleloop).orient] + 3];
		tdest = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.minus1mod3[(triangleloop).orient] + 3];
		// Create a new node in the middle of the edge.  Interpolate 
		//   its attributes.                                         
		newvertex = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.poolalloc(m.vertices);
		for (i = 0; i < 2 + m.nextras; i++)
		{
		  newvertex[i] = 0.5 * (torg[i] + tdest[i]);
		}
		// Set the new node's marker to zero or one, depending on 
		//   whether it lies on a boundary.                       
		((int)(newvertex))[m.vertexmarkindex] = trisym.tri == m.dummytri;
		((int)(newvertex))[m.vertexmarkindex + 1] = trisym.tri == m.dummytri ? DefineConstantsTriangle.FREEVERTEX : DefineConstantsTriangle.SEGMENTVERTEX;
		if (b.usesegments != 0)
		{
		  sptr = (GlobalMembersTriangle.REAL)(triangleloop).tri[6 + (triangleloop).orient];
		  (checkmark).ssorient = (int)((int)(sptr) & (int) 1l);
		  (checkmark).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
		  // If this edge is a segment, transfer the marker to the new node. 
		  if (checkmark.ss != m.dummysub)
		  {
			((int)(newvertex))[m.vertexmarkindex] = (* (int)((checkmark).ss + 8));
			((int)(newvertex))[m.vertexmarkindex + 1] = DefineConstantsTriangle.SEGMENTVERTEX;
		  }
		}
		if (b.verbose > 1)
		{
		  System.out.printf("  Creating (%.12g, %.12g).\n", newvertex[0], newvertex[1]);
		}
		// Record the new node in the (one or two) adjacent elements. 
		triangleloop.tri[m.highorderindex + triangleloop.orient] = (GlobalMembersTriangle.REAL) newvertex;
		if (trisym.tri != m.dummytri)
		{
		  trisym.tri[m.highorderindex + trisym.orient] = (GlobalMembersTriangle.REAL) newvertex;
		}
	  }
	}
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  }
}

//******** File I/O routines begin here                              ********
//*                                                                         *
//*                                                                         *

//***************************************************************************
//                                                                           
//  readline()   Read a nonempty line from a file.                           
//                                                                           
//  A line is considered "nonempty" if it contains something that looks like 
//  a number.  Comments (prefaced by `#') are ignored.                       
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
char *GlobalMembersTriangle.readline(char *String, FILE *infile, char *infilename)
//#else
char *GlobalMembersTriangle.readline(String, infile, infilename)
String String;
FILE infile;
String infilename;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
  char result;

  // Search for something that looks like a number. 
  do
  {
	result = fgets(String, DefineConstantsTriangle.INPUTLINESIZE, infile);
	if (result == (char) null)
	{
	  System.out.printf("  Error:  Unexpected end of file in %s.\n", infilename);
	  GlobalMembersTriangle.triexit(1);
	}
	// Skip anything that doesn't look like a number, a comment, 
	//   or the end of a line.                                   
	while (( result != '\0') && ( result != '#') && ( result != '.') && ( result != '+') && ( result != '-') && (( result < '0') || ( result > '9')))
	{
	  result++;
	}
  // If it's a comment or end of line, read another line and try again. 
  } while (( result == '#') || ( result == '\0'));
  return result;
}

//#endif // not TRILIBRARY

//***************************************************************************
//                                                                           
//  findfield()   Find the next field of a string.                           
//                                                                           
//  Jumps past the current field by searching for whitespace, then jumps     
//  past the whitespace to find the next field.                              
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
char *GlobalMembersTriangle.findfield(char String)
//#else
char *GlobalMembersTriangle.findfield(String)
String String;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged.
  char result;

  result = String;
  // Skip the current field.  Stop upon reaching whitespace. 
  while (( result != '\0') && ( result != '#') && ( result != ' ') && ( result != '\t'))
  {
	result++;
  }
  // Now skip the whitespace and anything else that doesn't look like a 
  //   number, a comment, or the end of a line.                         
  while (( result != '\0') && ( result != '#') && ( result != '.') && ( result != '+') && ( result != '-') && (( result < '0') || ( result > '9')))
  {
	result++;
  }
  // Check for a comment (prefixed with `#'). 
  if ( result == '#')
  {
	result = '\0';
  }
  return result;
}

//#endif // not TRILIBRARY

//***************************************************************************
//                                                                           
//  readnodes()   Read the vertices from a file, which may be a .node or     
//                .poly file.                                                
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.readnodes(struct mesh m, struct behavior b, char *nodefilename, char polyfilename, FILE polyfile)
//#else
void GlobalMembersTriangle.readnodes(m, b, nodefilename, polyfilename, polyfile)
mesh m;
behavior b;
String nodefilename;
String polyfilename;
FILE[] polyfile;
//#endif // not ANSI_DECLARATORS

{
  FILE infile;
  GlobalMembersTriangle.REAL vertexloop;
  String inputline = new String(new char[DefineConstantsTriangle.INPUTLINESIZE]);
  String stringptr;
  String infilename;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL x;
  GlobalMembersTriangle.REAL y;
  int firstnode;
  int nodemarkers;
  int currentmarker;
  int i;
  int j;

  if (b.poly != 0)
  {
	// Read the vertices from a .poly file. 
	if (b.quiet == 0)
	{
	  System.out.printf("Opening %s.\n", polyfilename);
	}
	polyfile = fopen(polyfilename, "r");
	if ( polyfile == (FILE) null)
	{
	  System.out.printf("  Error:  Cannot access file %s.\n", polyfilename);
	  GlobalMembersTriangle.triexit(1);
	}
	// Read number of vertices, number of dimensions, number of vertex 
	//   attributes, and number of boundary markers.                   
	stringptr = GlobalMembersTriangle.readline(inputline, polyfile, polyfilename);
	m.invertices = (int) strtol(stringptr, stringptr, 0);
	stringptr = GlobalMembersTriangle.findfield(stringptr);
	if ( stringptr.equals('\0'))
	{
	  m.mesh_dim = 2;
	}
	else
	{
	  m.mesh_dim = (int) strtol(stringptr, stringptr, 0);
	}
	stringptr = GlobalMembersTriangle.findfield(stringptr);
	if ( stringptr.equals('\0'))
	{
	  m.nextras = 0;
	}
	else
	{
	  m.nextras = (int) strtol(stringptr, stringptr, 0);
	}
	stringptr = GlobalMembersTriangle.findfield(stringptr);
	if ( stringptr.equals('\0'))
	{
	  nodemarkers = 0;
	}
	else
	{
	  nodemarkers = (int) strtol(stringptr, stringptr, 0);
	}
	if (m.invertices > 0)
	{
	  infile = polyfile;
	  infilename = polyfilename;
	  m.readnodefile = 0;
	}
	else
	{
	  // If the .poly file claims there are zero vertices, that means that 
	  //   the vertices should be read from a separate .node file.         
	  m.readnodefile = 1;
	  infilename = nodefilename;
	}
	}
  else
  {
	m.readnodefile = 1;
	infilename = nodefilename;
	polyfile = (FILE) null;
  }

  if (m.readnodefile != 0)
  {
	// Read the vertices from a .node file. 
	if (b.quiet == 0)
	{
	  System.out.printf("Opening %s.\n", nodefilename);
	}
	infile = fopen(nodefilename, "r");
	if (infile == (FILE) null)
	{
	  System.out.printf("  Error:  Cannot access file %s.\n", nodefilename);
	  GlobalMembersTriangle.triexit(1);
	}
	// Read number of vertices, number of dimensions, number of vertex 
	//   attributes, and number of boundary markers.                   
	stringptr = GlobalMembersTriangle.readline(inputline, infile, nodefilename);
	m.invertices = (int) strtol(stringptr, stringptr, 0);
	stringptr = GlobalMembersTriangle.findfield(stringptr);
	if ( stringptr.equals('\0'))
	{
	  m.mesh_dim = 2;
	}
	else
	{
	  m.mesh_dim = (int) strtol(stringptr, stringptr, 0);
	}
	stringptr = GlobalMembersTriangle.findfield(stringptr);
	if ( stringptr.equals('\0'))
	{
	  m.nextras = 0;
	}
	else
	{
	  m.nextras = (int) strtol(stringptr, stringptr, 0);
	}
	stringptr = GlobalMembersTriangle.findfield(stringptr);
	if ( stringptr.equals('\0'))
	{
	  nodemarkers = 0;
	}
	else
	{
	  nodemarkers = (int) strtol(stringptr, stringptr, 0);
	}
  }

  if (m.invertices < 3)
  {
	System.out.print("Error:  Input must have at least three input vertices.\n");
	GlobalMembersTriangle.triexit(1);
  }
  if (m.mesh_dim != 2)
  {
	System.out.print("Error:  Triangle only works with two-dimensional meshes.\n");
	GlobalMembersTriangle.triexit(1);
  }
  if (m.nextras == 0)
  {
	b.weighted = 0;
  }

  GlobalMembersTriangle.initializevertexpool(m, b);

  // Read the vertices. 
  for (i = 0; i < m.invertices; i++)
  {
	vertexloop = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.poolalloc(m.vertices);
	stringptr = GlobalMembersTriangle.readline(inputline, infile, infilename);
	if (i == 0)
	{
	  firstnode = (int) strtol(stringptr, stringptr, 0);
	  if ((firstnode == 0) || (firstnode == 1))
	  {
		b.firstnumber = firstnode;
	  }
	}
	stringptr = GlobalMembersTriangle.findfield(stringptr);
	if ( stringptr.equals('\0'))
	{
	  System.out.printf("Error:  Vertex %d has no x coordinate.\n", b.firstnumber + i);
	  GlobalMembersTriangle.triexit(1);
	}
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	x = (GlobalMembersTriangle.REAL) strtod(stringptr, stringptr);
	stringptr = GlobalMembersTriangle.findfield(stringptr);
	if ( stringptr.equals('\0'))
	{
	  System.out.printf("Error:  Vertex %d has no y coordinate.\n", b.firstnumber + i);
	  GlobalMembersTriangle.triexit(1);
	}
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	y = (GlobalMembersTriangle.REAL) strtod(stringptr, stringptr);
	vertexloop[0] = x;
	vertexloop[1] = y;
	// Read the vertex attributes. 
	for (j = 2; j < 2 + m.nextras; j++)
	{
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( stringptr.equals('\0'))
	  {
		vertexloop[j] = 0.0;
	  }
	  else
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		vertexloop[j] = (GlobalMembersTriangle.REAL) strtod(stringptr, stringptr);
	  }
	}
	if (nodemarkers != 0)
	{
	  // Read a vertex marker. 
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( stringptr.equals('\0'))
	  {
		((int)(vertexloop))[m.vertexmarkindex] = 0;
	  }
	  else
	  {
		currentmarker = (int) strtol(stringptr, stringptr, 0);
		((int)(vertexloop))[m.vertexmarkindex] = currentmarker;
	  }
	  }
	else
	{
	  // If no markers are specified in the file, they default to zero. 
	  ((int)(vertexloop))[m.vertexmarkindex] = 0;
	}
	((int)(vertexloop))[m.vertexmarkindex + 1] = DefineConstantsTriangle.INPUTVERTEX;
	// Determine the smallest and largest x and y coordinates. 
	if (i == 0)
	{
	  m.xmin = m.xmax = x;
	  m.ymin = m.ymax = y;
	}
	else
	{
	  m.xmin = (x < m.xmin) ? x : m.xmin;
	  m.xmax = (x > m.xmax) ? x : m.xmax;
	  m.ymin = (y < m.ymin) ? y : m.ymin;
	  m.ymax = (y > m.ymax) ? y : m.ymax;
	}
  }
  if (m.readnodefile != 0)
  {
	fclose(infile);
  }

  // Nonexistent x value used as a flag to mark circle events in sweepline 
  //   Delaunay algorithm.                                                 
  m.xminextreme = 10 m.xmin - 9 m.xmax;
}

//#endif // not TRILIBRARY

//***************************************************************************
//                                                                           
//  transfernodes()   Read the vertices from memory.                         
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
void GlobalMembersTriangle.transfernodes(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL *pointlist, GlobalMembersTriangle.REAL *pointattriblist, int *pointmarkerlist, int numberofpoints, int numberofpointattribs)
//#else
void GlobalMembersTriangle.transfernodes(m, b, pointlist, pointattriblist, pointmarkerlist, numberofpoints, numberofpointattribs)
mesh m;
behavior b;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL pointlist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL pointattriblist;
int pointmarkerlist;
int numberofpoints;
int numberofpointattribs;
//#endif // not ANSI_DECLARATORS

{
  GlobalMembersTriangle.REAL vertexloop;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL x;
  GlobalMembersTriangle.REAL y;
  int i;
  int j;
  int coordindex;
  int attribindex;

  m.invertices = numberofpoints;
  m.mesh_dim = 2;
  m.nextras = numberofpointattribs;
  m.readnodefile = 0;
  if (m.invertices < 3)
  {
	System.out.print("Error:  Input must have at least three input vertices.\n");
	GlobalMembersTriangle.triexit(1);
  }
  if (m.nextras == 0)
  {
	b.weighted = 0;
  }

  GlobalMembersTriangle.initializevertexpool(m, b);

  // Read the vertices. 
  coordindex = 0;
  attribindex = 0;
  for (i = 0; i < m.invertices; i++)
  {
	vertexloop = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.poolalloc(m.vertices);
	// Read the vertex coordinates. 
	x = vertexloop[0] = pointlist[coordindex++];
	y = vertexloop[1] = pointlist[coordindex++];
	// Read the vertex attributes. 
	for (j = 0; j < numberofpointattribs; j++)
	{
	  vertexloop[2 + j] = pointattriblist[attribindex++];
	}
	if (pointmarkerlist != (int) null)
	{
	  // Read a vertex marker. 
	  ((int)(vertexloop))[m.vertexmarkindex] = pointmarkerlist[i];
	}
	else
	{
	  // If no markers are specified, they default to zero. 
	  ((int)(vertexloop))[m.vertexmarkindex] = 0;
	}
	((int)(vertexloop))[m.vertexmarkindex + 1] = DefineConstantsTriangle.INPUTVERTEX;
	// Determine the smallest and largest x and y coordinates. 
	if (i == 0)
	{
	  m.xmin = m.xmax = x;
	  m.ymin = m.ymax = y;
	}
	else
	{
	  m.xmin = (x < m.xmin) ? x : m.xmin;
	  m.xmax = (x > m.xmax) ? x : m.xmax;
	  m.ymin = (y < m.ymin) ? y : m.ymin;
	  m.ymax = (y > m.ymax) ? y : m.ymax;
	}
  }

  // Nonexistent x value used as a flag to mark circle events in sweepline 
  //   Delaunay algorithm.                                                 
  m.xminextreme = 10 m.xmin - 9 m.xmax;
}

//#endif // TRILIBRARY

//***************************************************************************
//                                                                           
//  readholes()   Read the holes, and possibly regional attributes and area  
//                constraints, from a .poly file.                            
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
void GlobalMembersTriangle.readholes(struct mesh m, struct behavior b, FILE polyfile, char polyfilename, GlobalMembersTriangle.REAL **hlist, int *holes, GlobalMembersTriangle.REAL **rlist, int *regions)
//#else
void GlobalMembersTriangle.readholes(m, b, polyfile, polyfilename, hlist, holes, rlist, regions)
mesh m;
behavior b;
FILE polyfile;
String polyfilename;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL[] hlist;
int holes;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL[] rlist;
int regions;
//#endif // not ANSI_DECLARATORS

{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL holelist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL regionlist;
  String inputline = new String(new char[DefineConstantsTriangle.INPUTLINESIZE]);
  String stringptr;
  int index;
  int i;

  // Read the holes. 
  stringptr = GlobalMembersTriangle.readline(inputline, polyfile, polyfilename);
  holes = (int) strtol(stringptr, stringptr, 0);
  if ( holes > 0)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	holelist = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.trimalloc(2 * holes * (int) sizeof(GlobalMembersTriangle.REAL));
	*hlist = holelist;
	for (i = 0; i < 2 * holes; i += 2)
	{
	  stringptr = GlobalMembersTriangle.readline(inputline, polyfile, polyfilename);
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( stringptr.equals('\0'))
	  {
		System.out.printf("Error:  Hole %d has no x coordinate.\n", b.firstnumber + (i >> 1));
		GlobalMembersTriangle.triexit(1);
	  }
	  else
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		holelist[i] = (GlobalMembersTriangle.REAL) strtod(stringptr, stringptr);
	  }
	  stringptr = GlobalMembersTriangle.findfield(stringptr);
	  if ( stringptr.equals('\0'))
	  {
		System.out.printf("Error:  Hole %d has no y coordinate.\n", b.firstnumber + (i >> 1));
		GlobalMembersTriangle.triexit(1);
	  }
	  else
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		holelist[i + 1] = (GlobalMembersTriangle.REAL) strtod(stringptr, stringptr);
	  }
	}
	  }
  else
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	*hlist = (GlobalMembersTriangle.REAL) null;
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
  if ((b.regionattrib != 0 || b.vararea != 0) && b.refine == 0)
  {
	// Read the area constraints. 
	stringptr = GlobalMembersTriangle.readline(inputline, polyfile, polyfilename);
	regions = (int) strtol(stringptr, stringptr, 0);
	if ( regions > 0)
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  regionlist = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.trimalloc(4 * regions * (int) sizeof(GlobalMembersTriangle.REAL));
	  *rlist = regionlist;
	  index = 0;
	  for (i = 0; i < regions; i++)
	  {
		stringptr = GlobalMembersTriangle.readline(inputline, polyfile, polyfilename);
		stringptr = GlobalMembersTriangle.findfield(stringptr);
		if ( stringptr.equals('\0'))
		{
		  System.out.printf("Error:  Region %d has no x coordinate.\n", b.firstnumber + i);
		  GlobalMembersTriangle.triexit(1);
		}
		else
		{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		  regionlist[index++] = (GlobalMembersTriangle.REAL) strtod(stringptr, stringptr);
		}
		stringptr = GlobalMembersTriangle.findfield(stringptr);
		if ( stringptr.equals('\0'))
		{
		  System.out.printf("Error:  Region %d has no y coordinate.\n", b.firstnumber + i);
		  GlobalMembersTriangle.triexit(1);
		}
		else
		{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		  regionlist[index++] = (GlobalMembersTriangle.REAL) strtod(stringptr, stringptr);
		}
		stringptr = GlobalMembersTriangle.findfield(stringptr);
		if ( stringptr.equals('\0'))
		{
		  System.out.printf("Error:  Region %d has no region attribute or area constraint.\n", b.firstnumber + i);
		  GlobalMembersTriangle.triexit(1);
		}
		else
		{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		  regionlist[index++] = (GlobalMembersTriangle.REAL) strtod(stringptr, stringptr);
		}
		stringptr = GlobalMembersTriangle.findfield(stringptr);
		if ( stringptr.equals('\0'))
		{
		  regionlist[index] = regionlist[index - 1];
		}
		else
		{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		  regionlist[index] = (GlobalMembersTriangle.REAL) strtod(stringptr, stringptr);
		}
		index++;
	  }
	}
		}
  else
  {
	// Set `*regions' to zero to avoid an accidental free() later. 
	regions = 0;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	*rlist = (GlobalMembersTriangle.REAL) null;
  }
//#endif // not CDT_ONLY

  fclose(polyfile);
}

//#endif // not TRILIBRARY

//***************************************************************************
//                                                                           
//  finishfile()   Write the command line to the output file so the user     
//                 can remember how the file was generated.  Close the file. 
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.finishfile(FILE *outfile, int argc, char **argv)
//#else
void GlobalMembersTriangle.finishfile(outfile, argc, argv)
FILE outfile;
int argc;
String[] argv;
//#endif // not ANSI_DECLARATORS

{
  int i;

  fprintf(outfile, "# Generated by");
  for (i = 0; i < argc; i++)
  {
	fprintf(outfile, " ");
	fputs(argv.charAt(i), outfile);
  }
  fprintf(outfile, "\n");
  fclose(outfile);
}

//#endif // not TRILIBRARY

//***************************************************************************
//                                                                           
//  writenodes()   Number the vertices and write them to a .node file.       
//                                                                           
//  To save memory, the vertex numbers are written over the boundary markers 
//  after the vertices are written to a file.                                
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
void GlobalMembersTriangle.writenodes(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL * pointlist, GlobalMembersTriangle.REAL * pointattriblist, int * pointmarkerlist)
//#else
void GlobalMembersTriangle.writenodes(m, b, pointlist, pointattriblist, pointmarkerlist)
mesh m;
behavior b;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL[] pointlist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL[] pointattriblist;
int[] pointmarkerlist;
//#endif // not ANSI_DECLARATORS


//#else
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.writenodes(struct mesh m, struct behavior b, char nodefilename, int argc, char **argv)
//#else
void GlobalMembersTriangle.writenodes(m, b, nodefilename, argc, argv)
mesh m;
behavior b;
String nodefilename;
int argc;
String[] argv;
//#endif // not ANSI_DECLARATORS

//#endif // not TRILIBRARY

{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL plist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL palist;
  int pmlist;
  int coordindex;
  int attribindex;
//#else
  FILE outfile;
//#endif // not TRILIBRARY
  GlobalMembersTriangle.REAL vertexloop;
  int outvertices;
  int vertexnumber;
  int i;

  if (b.jettison != 0)
  {
	outvertices = m.vertices.items - m.undeads;
  }
  else
  {
	outvertices = m.vertices.items;
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  if (b.quiet == 0)
  {
	System.out.print("Writing vertices.\n");
  }
  // Allocate memory for output vertices if necessary. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  if ( pointlist == (GlobalMembersTriangle.REAL) null)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	pointlist = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.trimalloc((int)(outvertices * 2 * sizeof(GlobalMembersTriangle.REAL)));
  }
  // Allocate memory for output vertex attributes if necessary. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  if ((m.nextras > 0) && ( pointattriblist == (GlobalMembersTriangle.REAL) null))
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	pointattriblist = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.trimalloc((int)(outvertices m.nextras * sizeof(GlobalMembersTriangle.REAL)));
  }
  // Allocate memory for output vertex markers if necessary. 
  if (b.nobound == 0 && ( pointmarkerlist == (int) null))
  {
	pointmarkerlist = (int) GlobalMembersTriangle.trimalloc((int)(outvertices * sizeof(int)));
  }
  plist = pointlist;
  palist = pointattriblist;
  pmlist = pointmarkerlist;
  coordindex = 0;
  attribindex = 0;
//#else
  if (b.quiet == 0)
  {
	System.out.printf("Writing %s.\n", nodefilename);
  }
  outfile = fopen(nodefilename, "w");
  if (outfile == (FILE) null)
  {
	System.out.printf("  Error:  Cannot create file %s.\n", nodefilename);
	GlobalMembersTriangle.triexit(1);
  }
  // Number of vertices, number of dimensions, number of vertex attributes, 
  //   and number of boundary markers (zero or one).                        
  fprintf(outfile, "%ld  %d  %d  %d\n", outvertices, m.mesh_dim, m.nextras, 1 - b.nobound);
//#endif // not TRILIBRARY

  GlobalMembersTriangle.traversalinit(m.vertices);
  vertexnumber = b.firstnumber;
  vertexloop = GlobalMembersTriangle.vertextraverse(m);
  while (vertexloop != (GlobalMembersTriangle.REAL) null)
  {
	if (b.jettison == 0 || (((int)(vertexloop))[m.vertexmarkindex + 1] != -32767))
	{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	  // X and y coordinates. 
	  plist[coordindex++] = vertexloop[0];
	  plist[coordindex++] = vertexloop[1];
	  // Vertex attributes. 
	  for (i = 0; i < m.nextras; i++)
	  {
		palist[attribindex++] = vertexloop[2 + i];
	  }
	  if (b.nobound == 0)
	  {
		// Copy the boundary marker. 
		pmlist[vertexnumber - b.firstnumber] = ((int)(vertexloop))[m.vertexmarkindex];
	  }
//#else
	  // Vertex number, x and y coordinates. 
	  fprintf(outfile, "%4d    %.17g  %.17g", vertexnumber, vertexloop[0], vertexloop[1]);
	  for (i = 0; i < m.nextras; i++)
	  {
		// Write an attribute. 
		fprintf(outfile, "  %.17g", vertexloop[i + 2]);
	  }
	  if (b.nobound != 0)
	  {
		fprintf(outfile, "\n");
	  }
	  else
	  {
		// Write the boundary marker. 
		fprintf(outfile, "    %d\n", ((int)(vertexloop))[m.vertexmarkindex]);
	  }
//#endif // not TRILIBRARY

	  ((int)(vertexloop))[m.vertexmarkindex] = vertexnumber;
	  vertexnumber++;
	}
	vertexloop = GlobalMembersTriangle.vertextraverse(m);
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
  GlobalMembersTriangle.finishfile(outfile, argc, argv);
//#endif // not TRILIBRARY
}

//***************************************************************************
//                                                                           
//  numbernodes()   Number the vertices.                                     
//                                                                           
//  Each vertex is assigned a marker equal to its number.                    
//                                                                           
//  Used when writenodes() is not called because no .node file is written.   
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.numbernodes(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.numbernodes(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  GlobalMembersTriangle.REAL vertexloop;
  int vertexnumber;

  GlobalMembersTriangle.traversalinit(m.vertices);
  vertexnumber = b.firstnumber;
  vertexloop = GlobalMembersTriangle.vertextraverse(m);
  while (vertexloop != (GlobalMembersTriangle.REAL) null)
  {
	((int)(vertexloop))[m.vertexmarkindex] = vertexnumber;
	if (b.jettison == 0 || (((int)(vertexloop))[m.vertexmarkindex + 1] != -32767))
	{
	  vertexnumber++;
	}
	vertexloop = GlobalMembersTriangle.vertextraverse(m);
  }
}

//***************************************************************************
//                                                                           
//  writeelements()   Write the triangles to an .ele file.                   
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
void GlobalMembersTriangle.writeelements(struct mesh m, struct behavior b, int * trianglelist, GlobalMembersTriangle.REAL * triangleattriblist)
//#else
void GlobalMembersTriangle.writeelements(m, b, trianglelist, triangleattriblist)
mesh m;
behavior b;
int[] trianglelist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL[] triangleattriblist;
//#endif // not ANSI_DECLARATORS


//#else
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.writeelements(struct mesh m, struct behavior b, char elefilename, int argc, char **argv)
//#else
void GlobalMembersTriangle.writeelements(m, b, elefilename, argc, argv)
mesh m;
behavior b;
String elefilename;
int argc;
String[] argv;
//#endif // not ANSI_DECLARATORS

//#endif // not TRILIBRARY

{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  int tlist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL talist;
  int vertexindex;
  int attribindex;
//#else
  FILE outfile;
//#endif // not TRILIBRARY
  otri triangleloop = new otri();
  GlobalMembersTriangle.REAL p1;
  GlobalMembersTriangle.REAL p2;
  GlobalMembersTriangle.REAL p3;
  GlobalMembersTriangle.REAL mid1;
  GlobalMembersTriangle.REAL mid2;
  GlobalMembersTriangle.REAL mid3;
  int elementnumber;
  int i;

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  if (b.quiet == 0)
  {
	System.out.print("Writing triangles.\n");
  }
  // Allocate memory for output triangles if necessary. 
  if ( trianglelist == (int) null)
  {
	trianglelist = (int) GlobalMembersTriangle.trimalloc((int)(m.triangles.items * ((b.order + 1) * (b.order + 2) / 2) * sizeof(int)));
  }
  // Allocate memory for output triangle attributes if necessary. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  if ((m.eextras > 0) && ( triangleattriblist == (GlobalMembersTriangle.REAL) null))
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	triangleattriblist = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.trimalloc((int)(m.triangles.items m.eextras * sizeof(GlobalMembersTriangle.REAL)));
  }
  tlist = trianglelist;
  talist = triangleattriblist;
  vertexindex = 0;
  attribindex = 0;
//#else
  if (b.quiet == 0)
  {
	System.out.printf("Writing %s.\n", elefilename);
  }
  outfile = fopen(elefilename, "w");
  if (outfile == (FILE) null)
  {
	System.out.printf("  Error:  Cannot create file %s.\n", elefilename);
	GlobalMembersTriangle.triexit(1);
  }
  // Number of triangles, vertices per triangle, attributes per triangle. 
  fprintf(outfile, "%ld  %d  %d\n", m.triangles.items, (b.order + 1) * (b.order + 2) / 2, m.eextras);
//#endif // not TRILIBRARY

  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  triangleloop.orient = 0;
  elementnumber = b.firstnumber;
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	p1 = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.plus1mod3[(triangleloop).orient] + 3];
	p2 = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.minus1mod3[(triangleloop).orient] + 3];
	p3 = (GlobalMembersTriangle.REAL)(triangleloop).tri[(triangleloop).orient + 3];
	if (b.order == 1)
	{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	  tlist[vertexindex++] = ((int)(p1))[m.vertexmarkindex];
	  tlist[vertexindex++] = ((int)(p2))[m.vertexmarkindex];
	  tlist[vertexindex++] = ((int)(p3))[m.vertexmarkindex];
//#else
	  // Triangle number, indices for three vertices. 
	  fprintf(outfile, "%4ld    %4d  %4d  %4d", elementnumber, ((int)(p1))[m.vertexmarkindex], ((int)(p2))[m.vertexmarkindex], ((int)(p3))[m.vertexmarkindex]);
//#endif // not TRILIBRARY
	}
	else
	{
	  mid1 = (GlobalMembersTriangle.REAL) triangleloop.tri[m.highorderindex + 1];
	  mid2 = (GlobalMembersTriangle.REAL) triangleloop.tri[m.highorderindex + 2];
	  mid3 = (GlobalMembersTriangle.REAL) triangleloop.tri[m.highorderindex];
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	  tlist[vertexindex++] = ((int)(p1))[m.vertexmarkindex];
	  tlist[vertexindex++] = ((int)(p2))[m.vertexmarkindex];
	  tlist[vertexindex++] = ((int)(p3))[m.vertexmarkindex];
	  tlist[vertexindex++] = ((int)(mid1))[m.vertexmarkindex];
	  tlist[vertexindex++] = ((int)(mid2))[m.vertexmarkindex];
	  tlist[vertexindex++] = ((int)(mid3))[m.vertexmarkindex];
//#else
	  // Triangle number, indices for six vertices. 
	  fprintf(outfile, "%4ld    %4d  %4d  %4d  %4d  %4d  %4d", elementnumber, ((int)(p1))[m.vertexmarkindex], ((int)(p2))[m.vertexmarkindex], ((int)(p3))[m.vertexmarkindex], ((int)(mid1))[m.vertexmarkindex], ((int)(mid2))[m.vertexmarkindex], ((int)(mid3))[m.vertexmarkindex]);
//#endif // not TRILIBRARY
	}

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	for (i = 0; i < m.eextras; i++)
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  talist[attribindex++] = ((GlobalMembersTriangle.REAL)(triangleloop).tri)[m.elemattribindex + (i)];
	}
//#else
	for (i = 0; i < m.eextras; i++)
	{
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	  fprintf(outfile, "  %.17g", ((GlobalMembersTriangle.REAL)(triangleloop).tri)[m.elemattribindex + (i)]);
	}
	fprintf(outfile, "\n");
//#endif // not TRILIBRARY

	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
	elementnumber++;
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
  GlobalMembersTriangle.finishfile(outfile, argc, argv);
//#endif // not TRILIBRARY
}

//***************************************************************************
//                                                                           
//  writepoly()   Write the segments and holes to a .poly file.              
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.writepoly(struct mesh m, struct behavior b, int segmentlist, int segmentmarkerlist)
//#else
void GlobalMembersTriangle.writepoly(m, b, segmentlist, segmentmarkerlist)
mesh m;
behavior b;
int[] segmentlist;
int[] segmentmarkerlist;
//#endif // not ANSI_DECLARATORS


//#else
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
void GlobalMembersTriangle.writepoly(struct mesh m, struct behavior b, char polyfilename, GlobalMembersTriangle.REAL holelist, int holes, GlobalMembersTriangle.REAL regionlist, int regions, int argc, char **argv)
//#else
void GlobalMembersTriangle.writepoly(m, b, polyfilename, holelist, holes, regionlist, regions, argc, argv)
mesh m;
behavior b;
String polyfilename;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL holelist;
int holes;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL regionlist;
int regions;
int argc;
String[] argv;
//#endif // not ANSI_DECLARATORS

//#endif // not TRILIBRARY

{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  int slist;
  int smlist;
  int index;
//#else
  FILE outfile;
  int holenumber;
  int regionnumber;
//#endif // not TRILIBRARY
  osub subsegloop = new osub();
  GlobalMembersTriangle.REAL endpoint1;
  GlobalMembersTriangle.REAL endpoint2;
  int subsegnumber;

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  if (b.quiet == 0)
  {
	System.out.print("Writing segments.\n");
  }
  // Allocate memory for output segments if necessary. 
  if ( segmentlist == (int) null)
  {
	segmentlist = (int) GlobalMembersTriangle.trimalloc((int)(m.subsegs.items * 2 * sizeof(int)));
  }
  // Allocate memory for output segment markers if necessary. 
  if (b.nobound == 0 && ( segmentmarkerlist == (int) null))
  {
	segmentmarkerlist = (int) GlobalMembersTriangle.trimalloc((int)(m.subsegs.items * sizeof(int)));
  }
  slist = segmentlist;
  smlist = segmentmarkerlist;
  index = 0;
//#else
  if (b.quiet == 0)
  {
	System.out.printf("Writing %s.\n", polyfilename);
  }
  outfile = fopen(polyfilename, "w");
  if (outfile == (FILE) null)
  {
	System.out.printf("  Error:  Cannot create file %s.\n", polyfilename);
	GlobalMembersTriangle.triexit(1);
  }
  // The zero indicates that the vertices are in a separate .node file. 
  //   Followed by number of dimensions, number of vertex attributes,   
  //   and number of boundary markers (zero or one).                    
  fprintf(outfile, "%d  %d  %d  %d\n", 0, m.mesh_dim, m.nextras, 1 - b.nobound);
  // Number of segments, number of boundary markers (zero or one). 
  fprintf(outfile, "%ld  %d\n", m.subsegs.items, 1 - b.nobound);
//#endif // not TRILIBRARY

  GlobalMembersTriangle.traversalinit(m.subsegs);
  subsegloop.ss = GlobalMembersTriangle.subsegtraverse(m);
  subsegloop.ssorient = 0;
  subsegnumber = b.firstnumber;
  while (subsegloop.ss != (GlobalMembersTriangle.REAL ** *) null)
  {
	endpoint1 = (GlobalMembersTriangle.REAL)(subsegloop).ss[2 + (subsegloop).ssorient];
	endpoint2 = (GlobalMembersTriangle.REAL)(subsegloop).ss[3 - (subsegloop).ssorient];
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	// Copy indices of the segment's two endpoints. 
	slist[index++] = ((int)(endpoint1))[m.vertexmarkindex];
	slist[index++] = ((int)(endpoint2))[m.vertexmarkindex];
	if (b.nobound == 0)
	{
	  // Copy the boundary marker. 
	  smlist[subsegnumber - b.firstnumber] = (* (int)((subsegloop).ss + 8));
	}
//#else
	// Segment number, indices of its two endpoints, and possibly a marker. 
	if (b.nobound != 0)
	{
	  fprintf(outfile, "%4ld    %4d  %4d\n", subsegnumber, ((int)(endpoint1))[m.vertexmarkindex], ((int)(endpoint2))[m.vertexmarkindex]);
	}
	else
	{
	  fprintf(outfile, "%4ld    %4d  %4d    %4d\n", subsegnumber, ((int)(endpoint1))[m.vertexmarkindex], ((int)(endpoint2))[m.vertexmarkindex], (* (int)((subsegloop).ss + 8)));
	}
//#endif // not TRILIBRARY

	subsegloop.ss = GlobalMembersTriangle.subsegtraverse(m);
	subsegnumber++;
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
  fprintf(outfile, "%d\n", holes);
  if (holes > 0)
  {
	for (holenumber = 0; holenumber < holes; holenumber++)
	{
	  // Hole number, x and y coordinates. 
	  fprintf(outfile, "%4ld   %.17g  %.17g\n", b.firstnumber + holenumber, holelist[2 * holenumber], holelist[2 * holenumber + 1]);
	}
  }
  if (regions > 0)
  {
	fprintf(outfile, "%d\n", regions);
	for (regionnumber = 0; regionnumber < regions; regionnumber++)
	{
	  // Region number, x and y coordinates, attribute, maximum area. 
	  fprintf(outfile, "%4ld   %.17g  %.17g  %.17g  %.17g\n", b.firstnumber + regionnumber, regionlist[4 * regionnumber], regionlist[4 * regionnumber + 1], regionlist[4 * regionnumber + 2], regionlist[4 * regionnumber + 3]);
	}
  }
//#endif // not CDT_ONLY

  GlobalMembersTriangle.finishfile(outfile, argc, argv);
//#endif // not TRILIBRARY
}

//***************************************************************************
//                                                                           
//  writeedges()   Write the edges to an .edge file.                         
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.writeedges(struct mesh m, struct behavior b, int **edgelist, int **edgemarkerlist)
//#else
void GlobalMembersTriangle.writeedges(m, b, edgelist, edgemarkerlist)
mesh m;
behavior b;
int[] edgelist;
int[] edgemarkerlist;
//#endif // not ANSI_DECLARATORS


//#else
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.writeedges(struct mesh m, struct behavior b, char *edgefilename, int argc, char **argv)
//#else
void GlobalMembersTriangle.writeedges(m, b, edgefilename, argc, argv)
mesh m;
behavior b;
String edgefilename;
int argc;
String[] argv;
//#endif // not ANSI_DECLARATORS

//#endif // not TRILIBRARY

{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  int elist;
  int emlist;
  int index;
//#else
  FILE outfile;
//#endif // not TRILIBRARY
  otri triangleloop = new otri();
  otri trisym = new otri();
  osub checkmark = new osub();
  GlobalMembersTriangle.REAL p1;
  GlobalMembersTriangle.REAL p2;
  int edgenumber;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().
  GlobalMembersTriangle.REAL[][] sptr; // Temporary variable used by tspivot().

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  if (b.quiet == 0)
  {
	System.out.print("Writing edges.\n");
  }
  // Allocate memory for edges if necessary. 
  if (*edgelist == (int) null)
  {
	*edgelist = (int) GlobalMembersTriangle.trimalloc((int)(m.edges * 2 * sizeof(int)));
  }
  // Allocate memory for edge markers if necessary. 
  if (b.nobound == 0 && (*edgemarkerlist == (int) null))
  {
	*edgemarkerlist = (int) GlobalMembersTriangle.trimalloc((int)(m.edges * sizeof(int)));
  }
  elist = *edgelist;
  emlist = *edgemarkerlist;
  index = 0;
//#else
  if (b.quiet == 0)
  {
	System.out.printf("Writing %s.\n", edgefilename);
  }
  outfile = fopen(edgefilename, "w");
  if (outfile == (FILE) null)
  {
	System.out.printf("  Error:  Cannot create file %s.\n", edgefilename);
	GlobalMembersTriangle.triexit(1);
  }
  // Number of edges, number of boundary markers (zero or one). 
  fprintf(outfile, "%ld  %d\n", m.edges, 1 - b.nobound);
//#endif // not TRILIBRARY

  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  edgenumber = b.firstnumber;
  // To loop over the set of edges, loop over all triangles, and look at   
  //   the three edges of each triangle.  If there isn't another triangle  
  //   adjacent to the edge, operate on the edge.  If there is another     
  //   adjacent triangle, operate on the edge only if the current triangle 
  //   has a smaller pointer than its neighbor.  This way, each edge is    
  //   considered only once.                                               
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	for (triangleloop.orient = 0; triangleloop.orient < 3; triangleloop.orient++)
	{
	  ptr = (triangleloop).tri[(triangleloop).orient];
	  (trisym).orient = (int)((int)(ptr) & (int) 3l);
	  (trisym).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(trisym).orient);
	  ;
	  if ((triangleloop.tri < trisym.tri) || (trisym.tri == m.dummytri))
	  {
		p1 = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.plus1mod3[(triangleloop).orient] + 3];
		p2 = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.minus1mod3[(triangleloop).orient] + 3];
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
		elist[index++] = ((int)(p1))[m.vertexmarkindex];
		elist[index++] = ((int)(p2))[m.vertexmarkindex];
//#endif // TRILIBRARY
		if (b.nobound != 0)
		{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
		  // Edge number, indices of two endpoints. 
		  fprintf(outfile, "%4ld   %d  %d\n", edgenumber, ((int)(p1))[m.vertexmarkindex], ((int)(p2))[m.vertexmarkindex]);
//#endif // not TRILIBRARY
		}
		else
		{
		  // Edge number, indices of two endpoints, and a boundary marker. 
		  //   If there's no subsegment, the boundary marker is zero.      
		  if (b.usesegments != 0)
		  {
			sptr = (GlobalMembersTriangle.REAL)(triangleloop).tri[6 + (triangleloop).orient];
			(checkmark).ssorient = (int)((int)(sptr) & (int) 1l);
			(checkmark).ss = (GlobalMembersTriangle.REAL ** *)((int)(sptr) & ~ (int) 3l);
			if (checkmark.ss == m.dummysub)
			{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
			  emlist[edgenumber - b.firstnumber] = 0;
//#else
			  fprintf(outfile, "%4ld   %d  %d  %d\n", edgenumber, ((int)(p1))[m.vertexmarkindex], ((int)(p2))[m.vertexmarkindex], 0);
//#endif // not TRILIBRARY
			}
			else
			{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
			  emlist[edgenumber - b.firstnumber] = (* (int)((checkmark).ss + 8));
//#else
			  fprintf(outfile, "%4ld   %d  %d  %d\n", edgenumber, ((int)(p1))[m.vertexmarkindex], ((int)(p2))[m.vertexmarkindex], (* (int)((checkmark).ss + 8)));
//#endif // not TRILIBRARY
			}
			}
		  else
		  {
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
			emlist[edgenumber - b.firstnumber] = trisym.tri == m.dummytri;
//#else
			fprintf(outfile, "%4ld   %d  %d  %d\n", edgenumber, ((int)(p1))[m.vertexmarkindex], ((int)(p2))[m.vertexmarkindex], trisym.tri == m.dummytri);
//#endif // not TRILIBRARY
		  }
		}
		edgenumber++;
	  }
	}
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
  GlobalMembersTriangle.finishfile(outfile, argc, argv);
//#endif // not TRILIBRARY
}

//***************************************************************************
//                                                                           
//  writevoronoi()   Write the Voronoi diagram to a .v.node and .v.edge      
//                   file.                                                   
//                                                                           
//  The Voronoi diagram is the geometric dual of the Delaunay triangulation. 
//  Hence, the Voronoi vertices are listed by traversing the Delaunay        
//  triangles, and the Voronoi edges are listed by traversing the Delaunay   
//  edges.                                                                   
//                                                                           
//  WARNING:  In order to assign numbers to the Voronoi vertices, this       
//  procedure messes up the subsegments or the extra nodes of every          
//  element.  Hence, you should call this procedure last.                    
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
void GlobalMembersTriangle.writevoronoi(struct mesh m, struct behavior b, GlobalMembersTriangle.REAL **vpointlist, GlobalMembersTriangle.REAL **vpointattriblist, int **vpointmarkerlist, int **vedgelist, int **vedgemarkerlist, GlobalMembersTriangle.REAL **vnormlist)
//#else
void GlobalMembersTriangle.writevoronoi(m, b, vpointlist, vpointattriblist, vpointmarkerlist, vedgelist, vedgemarkerlist, vnormlist)
mesh m;
behavior b;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL[] vpointlist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL[] vpointattriblist;
int[] vpointmarkerlist;
int[] vedgelist;
int[] vedgemarkerlist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
GlobalMembersTriangle.REAL[] vnormlist;
//#endif // not ANSI_DECLARATORS


//#else
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.writevoronoi(struct mesh m, struct behavior b, char *vnodefilename, char *vedgefilename, int argc, char **argv)
//#else
void GlobalMembersTriangle.writevoronoi(m, b, vnodefilename, vedgefilename, argc, argv)
mesh m;
behavior b;
String vnodefilename;
String vedgefilename;
int argc;
String[] argv;
//#endif // not ANSI_DECLARATORS

//#endif // not TRILIBRARY

{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL plist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL palist;
  int elist;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL normlist;
  int coordindex;
  int attribindex;
//#else
  FILE outfile;
//#endif // not TRILIBRARY
  otri triangleloop = new otri();
  otri trisym = new otri();
  GlobalMembersTriangle.REAL torg;
  GlobalMembersTriangle.REAL tdest;
  GlobalMembersTriangle.REAL tapex;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] circumcenter = new GlobalMembersTriangle.REAL[2];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL xi;
  GlobalMembersTriangle.REAL eta;
  int vnodenumber;
  int vedgenumber;
  int p1;
  int p2;
  int i;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  if (b.quiet == 0)
  {
	System.out.print("Writing Voronoi vertices.\n");
  }
  // Allocate memory for Voronoi vertices if necessary. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  if (*vpointlist == (GlobalMembersTriangle.REAL) null)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	*vpointlist = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.trimalloc((int)(m.triangles.items * 2 * sizeof(GlobalMembersTriangle.REAL)));
  }
  // Allocate memory for Voronoi vertex attributes if necessary. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  if (*vpointattriblist == (GlobalMembersTriangle.REAL) null)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	*vpointattriblist = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.trimalloc((int)(m.triangles.items m.nextras * sizeof(GlobalMembersTriangle.REAL)));
  }
  *vpointmarkerlist = (int) null;
  plist = *vpointlist;
  palist = *vpointattriblist;
  coordindex = 0;
  attribindex = 0;
//#else
  if (b.quiet == 0)
  {
	System.out.printf("Writing %s.\n", vnodefilename);
  }
  outfile = fopen(vnodefilename, "w");
  if (outfile == (FILE) null)
  {
	System.out.printf("  Error:  Cannot create file %s.\n", vnodefilename);
	GlobalMembersTriangle.triexit(1);
  }
  // Number of triangles, two dimensions, number of vertex attributes, 
  //   no markers.                                                     
  fprintf(outfile, "%ld  %d  %d  %d\n", m.triangles.items, 2, m.nextras, 0);
//#endif // not TRILIBRARY

  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  triangleloop.orient = 0;
  vnodenumber = b.firstnumber;
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	torg = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.plus1mod3[(triangleloop).orient] + 3];
	tdest = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.minus1mod3[(triangleloop).orient] + 3];
	tapex = (GlobalMembersTriangle.REAL)(triangleloop).tri[(triangleloop).orient + 3];
	GlobalMembersTriangle.findcircumcenter(m, b, torg, tdest, tapex, circumcenter, xi, eta, 0);
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	// X and y coordinates. 
	plist[coordindex++] = circumcenter[0];
	plist[coordindex++] = circumcenter[1];
	for (i = 2; i < 2 + m.nextras; i++)
	{
	  // Interpolate the vertex attributes at the circumcenter. 
	  palist[attribindex++] = torg[i] + xi * (tdest[i] - torg[i]) + eta * (tapex[i] - torg[i]);
	}
//#else
	// Voronoi vertex number, x and y coordinates. 
	fprintf(outfile, "%4ld    %.17g  %.17g", vnodenumber, circumcenter[0], circumcenter[1]);
	for (i = 2; i < 2 + m.nextras; i++)
	{
	  // Interpolate the vertex attributes at the circumcenter. 
	  fprintf(outfile, "  %.17g", torg[i] + xi * (tdest[i] - torg[i]) + eta * (tapex[i] - torg[i]));
	}
	fprintf(outfile, "\n");
//#endif // not TRILIBRARY

//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
//	* (int *)(triangleloop.tri + 6) = (int) vnodenumber;
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
	vnodenumber++;
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
  GlobalMembersTriangle.finishfile(outfile, argc, argv);
//#endif // not TRILIBRARY

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  if (b.quiet == 0)
  {
	System.out.print("Writing Voronoi edges.\n");
  }
  // Allocate memory for output Voronoi edges if necessary. 
  if (*vedgelist == (int) null)
  {
	*vedgelist = (int) GlobalMembersTriangle.trimalloc((int)(m.edges * 2 * sizeof(int)));
  }
  *vedgemarkerlist = (int) null;
  // Allocate memory for output Voronoi norms if necessary. 
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  if (*vnormlist == (GlobalMembersTriangle.REAL) null)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	*vnormlist = (GlobalMembersTriangle.REAL) GlobalMembersTriangle.trimalloc((int)(m.edges * 2 * sizeof(GlobalMembersTriangle.REAL)));
  }
  elist = *vedgelist;
  normlist = *vnormlist;
  coordindex = 0;
//#else
  if (b.quiet == 0)
  {
	System.out.printf("Writing %s.\n", vedgefilename);
  }
  outfile = fopen(vedgefilename, "w");
  if (outfile == (FILE) null)
  {
	System.out.printf("  Error:  Cannot create file %s.\n", vedgefilename);
	GlobalMembersTriangle.triexit(1);
  }
  // Number of edges, zero boundary markers. 
  fprintf(outfile, "%ld  %d\n", m.edges, 0);
//#endif // not TRILIBRARY

  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  vedgenumber = b.firstnumber;
  // To loop over the set of edges, loop over all triangles, and look at   
  //   the three edges of each triangle.  If there isn't another triangle  
  //   adjacent to the edge, operate on the edge.  If there is another     
  //   adjacent triangle, operate on the edge only if the current triangle 
  //   has a smaller pointer than its neighbor.  This way, each edge is    
  //   considered only once.                                               
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	for (triangleloop.orient = 0; triangleloop.orient < 3; triangleloop.orient++)
	{
	  ptr = (triangleloop).tri[(triangleloop).orient];
	  (trisym).orient = (int)((int)(ptr) & (int) 3l);
	  (trisym).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(trisym).orient);
	  ;
	  if ((triangleloop.tri < trisym.tri) || (trisym.tri == m.dummytri))
	  {
		// Find the number of this triangle (and Voronoi vertex). 
		p1 = * (int)(triangleloop.tri + 6);
		if (trisym.tri == m.dummytri)
		{
		  torg = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.plus1mod3[(triangleloop).orient] + 3];
		  tdest = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.minus1mod3[(triangleloop).orient] + 3];
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
		  // Copy an infinite ray.  Index of one endpoint, and -1. 
		  elist[coordindex] = p1;
		  normlist[coordindex++] = tdest[1] - torg[1];
		  elist[coordindex] = -1;
		  normlist[coordindex++] = torg[0] - tdest[0];
//#else
		  // Write an infinite ray.  Edge number, index of one endpoint, -1, 
		  //   and x and y coordinates of a vector representing the          
		  //   direction of the ray.                                         
		  fprintf(outfile, "%4ld   %d  %d   %.17g  %.17g\n", vedgenumber, p1, -1, tdest[1] - torg[1], torg[0] - tdest[0]);
//#endif // not TRILIBRARY
		}
		else
		{
		  // Find the number of the adjacent triangle (and Voronoi vertex). 
		  p2 = * (int)(trisym.tri + 6);
		  // Finite edge.  Write indices of two endpoints. 
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
		  elist[coordindex] = p1;
		  normlist[coordindex++] = 0.0;
		  elist[coordindex] = p2;
		  normlist[coordindex++] = 0.0;
//#else
		  fprintf(outfile, "%4ld   %d  %d\n", vedgenumber, p1, p2);
//#endif // not TRILIBRARY
		}
		vedgenumber++;
	  }
	}
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
  GlobalMembersTriangle.finishfile(outfile, argc, argv);
//#endif // not TRILIBRARY
}


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.writeneighbors(struct mesh m, struct behavior b, int **neighborlist)
//#else
void GlobalMembersTriangle.writeneighbors(m, b, neighborlist)
mesh m;
behavior b;
int[] neighborlist;
//#endif // not ANSI_DECLARATORS


//#else
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.writeneighbors(struct mesh m, struct behavior b, char *neighborfilename, int argc, char **argv)
//#else
void GlobalMembersTriangle.writeneighbors(m, b, neighborfilename, argc, argv)
mesh m;
behavior b;
String neighborfilename;
int argc;
String[] argv;
//#endif // not ANSI_DECLARATORS

//#endif // not TRILIBRARY

{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  int nlist;
  int index;
//#else
  FILE outfile;
//#endif // not TRILIBRARY
  otri triangleloop = new otri();
  otri trisym = new otri();
  int elementnumber;
  int neighbor1;
  int neighbor2;
  int neighbor3;
  GlobalMembersTriangle.REAL[][] ptr; // Temporary variable used by sym().

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  if (b.quiet == 0)
  {
	System.out.print("Writing neighbors.\n");
  }
  // Allocate memory for neighbors if necessary. 
  if (*neighborlist == (int) null)
  {
	*neighborlist = (int) GlobalMembersTriangle.trimalloc((int)(m.triangles.items * 3 * sizeof(int)));
  }
  nlist = *neighborlist;
  index = 0;
//#else
  if (b.quiet == 0)
  {
	System.out.printf("Writing %s.\n", neighborfilename);
  }
  outfile = fopen(neighborfilename, "w");
  if (outfile == (FILE) null)
  {
	System.out.printf("  Error:  Cannot create file %s.\n", neighborfilename);
	GlobalMembersTriangle.triexit(1);
  }
  // Number of triangles, three neighbors per triangle. 
  fprintf(outfile, "%ld  %d\n", m.triangles.items, 3);
//#endif // not TRILIBRARY

  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  triangleloop.orient = 0;
  elementnumber = b.firstnumber;
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
//	* (int *)(triangleloop.tri + 6) = (int) elementnumber;
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
	elementnumber++;
  }
//C++ TO JAVA CONVERTER TODO TASK: There are no simple equivalents to function pointers in Java:
//  * (int *)(m->dummytri + 6) = -1;

  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  elementnumber = b.firstnumber;
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	triangleloop.orient = 1;
	ptr = (triangleloop).tri[(triangleloop).orient];
	(trisym).orient = (int)((int)(ptr) & (int) 3l);
	(trisym).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(trisym).orient);
	;
	neighbor1 = * (int)(trisym.tri + 6);
	triangleloop.orient = 2;
	ptr = (triangleloop).tri[(triangleloop).orient];
	(trisym).orient = (int)((int)(ptr) & (int) 3l);
	(trisym).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(trisym).orient);
	;
	neighbor2 = * (int)(trisym.tri + 6);
	triangleloop.orient = 0;
	ptr = (triangleloop).tri[(triangleloop).orient];
	(trisym).orient = (int)((int)(ptr) & (int) 3l);
	(trisym).tri = (GlobalMembersTriangle.REAL ** *)((int)(ptr) ^ (int)(trisym).orient);
	;
	neighbor3 = * (int)(trisym.tri + 6);
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	nlist[index++] = neighbor1;
	nlist[index++] = neighbor2;
	nlist[index++] = neighbor3;
//#else
	// Triangle number, neighboring triangle numbers. 
	fprintf(outfile, "%4ld    %d  %d  %d\n", elementnumber, neighbor1, neighbor2, neighbor3);
//#endif // not TRILIBRARY

	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
	elementnumber++;
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
  GlobalMembersTriangle.finishfile(outfile, argc, argv);
//#endif // not TRILIBRARY
}

//***************************************************************************
//                                                                           
//  writeoff()   Write the triangulation to an .off file.                    
//                                                                           
//  OFF stands for the Object File Format, a format used by the Geometry     
//  Center's Geomview package.                                               
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.writeoff(struct mesh m, struct behavior b, char *offfilename, int argc, char **argv)
//#else
void GlobalMembersTriangle.writeoff(m, b, offfilename, argc, argv)
mesh m;
behavior b;
String offfilename;
int argc;
String[] argv;
//#endif // not ANSI_DECLARATORS

{
  FILE outfile;
  otri triangleloop = new otri();
  GlobalMembersTriangle.REAL vertexloop;
  GlobalMembersTriangle.REAL p1;
  GlobalMembersTriangle.REAL p2;
  GlobalMembersTriangle.REAL p3;
  int outvertices;

  if (b.quiet == 0)
  {
	System.out.printf("Writing %s.\n", offfilename);
  }

  if (b.jettison != 0)
  {
	outvertices = m.vertices.items - m.undeads;
  }
  else
  {
	outvertices = m.vertices.items;
  }

  outfile = fopen(offfilename, "w");
  if (outfile == (FILE) null)
  {
	System.out.printf("  Error:  Cannot create file %s.\n", offfilename);
	GlobalMembersTriangle.triexit(1);
  }
  // Number of vertices, triangles, and edges. 
  fprintf(outfile, "OFF\n%ld  %ld  %ld\n", outvertices, m.triangles.items, m.edges);

  // Write the vertices. 
  GlobalMembersTriangle.traversalinit(m.vertices);
  vertexloop = GlobalMembersTriangle.vertextraverse(m);
  while (vertexloop != (GlobalMembersTriangle.REAL) null)
  {
	if (b.jettison == 0 || (((int)(vertexloop))[m.vertexmarkindex + 1] != -32767))
	{
	  // The "0.0" is here because the OFF format uses 3D coordinates. 
	  fprintf(outfile, " %.17g  %.17g  %.17g\n", vertexloop[0], vertexloop[1], 0.0);
	}
	vertexloop = GlobalMembersTriangle.vertextraverse(m);
  }

  // Write the triangles. 
  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  triangleloop.orient = 0;
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	p1 = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.plus1mod3[(triangleloop).orient] + 3];
	p2 = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.minus1mod3[(triangleloop).orient] + 3];
	p3 = (GlobalMembersTriangle.REAL)(triangleloop).tri[(triangleloop).orient + 3];
	// The "3" means a three-vertex polygon. 
	fprintf(outfile, " 3   %4d  %4d  %4d\n", ((int)(p1))[m.vertexmarkindex] - b.firstnumber, ((int)(p2))[m.vertexmarkindex] - b.firstnumber, ((int)(p3))[m.vertexmarkindex] - b.firstnumber);
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  }
  GlobalMembersTriangle.finishfile(outfile, argc, argv);
}

//#endif // not TRILIBRARY

//*                                                                         *
//*                                                                         *
//******** File I/O routines end here                                ********

//***************************************************************************
//                                                                           
//  quality_statistics()   Print statistics about the quality of the mesh.   
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.quality_statistics(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.quality_statistics(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  otri triangleloop = new otri();
  GlobalMembersTriangle.REAL[] p = new GlobalMembersTriangle.REAL[3];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] cossquaretable = new GlobalMembersTriangle.REAL[8];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] ratiotable = new GlobalMembersTriangle.REAL[16];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] dx = new GlobalMembersTriangle.REAL[3];
  GlobalMembersTriangle.REAL[] dy = new GlobalMembersTriangle.REAL[3];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL[] edgelength = new GlobalMembersTriangle.REAL[3];
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL dotproduct;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL cossquare;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL triarea;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL shortest;
  GlobalMembersTriangle.REAL longest;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL trilongest2;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL smallestarea;
  GlobalMembersTriangle.REAL biggestarea;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL triminaltitude2;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL minaltitude;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL triaspect2;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL worstaspect;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL smallestangle;
  GlobalMembersTriangle.REAL biggestangle;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL radconst;
  GlobalMembersTriangle.REAL degconst;
  int[] angletable = new int[18];
  int[] aspecttable = new int[16];
  int aspectindex;
  int tendegree;
  int acutebiggest;
  int i;
  int ii;
  int j;
  int k;

  System.out.print("Mesh quality statistics:\n\n");
  radconst = DefineConstantsTriangle.PI / 18.0;
  degconst = 180.0 / DefineConstantsTriangle.PI;
  for (i = 0; i < 8; i++)
  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
	cossquaretable[i] = Math.cos(radconst * (GlobalMembersTriangle.REAL)(i + 1));
	cossquaretable[i] = cossquaretable[i] * cossquaretable[i];
  }
  for (i = 0; i < 18; i++)
  {
	angletable[i] = 0;
  }

  ratiotable[0] = 1.5;
  ratiotable[1] = 2.0;
  ratiotable[2] = 2.5;
  ratiotable[3] = 3.0;
  ratiotable[4] = 4.0;
  ratiotable[5] = 6.0;
  ratiotable[6] = 10.0;
  ratiotable[7] = 15.0;
  ratiotable[8] = 25.0;
  ratiotable[9] = 50.0;
  ratiotable[10] = 100.0;
  ratiotable[11] = 300.0;
  ratiotable[12] = 1000.0;
  ratiotable[13] = 10000.0;
  ratiotable[14] = 100000.0;
  ratiotable[15] = 0.0;
  for (i = 0; i < 16; i++)
  {
	aspecttable[i] = 0;
  }

  worstaspect = 0.0;
  minaltitude = m.xmax - m.xmin + m.ymax - m.ymin;
  minaltitude = minaltitude * minaltitude;
  shortest = minaltitude;
  longest = 0.0;
  smallestarea = minaltitude;
  biggestarea = 0.0;
  worstaspect = 0.0;
  smallestangle = 0.0;
  biggestangle = 2.0;
  acutebiggest = 1;

  GlobalMembersTriangle.traversalinit(m.triangles);
  triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  triangleloop.orient = 0;
  while (triangleloop.tri != (GlobalMembersTriangle.REAL ** *) null)
  {
	p[0] = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.plus1mod3[(triangleloop).orient] + 3];
	p[1] = (GlobalMembersTriangle.REAL)(triangleloop).tri[GlobalMembersTriangle.minus1mod3[(triangleloop).orient] + 3];
	p[2] = (GlobalMembersTriangle.REAL)(triangleloop).tri[(triangleloop).orient + 3];
	trilongest2 = 0.0;

	for (i = 0; i < 3; i++)
	{
	  j = GlobalMembersTriangle.plus1mod3[i];
	  k = GlobalMembersTriangle.minus1mod3[i];
	  dx[i] = p[j][0] - p[k][0];
	  dy[i] = p[j][1] - p[k][1];
	  edgelength[i] = dx[i] * dx[i] + dy[i] * dy[i];
	  if (edgelength[i] > trilongest2)
	  {
		trilongest2 = edgelength[i];
	  }
	  if (edgelength[i] > longest)
	  {
		longest = edgelength[i];
	  }
	  if (edgelength[i] < shortest)
	  {
		shortest = edgelength[i];
	  }
	}

	triarea = GlobalMembersTriangle.counterclockwise(m, b, p[0], p[1], p[2]);
	if (triarea < smallestarea)
	{
	  smallestarea = triarea;
	}
	if (triarea > biggestarea)
	{
	  biggestarea = triarea;
	}
	triminaltitude2 = triarea * triarea / trilongest2;
	if (triminaltitude2 < minaltitude)
	{
	  minaltitude = triminaltitude2;
	}
	triaspect2 = trilongest2 / triminaltitude2;
	if (triaspect2 > worstaspect)
	{
	  worstaspect = triaspect2;
	}
	aspectindex = 0;
	while ((triaspect2 > ratiotable[aspectindex] * ratiotable[aspectindex]) && (aspectindex < 15))
	{
	  aspectindex++;
	}
	aspecttable[aspectindex]++;

	for (i = 0; i < 3; i++)
	{
	  j = GlobalMembersTriangle.plus1mod3[i];
	  k = GlobalMembersTriangle.minus1mod3[i];
	  dotproduct = dx[j] * dx[k] + dy[j] * dy[k];
	  cossquare = dotproduct * dotproduct / (edgelength[j] * edgelength[k]);
	  tendegree = 8;
	  for (ii = 7; ii >= 0; ii--)
	  {
		if (cossquare > cossquaretable[ii])
		{
		  tendegree = ii;
		}
	  }
	  if (dotproduct <= 0.0)
	  {
		angletable[tendegree]++;
		if (cossquare > smallestangle)
		{
		  smallestangle = cossquare;
		}
		if (acutebiggest != 0 && (cossquare < biggestangle))
		{
		  biggestangle = cossquare;
		}
		}
	  else
	  {
		angletable[17 - tendegree]++;
		if (acutebiggest != 0 || (cossquare > biggestangle))
		{
		  biggestangle = cossquare;
		  acutebiggest = 0;
		}
	  }
	}
	triangleloop.tri = GlobalMembersTriangle.triangletraverse(m);
  }

  shortest = Math.sqrt(shortest);
  longest = Math.sqrt(longest);
  minaltitude = Math.sqrt(minaltitude);
  worstaspect = Math.sqrt(worstaspect);
  smallestarea *= 0.5;
  biggestarea *= 0.5;
  if (smallestangle >= 1.0)
  {
	smallestangle = 0.0;
  }
  else
  {
	smallestangle = degconst * Math.acos(Math.sqrt(smallestangle));
  }
  if (biggestangle >= 1.0)
  {
	biggestangle = 180.0;
  }
  else
  {
	if (acutebiggest != 0)
	{
	  biggestangle = degconst * Math.acos(Math.sqrt(biggestangle));
	}
	else
	{
	  biggestangle = 180.0 - degconst * Math.acos(Math.sqrt(biggestangle));
	}
  }

  System.out.printf("  Smallest area: %16.5g   |  Largest area: %16.5g\n", smallestarea, biggestarea);
  System.out.printf("  Shortest edge: %16.5g   |  Longest edge: %16.5g\n", shortest, longest);
  System.out.printf("  Shortest altitude: %12.5g   |  Largest aspect ratio: %8.5g\n\n", minaltitude, worstaspect);

  System.out.print("  Triangle aspect ratio histogram:\n");
  System.out.printf("  1.1547 - %-6.6g    :  %8d    | %6.6g - %-6.6g     :  %8d\n", ratiotable[0], aspecttable[0], ratiotable[7], ratiotable[8], aspecttable[8]);
  for (i = 1; i < 7; i++)
  {
	System.out.printf("  %6.6g - %-6.6g    :  %8d    | %6.6g - %-6.6g     :  %8d\n", ratiotable[i - 1], ratiotable[i], aspecttable[i], ratiotable[i + 7], ratiotable[i + 8], aspecttable[i + 8]);
  }
  System.out.printf("  %6.6g - %-6.6g    :  %8d    | %6.6g -            :  %8d\n", ratiotable[6], ratiotable[7], aspecttable[7], ratiotable[14], aspecttable[15]);
  System.out.print("  (Aspect ratio is longest edge divided by shortest altitude)\n\n");

  System.out.printf("  Smallest angle: %15.5g   |  Largest angle: %15.5g\n\n", smallestangle, biggestangle);

  System.out.print("  Angle histogram:\n");
  for (i = 0; i < 9; i++)
  {
	System.out.printf("    %3d - %3d degrees:  %8d    |    %3d - %3d degrees:  %8d\n", i * 10, i * 10 + 10, angletable[i], i * 10 + 90, i * 10 + 100, angletable[i + 9]);
  }
  System.out.print("\n");
}

//***************************************************************************
//                                                                           
//  statistics()   Print all sorts of cool facts.                            
//                                                                           
//***************************************************************************

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.statistics(struct mesh m, struct behavior b)
//#else
void GlobalMembersTriangle.statistics(m, b)
mesh m;
behavior b;
//#endif // not ANSI_DECLARATORS

{
  System.out.print("\nStatistics:\n\n");
  System.out.printf("  Input vertices: %d\n", m.invertices);
  if (b.refine != 0)
  {
	System.out.printf("  Input triangles: %d\n", m.inelements);
  }
  if (b.poly != 0)
  {
	System.out.printf("  Input segments: %d\n", m.insegments);
	if (b.refine == 0)
	{
	  System.out.printf("  Input holes: %d\n", m.holes);
	}
  }

  System.out.printf("\n  Mesh vertices: %ld\n", m.vertices.items - m.undeads);
  System.out.printf("  Mesh triangles: %ld\n", m.triangles.items);
  System.out.printf("  Mesh edges: %ld\n", m.edges);
  System.out.printf("  Mesh exterior boundary edges: %ld\n", m.hullsize);
  if (b.poly != 0 || b.refine != 0)
  {
	System.out.printf("  Mesh interior boundary edges: %ld\n", m.subsegs.items - m.hullsize);
	System.out.printf("  Mesh subsegments (constrained edges): %ld\n", m.subsegs.items);
  }
  System.out.print("\n");

  if (b.verbose != 0)
  {
	GlobalMembersTriangle.quality_statistics(m, b);
	System.out.print("Memory allocation statistics:\n\n");
	System.out.printf("  Maximum number of vertices: %ld\n", m.vertices.maxitems);
	System.out.printf("  Maximum number of triangles: %ld\n", m.triangles.maxitems);
	if (m.subsegs.maxitems > 0)
	{
	  System.out.printf("  Maximum number of subsegments: %ld\n", m.subsegs.maxitems);
	}
	if (m.viri.maxitems > 0)
	{
	  System.out.printf("  Maximum number of viri: %ld\n", m.viri.maxitems);
	}
	if (m.badsubsegs.maxitems > 0)
	{
	  System.out.printf("  Maximum number of encroached subsegments: %ld\n", m.badsubsegs.maxitems);
	}
	if (m.badtriangles.maxitems > 0)
	{
	  System.out.printf("  Maximum number of bad triangles: %ld\n", m.badtriangles.maxitems);
	}
	if (m.flipstackers.maxitems > 0)
	{
	  System.out.printf("  Maximum number of stacked triangle flips: %ld\n", m.flipstackers.maxitems);
	}
	if (m.splaynodes.maxitems > 0)
	{
	  System.out.printf("  Maximum number of splay tree nodes: %ld\n", m.splaynodes.maxitems);
	}
	System.out.printf("  Approximate heap memory use (bytes): %ld\n\n", m.vertices.maxitems m.vertices.itembytes + m.triangles.maxitems m.triangles.itembytes + m.subsegs.maxitems m.subsegs.itembytes + m.viri.maxitems m.viri.itembytes + m.badsubsegs.maxitems m.badsubsegs.itembytes + m.badtriangles.maxitems m.badtriangles.itembytes + m.flipstackers.maxitems m.flipstackers.itembytes + m.splaynodes.maxitems m.splaynodes.itembytes);

	System.out.print("Algorithmic statistics:\n\n");
	if (b.weighted == 0)
	{
	  System.out.printf("  Number of incircle tests: %ld\n", m.incirclecount);
	}
	else
	{
	  System.out.printf("  Number of 3D orientation tests: %ld\n", m.orient3dcount);
	}
	System.out.printf("  Number of 2D orientation tests: %ld\n", m.counterclockcount);
	if (m.hyperbolacount > 0)
	{
	  System.out.printf("  Number of right-of-hyperbola tests: %ld\n", m.hyperbolacount);
	}
	if (m.circletopcount > 0)
	{
	  System.out.printf("  Number of circle top computations: %ld\n", m.circletopcount);
	}
	if (m.circumcentercount > 0)
	{
	  System.out.printf("  Number of triangle circumcenter computations: %ld\n", m.circumcentercount);
	}
	System.out.print("\n");
  }
}

//***************************************************************************
//                                                                           
//  main() or triangulate()   Gosh, do everything.                           
//                                                                           
//  The sequence is roughly as follows.  Many of these steps can be skipped, 
//  depending on the command line switches.                                  
//                                                                           
//  - Initialize constants and parse the command line.                       
//  - Read the vertices from a file and either                               
//    - triangulate them (no -r), or                                         
//    - read an old mesh from files and reconstruct it (-r).                 
//  - Insert the PSLG segments (-p), and possibly segments on the convex     
//      hull (-c).                                                           
//  - Read the holes (-p), regional attributes (-pA), and regional area      
//      constraints (-pa).  Carve the holes and concavities, and spread the  
//      regional attributes and area constraints.                            
//  - Enforce the constraints on minimum angle (-q) and maximum area (-a).   
//      Also enforce the conforming Delaunay property (-q and -a).           
//  - Compute the number of edges in the resulting mesh.                     
//  - Promote the mesh's linear triangles to higher order elements (-o).     
//  - Write the output files and print the statistics.                       
//  - Check the consistency and Delaunay property of the mesh (-C).          
//                                                                           
//***************************************************************************


//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
void GlobalMembersTriangle.triangulate(String triswitches, struct triangulateio *in, struct triangulateio *out, struct triangulateio *vorout)
//#else
void GlobalMembersTriangle.triangulate(triswitches, in, out, vorout)
String triswitches;
triangulateio in;
triangulateio out;
triangulateio vorout;
//#endif // not ANSI_DECLARATORS


//#else
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ANSI_DECLARATORS
int main(int argc, char **argv)
//#else
int main(argc, argv)
int argc;
String[] argv;
//#endif // not ANSI_DECLARATORS

//#endif // not TRILIBRARY

{
  mesh m = new mesh();
  behavior b = new behavior();
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL holearray; // Array of holes.
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
  GlobalMembersTriangle.REAL regionarray; // Array of regional attributes and area constraints.
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
  FILE polyfile;
//#endif // not TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! NO_TIMER
  // Variables for timing the performance of Triangle.  The types are 
  //   defined in sys/time.h.                                         
  timeval tv0;
  timeval tv1;
  timeval tv2;
  timeval tv3;
  timeval tv4;
  timeval tv5;
  timeval tv6;
  timezone tz;
//#endif // not NO_TIMER

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! NO_TIMER
  gettimeofday(tv0, tz);
//#endif // not NO_TIMER

  GlobalMembersTriangle.triangleinit(m);
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  GlobalMembersTriangle.parsecommandline(1, triswitches, b);
//#else
  GlobalMembersTriangle.parsecommandline(argc, argv, b);
//#endif // not TRILIBRARY
  m.steinerleft = b.steiner;

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  GlobalMembersTriangle.transfernodes(m, b, in.pointlist, in.pointattributelist, in.pointmarkerlist, in.numberofpoints, in.numberofpointattributes);
//#else
  GlobalMembersTriangle.readnodes(m, b, b.innodefilename, b.inpolyfilename, polyfile);
//#endif // not TRILIBRARY

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! NO_TIMER
  if (b.quiet == 0)
  {
	gettimeofday(tv1, tz);
  }
//#endif // not NO_TIMER

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if CDT_ONLY
  m.hullsize = GlobalMembersTriangle.delaunay(m, b); // Triangulate the vertices.
//#else
  if (b.refine != 0)
  {
	// Read and reconstruct a mesh. 
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	m.hullsize = GlobalMembersTriangle.reconstruct(m, b, in.trianglelist, in.triangleattributelist, in.trianglearealist, in.numberoftriangles, in.numberofcorners, in.numberoftriangleattributes, in.segmentlist, in.segmentmarkerlist, in.numberofsegments);
//#else
	m.hullsize = GlobalMembersTriangle.reconstruct(m, b, b.inelefilename, b.areafilename, b.inpolyfilename, polyfile);
//#endif // not TRILIBRARY
  }
  else
  {
	m.hullsize = GlobalMembersTriangle.delaunay(m, b); // Triangulate the vertices.
  }
//#endif // not CDT_ONLY

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! NO_TIMER
  if (b.quiet == 0)
  {
	gettimeofday(tv2, tz);
	if (b.refine != 0)
	{
	  System.out.print("Mesh reconstruction");
	}
	else
	{
	  System.out.print("Delaunay");
	}
	System.out.printf(" milliseconds:  %ld\n", 1000l * (tv2.tv_sec - tv1.tv_sec) + (tv2.tv_usec - tv1.tv_usec) / 1000l);
  }
//#endif // not NO_TIMER

  // Ensure that no vertex can be mistaken for a triangular bounding 
  //   box vertex in insertvertex().                                 
  m.infvertex1 = (GlobalMembersTriangle.REAL) null;
  m.infvertex2 = (GlobalMembersTriangle.REAL) null;
  m.infvertex3 = (GlobalMembersTriangle.REAL) null;

  if (b.usesegments != 0)
  {
	m.checksegments = 1; // Segments will be introduced next.
	if (b.refine == 0)
	{
	  // Insert PSLG segments and/or convex hull segments. 
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	  GlobalMembersTriangle.formskeleton(m, b, in.segmentlist, in.segmentmarkerlist, in.numberofsegments);
//#else
	  GlobalMembersTriangle.formskeleton(m, b, polyfile, b.inpolyfilename);
//#endif // not TRILIBRARY
	}
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! NO_TIMER
  if (b.quiet == 0)
  {
	gettimeofday(tv3, tz);
	if (b.usesegments != 0 && b.refine == 0)
	{
	  System.out.printf("Segment milliseconds:  %ld\n", 1000l * (tv3.tv_sec - tv2.tv_sec) + (tv3.tv_usec - tv2.tv_usec) / 1000l);
	}
  }
//#endif // not NO_TIMER

  if (b.poly != 0 && (m.triangles.items > 0))
  {
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	holearray = in.holelist;
	m.holes = in.numberofholes;
	regionarray = in.regionlist;
	m.regions = in.numberofregions;
//#else
	GlobalMembersTriangle.readholes(m, b, polyfile, b.inpolyfilename, holearray, m.holes, regionarray, m.regions);
//#endif // not TRILIBRARY
	if (b.refine == 0)
	{
	  // Carve out holes and concavities. 
	  GlobalMembersTriangle.carveholes(m, b, holearray, m.holes, regionarray, m.regions);
	}
	}
  else
  {
	// Without a PSLG, there can be no holes or regional attributes   
	//   or area constraints.  The following are set to zero to avoid 
	//   an accidental free() later.                                  
	m.holes = 0;
	m.regions = 0;
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! NO_TIMER
  if (b.quiet == 0)
  {
	gettimeofday(tv4, tz);
	if (b.poly != 0 && b.refine == 0)
	{
	  System.out.printf("Hole milliseconds:  %ld\n", 1000l * (tv4.tv_sec - tv3.tv_sec) + (tv4.tv_usec - tv3.tv_usec) / 1000l);
	}
  }
//#endif // not NO_TIMER

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
  if (b.quality != 0 && (m.triangles.items > 0))
  {
	GlobalMembersTriangle.enforcequality(m, b); // Enforce angle and area constraints.
  }
//#endif // not CDT_ONLY

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! NO_TIMER
  if (b.quiet == 0)
  {
	gettimeofday(tv5, tz);
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
	if (b.quality != 0)
	{
	  System.out.printf("Quality milliseconds:  %ld\n", 1000l * (tv5.tv_sec - tv4.tv_sec) + (tv5.tv_usec - tv4.tv_usec) / 1000l);
	}
//#endif // not CDT_ONLY
  }
//#endif // not NO_TIMER

  // Calculate the number of edges. 
  m.edges = (3l m.triangles.items + m.hullsize) / 2l;

  if (b.order > 1)
  {
	GlobalMembersTriangle.highorder(m, b); // Promote elements to higher polynomial order.
  }
  if (b.quiet == 0)
  {
	System.out.print("\n");
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
  if (b.jettison != 0)
  {
	out.numberofpoints = m.vertices.items - m.undeads;
  }
  else
  {
	out.numberofpoints = m.vertices.items;
  }
  out.numberofpointattributes = m.nextras;
  out.numberoftriangles = m.triangles.items;
  out.numberofcorners = (b.order + 1) * (b.order + 2) / 2;
  out.numberoftriangleattributes = m.eextras;
  out.numberofedges = m.edges;
  if (b.usesegments != 0)
  {
	out.numberofsegments = m.subsegs.items;
  }
  else
  {
	out.numberofsegments = m.hullsize;
  }
  if (vorout != (triangulateio) null)
  {
	vorout.numberofpoints = m.triangles.items;
	vorout.numberofpointattributes = m.nextras;
	vorout.numberofedges = m.edges;
  }
//#endif // TRILIBRARY
  // If not using iteration numbers, don't write a .node file if one was 
  //   read, because the original one would be overwritten!              
  if (b.nonodewritten != 0 || (b.noiterationnum != 0 && m.readnodefile != 0))
  {
	if (b.quiet == 0)
	{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	  System.out.print("NOT writing vertices.\n");
//#else
	  System.out.print("NOT writing a .node file.\n");
//#endif // not TRILIBRARY
	}
	GlobalMembersTriangle.numbernodes(m, b); // We must remember to number the vertices.
	}
  else
  {
	// writenodes() numbers the vertices too. 
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	GlobalMembersTriangle.writenodes(m, b, out.pointlist, out.pointattributelist, out.pointmarkerlist);
//#else
	GlobalMembersTriangle.writenodes(m, b, b.outnodefilename, argc, argv);
//#endif // TRILIBRARY
  }
  if (b.noelewritten != 0)
  {
	if (b.quiet == 0)
	{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	  System.out.print("NOT writing triangles.\n");
//#else
	  System.out.print("NOT writing an .ele file.\n");
//#endif // not TRILIBRARY
	}
	}
  else
  {
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	GlobalMembersTriangle.writeelements(m, b, out.trianglelist, out.triangleattributelist);
//#else
	GlobalMembersTriangle.writeelements(m, b, b.outelefilename, argc, argv);
//#endif // not TRILIBRARY
  }
  // The -c switch (convex switch) causes a PSLG to be written 
  //   even if none was read.                                  
  if (b.poly != 0 || b.convex != 0)
  {
	// If not using iteration numbers, don't overwrite the .poly file. 
	if (b.nopolywritten != 0 || b.noiterationnum != 0)
	{
	  if (b.quiet == 0)
	  {
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
		System.out.print("NOT writing segments.\n");
//#else
		System.out.print("NOT writing a .poly file.\n");
//#endif // not TRILIBRARY
	  }
	  }
	else
	{
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	  GlobalMembersTriangle.writepoly(m, b, out.segmentlist, out.segmentmarkerlist);
	  out.numberofholes = m.holes;
	  out.numberofregions = m.regions;
	  if (b.poly != 0)
	  {
		out.holelist = in.holelist;
		out.regionlist = in.regionlist;
	  }
	  else
	  {
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		out.holelist = (GlobalMembersTriangle.REAL) null;
//C++ TO JAVA CONVERTER TODO TASK: The #define macro REAL was defined in alternate ways and cannot be replaced in-line:
		out.regionlist = (GlobalMembersTriangle.REAL) null;
	  }
//#else
	  GlobalMembersTriangle.writepoly(m, b, b.outpolyfilename, holearray, m.holes, regionarray, m.regions, argc, argv);
//#endif // not TRILIBRARY
	}
  }
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! CDT_ONLY
  if (m.regions > 0)
  {
	GlobalMembersTriangle.trifree((int) regionarray);
  }
//#endif // not CDT_ONLY
  if (m.holes > 0)
  {
	GlobalMembersTriangle.trifree((int) holearray);
  }
  if (b.geomview != 0)
  {
	GlobalMembersTriangle.writeoff(m, b, b.offfilename, argc, argv);
  }
//#endif // not TRILIBRARY
  if (b.edgesout != 0)
  {
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	GlobalMembersTriangle.writeedges(m, b, out.edgelist, out.edgemarkerlist);
//#else
	GlobalMembersTriangle.writeedges(m, b, b.edgefilename, argc, argv);
//#endif // not TRILIBRARY
  }
  if (b.voronoi != 0)
  {
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	GlobalMembersTriangle.writevoronoi(m, b, vorout.pointlist, vorout.pointattributelist, vorout.pointmarkerlist, vorout.edgelist, vorout.edgemarkerlist, vorout.normlist);
//#else
	GlobalMembersTriangle.writevoronoi(m, b, b.vnodefilename, b.vedgefilename, argc, argv);
//#endif // not TRILIBRARY
  }
  if (b.neighbors != 0)
  {
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if TRILIBRARY
	GlobalMembersTriangle.writeneighbors(m, b, out.neighborlist);
//#else
	GlobalMembersTriangle.writeneighbors(m, b, b.neighborfilename, argc, argv);
//#endif // not TRILIBRARY
  }

  if (b.quiet == 0)
  {
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! NO_TIMER
	gettimeofday(tv6, tz);
	System.out.printf("\nOutput milliseconds:  %ld\n", 1000l * (tv6.tv_sec - tv5.tv_sec) + (tv6.tv_usec - tv5.tv_usec) / 1000l);
	System.out.printf("Total running milliseconds:  %ld\n", 1000l * (tv6.tv_sec - tv0.tv_sec) + (tv6.tv_usec - tv0.tv_usec) / 1000l);
//#endif // not NO_TIMER

	GlobalMembersTriangle.statistics(m, b);
  }

//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! REDUCED
  if (b.docheck != 0)
  {
	GlobalMembersTriangle.checkmesh(m, b);
	GlobalMembersTriangle.checkdelaunay(m, b);
  }
//#endif // not REDUCED

  GlobalMembersTriangle.triangledeinit(m, b);
//C++ TO JAVA CONVERTER TODO TASK: There is no preprocessor in Java:
//#if ! TRILIBRARY
  return 0;
//#endif // not TRILIBRARY
}


final class DefineConstantsTriangle
{
	public static final int FILENAMESIZE = 2048;
	public static final int INPUTLINESIZE = 1024;
	public static final int TRIPERBLOCK = 4092;
	public static final int SUBSEGPERBLOCK = 508;
	public static final int VERTEXPERBLOCK = 4092;
	public static final int VIRUSPERBLOCK = 1020;
	public static final int BADSUBSEGPERBLOCK = 252;
	public static final int BADTRIPERBLOCK = 4092;
	public static final int FLIPSTACKERPERBLOCK = 252;
	public static final int SPLAYNODEPERBLOCK = 508;
	public static final int INPUTVERTEX = 0;
	public static final int SEGMENTVERTEX = 1;
	public static final int FREEVERTEX = 2;
	public static final int SAMPLEFACTOR = 11;
	public static final int SAMPLERATE = 10;
	public static final double PI = 3.141592653589793238462643383279502884197169399375105820974944592308;
	public static final double SQUAREROOTTWO = 1.4142135623730950488016887242096980785696718753769480732;
	public static final double ONETHIRD = 0.333333333333333333333333333333333333333333333333333333333333;
	public static final int _FPU_CONTROL_H = 1;
	public static final int _FPU_MASK_IM = 0x01;
	public static final int _FPU_MASK_DM = 0x02;
	public static final int _FPU_MASK_ZM = 0x04;
	public static final int _FPU_MASK_OM = 0x08;
	public static final int _FPU_MASK_UM = 0x10;
	public static final int _FPU_MASK_PM = 0x20;
	public static final int _FPU_EXTENDED = 0x300;
	public static final int _FPU_DOUBLE = 0x200;
	public static final int _FPU_SINGLE = 0x0;
	public static final int _FPU_RC_NEAREST = 0x0;
	public static final int _FPU_RC_DOWN = 0x400;
	public static final int _FPU_RC_UP = 0x800;
	public static final int _FPU_RC_ZERO = 0xC00;
	public static final int _FPU_RESERVED = 0xF0C0;
	public static final int _FPU_DEFAULT = 0x037f;
	public static final int _FPU_IEEE = 0x037f;
	public static final int STARTINDEX = 0;
//C++ TO JAVA CONVERTER TODO TASK: The following #define constant was defined in alternate ways:
	public static final int STARTINDEX = 1;
}
//----------------------------------------------------------------------------------------
//	Copyright  2006 - 2008 Tangible Software Solutions Inc.
//
//	This class provides miscellaneous helper methods for strings.
//----------------------------------------------------------------------------------------
final class StringHelper
{
	//------------------------------------------------------------------------------------
	//	This method allows replacing a single character in a string, to help convert
	//	C++ code where a single character in a character array is replaced.
	//------------------------------------------------------------------------------------
	static String changeCharacter(String sourcestring, int charindex, char changechar)
	{
		return (charindex > 0 ? sourcestring.substring(0, charindex) : "")
			+ Character.toString(changechar) + (charindex < sourcestring.length() - 1 ? sourcestring.substring(charindex + 1) : "");
	}
}
//----------------------------------------------------------------------------------------
//	Copyright  2006 - 2008 Tangible Software Solutions Inc.
//
//	This class is used to simulate the ability to pass arguments by reference in Java.
//----------------------------------------------------------------------------------------
final class RefObject<T>
{
	T argvalue;
	RefObject(T refarg)
	{
		argvalue = refarg;
	}
}